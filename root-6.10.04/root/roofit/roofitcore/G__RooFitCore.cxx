// Do NOT change. Changes will be lost next time file is generated

#define R__DICTIONARY_FILENAME G__RooFitCore

/*******************************************************************/
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#define G__DICTIONARY
#include "RConfig.h"
#include "TClass.h"
#include "TDictAttributeMap.h"
#include "TInterpreter.h"
#include "TROOT.h"
#include "TBuffer.h"
#include "TMemberInspector.h"
#include "TInterpreter.h"
#include "TVirtualMutex.h"
#include "TError.h"

#ifndef G__ROOT
#define G__ROOT
#endif

#include "RtypesImp.h"
#include "TIsAProxy.h"
#include "TFileMergeInfo.h"
#include <algorithm>
#include "TCollectionProxyInfo.h"
/*******************************************************************/

#include "TDataMember.h"

// Since CINT ignores the std namespace, we need to do so in this file.
namespace std {} using namespace std;

#include "TBuffer.h"
#include "TVirtualObject.h"
#include <vector>
#include "TSchemaHelper.h"


// Header files passed as explicit arguments
#include "Roo1DTable.h"
#include "RooAbsArg.h"
#include "RooAbsBinning.h"
#include "RooAbsCategory.h"
#include "RooAbsCategoryLValue.h"
#include "RooAbsCollection.h"
#include "RooAbsData.h"
#include "RooAbsFunc.h"
#include "RooAbsGenContext.h"
#include "RooAbsTestStatistic.h"
#include "RooAbsHiddenReal.h"
#include "RooAbsIntegrator.h"
#include "RooAbsLValue.h"
#include "RooAbsMCStudyModule.h"
#include "RooAbsOptTestStatistic.h"
#include "RooAbsPdf.h"
#include "RooAbsProxy.h"
#include "RooAbsReal.h"
#include "RooAbsRealLValue.h"
#include "RooAbsRootFinder.h"
#include "RooAbsString.h"
#include "RooAcceptReject.h"
#include "RooAdaptiveGaussKronrodIntegrator1D.h"
#include "RooAddGenContext.h"
#include "RooAddition.h"
#include "RooAddModel.h"
#include "RooAICRegistry.h"
#include "RooArgList.h"
#include "RooArgProxy.h"
#include "RooArgSet.h"
#include "RooBanner.h"
#include "RooBinning.h"
#include "RooBinnedGenContext.h"
#include "RooBrentRootFinder.h"
#include "RooCategory.h"
#include "RooCategoryProxy.h"
#include "RooCategorySharedProperties.h"
#include "RooCatType.h"
#include "RooChi2Var.h"
#include "RooClassFactory.h"
#include "RooCmdArg.h"
#include "RooCmdConfig.h"
#include "RooConstVar.h"
#include "RooConvCoefVar.h"
#include "RooConvGenContext.h"
#include "RooConvIntegrandBinding.h"
#include "RooCurve.h"
#include "RooCustomizer.h"
#include "RooDataHist.h"
#include "RooDataProjBinding.h"
#include "RooDataSet.h"
#include "RooDirItem.h"
#include "RooDLLSignificanceMCSModule.h"
#include "RooAbsAnaConvPdf.h"
#include "RooAddPdf.h"
#include "RooEfficiency.h"
#include "RooEffProd.h"
#include "RooExtendPdf.h"
#include "RooDouble.h"
#include "RooEffGenContext.h"
#include "RooEllipse.h"
#include "RooErrorHandler.h"
#include "RooErrorVar.h"
#include "RooFit.h"
#include "RooFitResult.h"
#include "RooFormula.h"
#include "RooFormulaVar.h"
#include "RooGaussKronrodIntegrator1D.h"
#include "RooGenContext.h"
#include "RooGenericPdf.h"
#include "RooGenProdProj.h"
#include "RooGlobalFunc.h"
#include "RooGrid.h"
#include "RooHashTable.h"
#include "RooHistError.h"
#include "RooHist.h"
#include "RooImproperIntegrator1D.h"
#include "RooBinIntegrator.h"
#include "RooIntegrator1D.h"
#include "RooIntegrator2D.h"
#include "RooIntegratorBinding.h"
#include "RooInt.h"
#include "RooInvTransform.h"
#include "RooLinearVar.h"
#include "RooLinkedListElem.h"
#include "RooLinkedList.h"
#include "RooLinkedListIter.h"
#include "RooLinTransBinning.h"
#include "RooList.h"
#include "RooListProxy.h"
#include "RooMapCatEntry.h"
#include "RooMappedCategory.h"
#include "RooMath.h"
#include "RooMCIntegrator.h"
#include "RooMinuit.h"
#include "RooMPSentinel.h"
#include "RooMultiCategory.h"
#include "RooMultiCatIter.h"
#include "RooNameReg.h"
#include "RooNameSet.h"
#include "RooNLLVar.h"
#include "RooNormSetCache.h"
#include "RooNumber.h"
#include "RooNumConvolution.h"
#include "RooNumConvPdf.h"
#include "RooNumIntConfig.h"
#include "RooNumIntFactory.h"
#include "RooPlotable.h"
#include "RooPlot.h"
#include "RooPolyVar.h"
#include "RooPrintable.h"
#include "RooProdGenContext.h"
#include "RooProduct.h"
#include "RooPullVar.h"
#include "RooQuasiRandomGenerator.h"
#include "RooRandom.h"
#include "RooRandomizeParamMCSModule.h"
#include "RooRangeBinning.h"
#include "RooRealAnalytic.h"
#include "RooRealBinding.h"
#include "RooRealConstant.h"
#include "RooRealIntegral.h"
#include "RooRealMPFE.h"
#include "RooRealProxy.h"
#include "RooRealVar.h"
#include "RooRealVarSharedProperties.h"
#include "RooRefCountList.h"
#include "RooScaledFunc.h"
#include "RooSegmentedIntegrator1D.h"
#include "RooSegmentedIntegrator2D.h"
#include "RooSetPair.h"
#include "RooSetProxy.h"
#include "RooSharedProperties.h"
#include "RooSharedPropertiesList.h"
#include "RooSimGenContext.h"
#include "RooSimSplitGenContext.h"
#include "RooStreamParser.h"
#include "RooStringVar.h"
#include "RooSuperCategory.h"
#include "RooTable.h"
#include "RooThreshEntry.h"
#include "RooThresholdCategory.h"
#include "RooTObjWrap.h"
#include "RooTrace.h"
#include "RooUniformBinning.h"
#include "RooSimultaneous.h"
#include "RooRealSumPdf.h"
#include "RooResolutionModel.h"
#include "RooProdPdf.h"
#include "RooMCStudy.h"
#include "RooSimPdfBuilder.h"
#include "RooTruthModel.h"
#include "RooMsgService.h"
#include "RooProjectedPdf.h"
#include "RooWorkspace.h"
#include "RooProfileLL.h"
#include "RooAbsCachedPdf.h"
#include "RooAbsSelfCachedPdf.h"
#include "RooHistPdf.h"
#include "RooCachedPdf.h"
#include "RooFFTConvPdf.h"
#include "RooDataHistSliceIter.h"
#include "RooCacheManager.h"
#include "RooAbsCache.h"
#include "RooAbsCacheElement.h"
#include "RooObjCacheManager.h"
#include "RooExtendedTerm.h"
#include "RooSentinel.h"
#include "RooParamBinning.h"
#include "RooConstraintSum.h"
#include "RooRecursiveFraction.h"
#include "RooDataWeightedAverage.h"
#include "RooSimWSTool.h"
#include "RooFracRemainder.h"
#include "RooAbsCachedReal.h"
#include "RooAbsSelfCachedReal.h"
#include "RooCachedReal.h"
#include "RooNumCdf.h"
#include "RooChangeTracker.h"
#include "RooNumRunningInt.h"
#include "RooHistFunc.h"
#include "RooExpensiveObjectCache.h"
#include "RooBinningCategory.h"
#include "RooCintUtils.h"
#include "RooFactoryWSTool.h"
#include "RooTFoamBinding.h"
#include "RooFunctor.h"
#include "RooDerivative.h"
#include "RooGenFunction.h"
#include "RooMultiGenFunction.h"
#include "RooAdaptiveIntegratorND.h"
#include "RooAbsNumGenerator.h"
#include "RooFoamGenerator.h"
#include "RooNumGenConfig.h"
#include "RooNumGenFactory.h"
#include "RooMultiVarGaussian.h"
#include "RooXYChi2Var.h"
#include "RooAbsDataStore.h"
#include "RooTreeDataStore.h"
#include "RooTreeData.h"
#include "RooMinimizer.h"
#include "RooMinimizerFcn.h"
#include "RooMoment.h"
#include "RooStudyManager.h"
#include "RooAbsStudy.h"
#include "RooGenFitStudy.h"
#include "RooProofDriverSelector.h"
#include "RooStudyPackage.h"
#include "RooCompositeDataStore.h"
#include "RooRangeBoolean.h"
#include "RooVectorDataStore.h"
#include "RooUnitTest.h"
#include "RooExtendedBinding.h"
#include "RooAbsMoment.h"
#include "RooFirstMoment.h"
#include "RooSecondMoment.h"

// Header files passed via #pragma extra_include

namespace RooFit {
   namespace ROOT {
      inline ::ROOT::TGenericClassInfo *GenerateInitInstance();
      static TClass *RooFit_Dictionary();

      // Function generating the singleton type initializer
      inline ::ROOT::TGenericClassInfo *GenerateInitInstance()
      {
         static ::ROOT::TGenericClassInfo 
            instance("RooFit", 0 /*version*/, "RooPrintable.h", 64,
                     ::ROOT::Internal::DefineBehavior((void*)0,(void*)0),
                     &RooFit_Dictionary, 0);
         return &instance;
      }
      // Insure that the inline function is _not_ optimized away by the compiler
      ::ROOT::TGenericClassInfo *(*_R__UNIQUE_DICT_(InitFunctionKeeper))() = &GenerateInitInstance;  
      // Static variable to force the class initialization
      static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstance(); R__UseDummy(_R__UNIQUE_DICT_(Init));

      // Dictionary for non-ClassDef classes
      static TClass *RooFit_Dictionary() {
         return GenerateInitInstance()->GetClass();
      }

   }
}

namespace RooFitShortHand {
   namespace ROOT {
      inline ::ROOT::TGenericClassInfo *GenerateInitInstance();
      static TClass *RooFitShortHand_Dictionary();

      // Function generating the singleton type initializer
      inline ::ROOT::TGenericClassInfo *GenerateInitInstance()
      {
         static ::ROOT::TGenericClassInfo 
            instance("RooFitShortHand", 0 /*version*/, "RooGlobalFunc.h", 304,
                     ::ROOT::Internal::DefineBehavior((void*)0,(void*)0),
                     &RooFitShortHand_Dictionary, 0);
         return &instance;
      }
      // Insure that the inline function is _not_ optimized away by the compiler
      ::ROOT::TGenericClassInfo *(*_R__UNIQUE_DICT_(InitFunctionKeeper))() = &GenerateInitInstance;  
      // Static variable to force the class initialization
      static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstance(); R__UseDummy(_R__UNIQUE_DICT_(Init));

      // Dictionary for non-ClassDef classes
      static TClass *RooFitShortHand_Dictionary() {
         return GenerateInitInstance()->GetClass();
      }

   }
}

namespace RooCintUtils {
   namespace ROOT {
      inline ::ROOT::TGenericClassInfo *GenerateInitInstance();
      static TClass *RooCintUtils_Dictionary();

      // Function generating the singleton type initializer
      inline ::ROOT::TGenericClassInfo *GenerateInitInstance()
      {
         static ::ROOT::TGenericClassInfo 
            instance("RooCintUtils", 0 /*version*/, "RooCintUtils.h", 22,
                     ::ROOT::Internal::DefineBehavior((void*)0,(void*)0),
                     &RooCintUtils_Dictionary, 0);
         return &instance;
      }
      // Insure that the inline function is _not_ optimized away by the compiler
      ::ROOT::TGenericClassInfo *(*_R__UNIQUE_DICT_(InitFunctionKeeper))() = &GenerateInitInstance;  
      // Static variable to force the class initialization
      static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstance(); R__UseDummy(_R__UNIQUE_DICT_(Init));

      // Dictionary for non-ClassDef classes
      static TClass *RooCintUtils_Dictionary() {
         return GenerateInitInstance()->GetClass();
      }

   }
}

namespace ROOT {
   static TClass *pairlEintcORooLinkedListElemmUgR_Dictionary();
   static void pairlEintcORooLinkedListElemmUgR_TClassManip(TClass*);
   static void *new_pairlEintcORooLinkedListElemmUgR(void *p = 0);
   static void *newArray_pairlEintcORooLinkedListElemmUgR(Long_t size, void *p);
   static void delete_pairlEintcORooLinkedListElemmUgR(void *p);
   static void deleteArray_pairlEintcORooLinkedListElemmUgR(void *p);
   static void destruct_pairlEintcORooLinkedListElemmUgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<int,RooLinkedListElem*>*)
   {
      pair<int,RooLinkedListElem*> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<int,RooLinkedListElem*>));
      static ::ROOT::TGenericClassInfo 
         instance("pair<int,RooLinkedListElem*>", "string", 198,
                  typeid(pair<int,RooLinkedListElem*>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &pairlEintcORooLinkedListElemmUgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<int,RooLinkedListElem*>) );
      instance.SetNew(&new_pairlEintcORooLinkedListElemmUgR);
      instance.SetNewArray(&newArray_pairlEintcORooLinkedListElemmUgR);
      instance.SetDelete(&delete_pairlEintcORooLinkedListElemmUgR);
      instance.SetDeleteArray(&deleteArray_pairlEintcORooLinkedListElemmUgR);
      instance.SetDestructor(&destruct_pairlEintcORooLinkedListElemmUgR);
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const pair<int,RooLinkedListElem*>*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *pairlEintcORooLinkedListElemmUgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const pair<int,RooLinkedListElem*>*)0x0)->GetClass();
      pairlEintcORooLinkedListElemmUgR_TClassManip(theClass);
   return theClass;
   }

   static void pairlEintcORooLinkedListElemmUgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *pairlEstringcORooAbsDatamUgR_Dictionary();
   static void pairlEstringcORooAbsDatamUgR_TClassManip(TClass*);
   static void *new_pairlEstringcORooAbsDatamUgR(void *p = 0);
   static void *newArray_pairlEstringcORooAbsDatamUgR(Long_t size, void *p);
   static void delete_pairlEstringcORooAbsDatamUgR(void *p);
   static void deleteArray_pairlEstringcORooAbsDatamUgR(void *p);
   static void destruct_pairlEstringcORooAbsDatamUgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<string,RooAbsData*>*)
   {
      pair<string,RooAbsData*> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<string,RooAbsData*>));
      static ::ROOT::TGenericClassInfo 
         instance("pair<string,RooAbsData*>", "string", 198,
                  typeid(pair<string,RooAbsData*>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &pairlEstringcORooAbsDatamUgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<string,RooAbsData*>) );
      instance.SetNew(&new_pairlEstringcORooAbsDatamUgR);
      instance.SetNewArray(&newArray_pairlEstringcORooAbsDatamUgR);
      instance.SetDelete(&delete_pairlEstringcORooAbsDatamUgR);
      instance.SetDeleteArray(&deleteArray_pairlEstringcORooAbsDatamUgR);
      instance.SetDestructor(&destruct_pairlEstringcORooAbsDatamUgR);

      ::ROOT::AddClassAlternate("pair<string,RooAbsData*>","pair<std::string,RooAbsData*>");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const pair<string,RooAbsData*>*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *pairlEstringcORooAbsDatamUgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const pair<string,RooAbsData*>*)0x0)->GetClass();
      pairlEstringcORooAbsDatamUgR_TClassManip(theClass);
   return theClass;
   }

   static void pairlEstringcORooAbsDatamUgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static void *new_RooPrintable(void *p = 0);
   static void *newArray_RooPrintable(Long_t size, void *p);
   static void delete_RooPrintable(void *p);
   static void deleteArray_RooPrintable(void *p);
   static void destruct_RooPrintable(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooPrintable*)
   {
      ::RooPrintable *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooPrintable >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooPrintable", ::RooPrintable::Class_Version(), "RooPrintable.h", 25,
                  typeid(::RooPrintable), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooPrintable::Dictionary, isa_proxy, 4,
                  sizeof(::RooPrintable) );
      instance.SetNew(&new_RooPrintable);
      instance.SetNewArray(&newArray_RooPrintable);
      instance.SetDelete(&delete_RooPrintable);
      instance.SetDeleteArray(&deleteArray_RooPrintable);
      instance.SetDestructor(&destruct_RooPrintable);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooPrintable*)
   {
      return GenerateInitInstanceLocal((::RooPrintable*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooPrintable*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooLinkedListElem(void *p = 0);
   static void *newArray_RooLinkedListElem(Long_t size, void *p);
   static void delete_RooLinkedListElem(void *p);
   static void deleteArray_RooLinkedListElem(void *p);
   static void destruct_RooLinkedListElem(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooLinkedListElem*)
   {
      ::RooLinkedListElem *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooLinkedListElem >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooLinkedListElem", ::RooLinkedListElem::Class_Version(), "RooLinkedListElem.h", 30,
                  typeid(::RooLinkedListElem), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooLinkedListElem::Dictionary, isa_proxy, 4,
                  sizeof(::RooLinkedListElem) );
      instance.SetNew(&new_RooLinkedListElem);
      instance.SetNewArray(&newArray_RooLinkedListElem);
      instance.SetDelete(&delete_RooLinkedListElem);
      instance.SetDeleteArray(&deleteArray_RooLinkedListElem);
      instance.SetDestructor(&destruct_RooLinkedListElem);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooLinkedListElem*)
   {
      return GenerateInitInstanceLocal((::RooLinkedListElem*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooLinkedListElem*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooHashTable(void *p = 0);
   static void *newArray_RooHashTable(Long_t size, void *p);
   static void delete_RooHashTable(void *p);
   static void deleteArray_RooHashTable(void *p);
   static void destruct_RooHashTable(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooHashTable*)
   {
      ::RooHashTable *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooHashTable >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooHashTable", ::RooHashTable::Class_Version(), "RooHashTable.h", 28,
                  typeid(::RooHashTable), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooHashTable::Dictionary, isa_proxy, 4,
                  sizeof(::RooHashTable) );
      instance.SetNew(&new_RooHashTable);
      instance.SetNewArray(&newArray_RooHashTable);
      instance.SetDelete(&delete_RooHashTable);
      instance.SetDeleteArray(&deleteArray_RooHashTable);
      instance.SetDestructor(&destruct_RooHashTable);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooHashTable*)
   {
      return GenerateInitInstanceLocal((::RooHashTable*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooHashTable*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooLinkedList(void *p = 0);
   static void *newArray_RooLinkedList(Long_t size, void *p);
   static void delete_RooLinkedList(void *p);
   static void deleteArray_RooLinkedList(void *p);
   static void destruct_RooLinkedList(void *p);
   static void streamer_RooLinkedList(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooLinkedList*)
   {
      ::RooLinkedList *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooLinkedList >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooLinkedList", ::RooLinkedList::Class_Version(), "RooLinkedList.h", 35,
                  typeid(::RooLinkedList), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooLinkedList::Dictionary, isa_proxy, 17,
                  sizeof(::RooLinkedList) );
      instance.SetNew(&new_RooLinkedList);
      instance.SetNewArray(&newArray_RooLinkedList);
      instance.SetDelete(&delete_RooLinkedList);
      instance.SetDeleteArray(&deleteArray_RooLinkedList);
      instance.SetDestructor(&destruct_RooLinkedList);
      instance.SetStreamerFunc(&streamer_RooLinkedList);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooLinkedList*)
   {
      return GenerateInitInstanceLocal((::RooLinkedList*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooLinkedList*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooRefCountList(void *p = 0);
   static void *newArray_RooRefCountList(Long_t size, void *p);
   static void delete_RooRefCountList(void *p);
   static void deleteArray_RooRefCountList(void *p);
   static void destruct_RooRefCountList(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooRefCountList*)
   {
      ::RooRefCountList *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooRefCountList >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooRefCountList", ::RooRefCountList::Class_Version(), "RooRefCountList.h", 21,
                  typeid(::RooRefCountList), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooRefCountList::Dictionary, isa_proxy, 4,
                  sizeof(::RooRefCountList) );
      instance.SetNew(&new_RooRefCountList);
      instance.SetNewArray(&newArray_RooRefCountList);
      instance.SetDelete(&delete_RooRefCountList);
      instance.SetDeleteArray(&deleteArray_RooRefCountList);
      instance.SetDestructor(&destruct_RooRefCountList);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooRefCountList*)
   {
      return GenerateInitInstanceLocal((::RooRefCountList*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooRefCountList*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooAbsCache(void *p = 0);
   static void *newArray_RooAbsCache(Long_t size, void *p);
   static void delete_RooAbsCache(void *p);
   static void deleteArray_RooAbsCache(void *p);
   static void destruct_RooAbsCache(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooAbsCache*)
   {
      ::RooAbsCache *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooAbsCache >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooAbsCache", ::RooAbsCache::Class_Version(), "RooAbsCache.h", 27,
                  typeid(::RooAbsCache), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooAbsCache::Dictionary, isa_proxy, 4,
                  sizeof(::RooAbsCache) );
      instance.SetNew(&new_RooAbsCache);
      instance.SetNewArray(&newArray_RooAbsCache);
      instance.SetDelete(&delete_RooAbsCache);
      instance.SetDeleteArray(&deleteArray_RooAbsCache);
      instance.SetDestructor(&destruct_RooAbsCache);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooAbsCache*)
   {
      return GenerateInitInstanceLocal((::RooAbsCache*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooAbsCache*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static TClass *RooFIter_Dictionary();
   static void RooFIter_TClassManip(TClass*);
   static void *new_RooFIter(void *p = 0);
   static void *newArray_RooFIter(Long_t size, void *p);
   static void delete_RooFIter(void *p);
   static void deleteArray_RooFIter(void *p);
   static void destruct_RooFIter(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooFIter*)
   {
      ::RooFIter *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::RooFIter));
      static ::ROOT::TGenericClassInfo 
         instance("RooFIter", "RooLinkedListIter.h", 23,
                  typeid(::RooFIter), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &RooFIter_Dictionary, isa_proxy, 4,
                  sizeof(::RooFIter) );
      instance.SetNew(&new_RooFIter);
      instance.SetNewArray(&newArray_RooFIter);
      instance.SetDelete(&delete_RooFIter);
      instance.SetDeleteArray(&deleteArray_RooFIter);
      instance.SetDestructor(&destruct_RooFIter);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooFIter*)
   {
      return GenerateInitInstanceLocal((::RooFIter*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooFIter*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *RooFIter_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::RooFIter*)0x0)->GetClass();
      RooFIter_TClassManip(theClass);
   return theClass;
   }

   static void RooFIter_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static void *new_RooLinkedListIter(void *p = 0);
   static void *newArray_RooLinkedListIter(Long_t size, void *p);
   static void delete_RooLinkedListIter(void *p);
   static void deleteArray_RooLinkedListIter(void *p);
   static void destruct_RooLinkedListIter(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooLinkedListIter*)
   {
      ::RooLinkedListIter *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooLinkedListIter >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooLinkedListIter", ::RooLinkedListIter::Class_Version(), "RooLinkedListIter.h", 43,
                  typeid(::RooLinkedListIter), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooLinkedListIter::Dictionary, isa_proxy, 4,
                  sizeof(::RooLinkedListIter) );
      instance.SetNew(&new_RooLinkedListIter);
      instance.SetNewArray(&newArray_RooLinkedListIter);
      instance.SetDelete(&delete_RooLinkedListIter);
      instance.SetDeleteArray(&deleteArray_RooLinkedListIter);
      instance.SetDestructor(&destruct_RooLinkedListIter);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooLinkedListIter*)
   {
      return GenerateInitInstanceLocal((::RooLinkedListIter*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooLinkedListIter*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooNameReg(void *p);
   static void deleteArray_RooNameReg(void *p);
   static void destruct_RooNameReg(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooNameReg*)
   {
      ::RooNameReg *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooNameReg >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooNameReg", ::RooNameReg::Class_Version(), "RooNameReg.h", 23,
                  typeid(::RooNameReg), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooNameReg::Dictionary, isa_proxy, 4,
                  sizeof(::RooNameReg) );
      instance.SetDelete(&delete_RooNameReg);
      instance.SetDeleteArray(&deleteArray_RooNameReg);
      instance.SetDestructor(&destruct_RooNameReg);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooNameReg*)
   {
      return GenerateInitInstanceLocal((::RooNameReg*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooNameReg*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static TClass *stacklERooAbsArgmUcOdequelERooAbsArgmUgRsPgR_Dictionary();
   static void stacklERooAbsArgmUcOdequelERooAbsArgmUgRsPgR_TClassManip(TClass*);
   static void *new_stacklERooAbsArgmUcOdequelERooAbsArgmUgRsPgR(void *p = 0);
   static void *newArray_stacklERooAbsArgmUcOdequelERooAbsArgmUgRsPgR(Long_t size, void *p);
   static void delete_stacklERooAbsArgmUcOdequelERooAbsArgmUgRsPgR(void *p);
   static void deleteArray_stacklERooAbsArgmUcOdequelERooAbsArgmUgRsPgR(void *p);
   static void destruct_stacklERooAbsArgmUcOdequelERooAbsArgmUgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::stack<RooAbsArg*,deque<RooAbsArg*> >*)
   {
      ::stack<RooAbsArg*,deque<RooAbsArg*> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::stack<RooAbsArg*,deque<RooAbsArg*> >));
      static ::ROOT::TGenericClassInfo 
         instance("stack<RooAbsArg*,deque<RooAbsArg*> >", "stack", 99,
                  typeid(::stack<RooAbsArg*,deque<RooAbsArg*> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &stacklERooAbsArgmUcOdequelERooAbsArgmUgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::stack<RooAbsArg*,deque<RooAbsArg*> >) );
      instance.SetNew(&new_stacklERooAbsArgmUcOdequelERooAbsArgmUgRsPgR);
      instance.SetNewArray(&newArray_stacklERooAbsArgmUcOdequelERooAbsArgmUgRsPgR);
      instance.SetDelete(&delete_stacklERooAbsArgmUcOdequelERooAbsArgmUgRsPgR);
      instance.SetDeleteArray(&deleteArray_stacklERooAbsArgmUcOdequelERooAbsArgmUgRsPgR);
      instance.SetDestructor(&destruct_stacklERooAbsArgmUcOdequelERooAbsArgmUgRsPgR);
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::stack<RooAbsArg*,deque<RooAbsArg*> >*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *stacklERooAbsArgmUcOdequelERooAbsArgmUgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::stack<RooAbsArg*,deque<RooAbsArg*> >*)0x0)->GetClass();
      stacklERooAbsArgmUcOdequelERooAbsArgmUgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void stacklERooAbsArgmUcOdequelERooAbsArgmUgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static void *new_RooRefArray(void *p = 0);
   static void *newArray_RooRefArray(Long_t size, void *p);
   static void delete_RooRefArray(void *p);
   static void deleteArray_RooRefArray(void *p);
   static void destruct_RooRefArray(void *p);
   static void streamer_RooRefArray(TBuffer &buf, void *obj);
   static Long64_t merge_RooRefArray(void *obj, TCollection *coll,TFileMergeInfo *info);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooRefArray*)
   {
      ::RooRefArray *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooRefArray >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooRefArray", ::RooRefArray::Class_Version(), "RooAbsArg.h", 54,
                  typeid(::RooRefArray), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooRefArray::Dictionary, isa_proxy, 17,
                  sizeof(::RooRefArray) );
      instance.SetNew(&new_RooRefArray);
      instance.SetNewArray(&newArray_RooRefArray);
      instance.SetDelete(&delete_RooRefArray);
      instance.SetDeleteArray(&deleteArray_RooRefArray);
      instance.SetDestructor(&destruct_RooRefArray);
      instance.SetStreamerFunc(&streamer_RooRefArray);
      instance.SetMerge(&merge_RooRefArray);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooRefArray*)
   {
      return GenerateInitInstanceLocal((::RooRefArray*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooRefArray*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooAbsArg(void *p);
   static void deleteArray_RooAbsArg(void *p);
   static void destruct_RooAbsArg(void *p);
   static void streamer_RooAbsArg(TBuffer &buf, void *obj);

   // Schema evolution read functions
   static void read_RooAbsArg_0( char* target, TVirtualObject *oldObj )
   {
      //--- Automatically generated variables ---
#if 0
      static Int_t id__proxyList = oldObj->GetId("_proxyList");
#endif
      struct RooAbsArg_Onfile {
         TList &_proxyList;
         RooAbsArg_Onfile(TList &onfile__proxyList ): _proxyList(onfile__proxyList) {}
      };
      static Long_t offset_Onfile_RooAbsArg__proxyList = oldObj->GetClass()->GetDataMemberOffset("_proxyList");
      char *onfile_add = (char*)oldObj->GetObject();
      RooAbsArg_Onfile onfile(
         *(TList*)(onfile_add+offset_Onfile_RooAbsArg__proxyList) );

      static TClassRef cls("RooAbsArg");
      static Long_t offset__proxyList = cls->GetDataMemberOffset("_proxyList");
      RooRefArray& _proxyList = *(RooRefArray*)(target+offset__proxyList);
      RooAbsArg* newObj = (RooAbsArg*)target;
      // Supress warning message.
      if (oldObj) {}

      if (newObj) {}

      //--- User's code ---
      TIterator* iter = onfile._proxyList.MakeIterator() ; TObject* tmpObj ; while ((tmpObj = iter->Next())) { _proxyList.Add(tmpObj) ; } delete iter ; 
   }
   static void read_RooAbsArg_1( char* target, TVirtualObject *oldObj )
   {
      //--- Automatically generated variables ---
#if 0
      static Int_t id__proxyList = oldObj->GetId("_proxyList");
#endif
      struct RooAbsArg_Onfile {
         TRefArray &_proxyList;
         RooAbsArg_Onfile(TRefArray &onfile__proxyList ): _proxyList(onfile__proxyList) {}
      };
      static Long_t offset_Onfile_RooAbsArg__proxyList = oldObj->GetClass()->GetDataMemberOffset("_proxyList");
      char *onfile_add = (char*)oldObj->GetObject();
      RooAbsArg_Onfile onfile(
         *(TRefArray*)(onfile_add+offset_Onfile_RooAbsArg__proxyList) );

      static TClassRef cls("RooAbsArg");
      static Long_t offset__proxyList = cls->GetDataMemberOffset("_proxyList");
      RooRefArray& _proxyList = *(RooRefArray*)(target+offset__proxyList);
      RooAbsArg* newObj = (RooAbsArg*)target;
      // Supress warning message.
      if (oldObj) {}

      if (newObj) {}

      //--- User's code ---
      _proxyList.GetSize() ; if (onfile._proxyList.GetSize()>0) { RooAbsArg::_ioEvoList[newObj] = new TRefArray(onfile._proxyList) ; } 
   }

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooAbsArg*)
   {
      ::RooAbsArg *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooAbsArg >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooAbsArg", ::RooAbsArg::Class_Version(), "RooAbsArg.h", 66,
                  typeid(::RooAbsArg), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooAbsArg::Dictionary, isa_proxy, 17,
                  sizeof(::RooAbsArg) );
      instance.SetDelete(&delete_RooAbsArg);
      instance.SetDeleteArray(&deleteArray_RooAbsArg);
      instance.SetDestructor(&destruct_RooAbsArg);
      instance.SetStreamerFunc(&streamer_RooAbsArg);

      ROOT::Internal::TSchemaHelper* rule;

      // the io read rules
      std::vector<ROOT::Internal::TSchemaHelper> readrules(2);
      rule = &readrules[0];
      rule->fSourceClass = "RooAbsArg";
      rule->fTarget      = "_proxyList";
      rule->fSource      = "TList _proxyList";
      rule->fFunctionPtr = (void *)TFunc2void( read_RooAbsArg_0);
      rule->fCode        = " TIterator* iter = onfile._proxyList.MakeIterator() ; TObject* tmpObj ; while ((tmpObj = iter->Next())) { _proxyList.Add(tmpObj) ; } delete iter ; ";
      rule->fVersion     = "[1-4]";
      rule = &readrules[1];
      rule->fSourceClass = "RooAbsArg";
      rule->fTarget      = "_proxyList";
      rule->fSource      = "TRefArray _proxyList";
      rule->fFunctionPtr = (void *)TFunc2void( read_RooAbsArg_1);
      rule->fCode        = " _proxyList.GetSize() ; if (onfile._proxyList.GetSize()>0) { RooAbsArg::_ioEvoList[newObj] = new TRefArray(onfile._proxyList) ; } ";
      rule->fVersion     = "[5]";
      instance.SetReadRules( readrules );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooAbsArg*)
   {
      return GenerateInitInstanceLocal((::RooAbsArg*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooAbsArg*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooCatType(void *p = 0);
   static void *newArray_RooCatType(Long_t size, void *p);
   static void delete_RooCatType(void *p);
   static void deleteArray_RooCatType(void *p);
   static void destruct_RooCatType(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooCatType*)
   {
      ::RooCatType *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooCatType >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooCatType", ::RooCatType::Class_Version(), "RooCatType.h", 22,
                  typeid(::RooCatType), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooCatType::Dictionary, isa_proxy, 4,
                  sizeof(::RooCatType) );
      instance.SetNew(&new_RooCatType);
      instance.SetNewArray(&newArray_RooCatType);
      instance.SetDelete(&delete_RooCatType);
      instance.SetDeleteArray(&deleteArray_RooCatType);
      instance.SetDestructor(&destruct_RooCatType);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooCatType*)
   {
      return GenerateInitInstanceLocal((::RooCatType*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooCatType*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooAbsCategory(void *p);
   static void deleteArray_RooAbsCategory(void *p);
   static void destruct_RooAbsCategory(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooAbsCategory*)
   {
      ::RooAbsCategory *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooAbsCategory >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooAbsCategory", ::RooAbsCategory::Class_Version(), "RooAbsCategory.h", 29,
                  typeid(::RooAbsCategory), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooAbsCategory::Dictionary, isa_proxy, 4,
                  sizeof(::RooAbsCategory) );
      instance.SetDelete(&delete_RooAbsCategory);
      instance.SetDeleteArray(&deleteArray_RooAbsCategory);
      instance.SetDestructor(&destruct_RooAbsCategory);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooAbsCategory*)
   {
      return GenerateInitInstanceLocal((::RooAbsCategory*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooAbsCategory*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooTable(void *p);
   static void deleteArray_RooTable(void *p);
   static void destruct_RooTable(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooTable*)
   {
      ::RooTable *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooTable >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooTable", ::RooTable::Class_Version(), "RooTable.h", 24,
                  typeid(::RooTable), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooTable::Dictionary, isa_proxy, 4,
                  sizeof(::RooTable) );
      instance.SetDelete(&delete_RooTable);
      instance.SetDeleteArray(&deleteArray_RooTable);
      instance.SetDestructor(&destruct_RooTable);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooTable*)
   {
      return GenerateInitInstanceLocal((::RooTable*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooTable*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_Roo1DTable(void *p = 0);
   static void *newArray_Roo1DTable(Long_t size, void *p);
   static void delete_Roo1DTable(void *p);
   static void deleteArray_Roo1DTable(void *p);
   static void destruct_Roo1DTable(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::Roo1DTable*)
   {
      ::Roo1DTable *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::Roo1DTable >(0);
      static ::ROOT::TGenericClassInfo 
         instance("Roo1DTable", ::Roo1DTable::Class_Version(), "Roo1DTable.h", 24,
                  typeid(::Roo1DTable), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::Roo1DTable::Dictionary, isa_proxy, 4,
                  sizeof(::Roo1DTable) );
      instance.SetNew(&new_Roo1DTable);
      instance.SetNewArray(&newArray_Roo1DTable);
      instance.SetDelete(&delete_Roo1DTable);
      instance.SetDeleteArray(&deleteArray_Roo1DTable);
      instance.SetDestructor(&destruct_Roo1DTable);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::Roo1DTable*)
   {
      return GenerateInitInstanceLocal((::Roo1DTable*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::Roo1DTable*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooAbsBinning(void *p);
   static void deleteArray_RooAbsBinning(void *p);
   static void destruct_RooAbsBinning(void *p);
   static void streamer_RooAbsBinning(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooAbsBinning*)
   {
      ::RooAbsBinning *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooAbsBinning >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooAbsBinning", ::RooAbsBinning::Class_Version(), "RooAbsBinning.h", 26,
                  typeid(::RooAbsBinning), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooAbsBinning::Dictionary, isa_proxy, 17,
                  sizeof(::RooAbsBinning) );
      instance.SetDelete(&delete_RooAbsBinning);
      instance.SetDeleteArray(&deleteArray_RooAbsBinning);
      instance.SetDestructor(&destruct_RooAbsBinning);
      instance.SetStreamerFunc(&streamer_RooAbsBinning);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooAbsBinning*)
   {
      return GenerateInitInstanceLocal((::RooAbsBinning*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooAbsBinning*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooAbsLValue(void *p);
   static void deleteArray_RooAbsLValue(void *p);
   static void destruct_RooAbsLValue(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooAbsLValue*)
   {
      ::RooAbsLValue *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooAbsLValue >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooAbsLValue", ::RooAbsLValue::Class_Version(), "RooAbsLValue.h", 26,
                  typeid(::RooAbsLValue), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooAbsLValue::Dictionary, isa_proxy, 4,
                  sizeof(::RooAbsLValue) );
      instance.SetDelete(&delete_RooAbsLValue);
      instance.SetDeleteArray(&deleteArray_RooAbsLValue);
      instance.SetDestructor(&destruct_RooAbsLValue);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooAbsLValue*)
   {
      return GenerateInitInstanceLocal((::RooAbsLValue*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooAbsLValue*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooAbsCategoryLValue(void *p);
   static void deleteArray_RooAbsCategoryLValue(void *p);
   static void destruct_RooAbsCategoryLValue(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooAbsCategoryLValue*)
   {
      ::RooAbsCategoryLValue *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooAbsCategoryLValue >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooAbsCategoryLValue", ::RooAbsCategoryLValue::Class_Version(), "RooAbsCategoryLValue.h", 22,
                  typeid(::RooAbsCategoryLValue), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooAbsCategoryLValue::Dictionary, isa_proxy, 4,
                  sizeof(::RooAbsCategoryLValue) );
      instance.SetDelete(&delete_RooAbsCategoryLValue);
      instance.SetDeleteArray(&deleteArray_RooAbsCategoryLValue);
      instance.SetDestructor(&destruct_RooAbsCategoryLValue);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooAbsCategoryLValue*)
   {
      return GenerateInitInstanceLocal((::RooAbsCategoryLValue*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooAbsCategoryLValue*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooCmdArg(void *p = 0);
   static void *newArray_RooCmdArg(Long_t size, void *p);
   static void delete_RooCmdArg(void *p);
   static void deleteArray_RooCmdArg(void *p);
   static void destruct_RooCmdArg(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooCmdArg*)
   {
      ::RooCmdArg *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooCmdArg >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooCmdArg", ::RooCmdArg::Class_Version(), "RooCmdArg.h", 27,
                  typeid(::RooCmdArg), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooCmdArg::Dictionary, isa_proxy, 4,
                  sizeof(::RooCmdArg) );
      instance.SetNew(&new_RooCmdArg);
      instance.SetNewArray(&newArray_RooCmdArg);
      instance.SetDelete(&delete_RooCmdArg);
      instance.SetDeleteArray(&deleteArray_RooCmdArg);
      instance.SetDestructor(&destruct_RooCmdArg);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooCmdArg*)
   {
      return GenerateInitInstanceLocal((::RooCmdArg*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooCmdArg*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooAbsCollection(void *p);
   static void deleteArray_RooAbsCollection(void *p);
   static void destruct_RooAbsCollection(void *p);

   // Schema evolution read functions
   static void read_RooAbsCollection_0( char* target, TVirtualObject *oldObj )
   {
      //--- Automatically generated variables ---
      static TClassRef cls("RooAbsCollection");
      static Long_t offset__allRRV = cls->GetDataMemberOffset("_allRRV");
      Bool_t& _allRRV = *(Bool_t*)(target+offset__allRRV);
      RooAbsCollection* newObj = (RooAbsCollection*)target;
      // Supress warning message.
      if (oldObj) {}

      if (newObj) {}

      //--- User's code ---
      _allRRV=kFALSE ; 
   }

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooAbsCollection*)
   {
      ::RooAbsCollection *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooAbsCollection >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooAbsCollection", ::RooAbsCollection::Class_Version(), "RooAbsCollection.h", 27,
                  typeid(::RooAbsCollection), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooAbsCollection::Dictionary, isa_proxy, 4,
                  sizeof(::RooAbsCollection) );
      instance.SetDelete(&delete_RooAbsCollection);
      instance.SetDeleteArray(&deleteArray_RooAbsCollection);
      instance.SetDestructor(&destruct_RooAbsCollection);

      ROOT::Internal::TSchemaHelper* rule;

      // the io read rules
      std::vector<ROOT::Internal::TSchemaHelper> readrules(1);
      rule = &readrules[0];
      rule->fSourceClass = "RooAbsCollection";
      rule->fTarget      = "_allRRV";
      rule->fSource      = "";
      rule->fFunctionPtr = (void *)TFunc2void( read_RooAbsCollection_0);
      rule->fCode        = " _allRRV=kFALSE ; ";
      rule->fVersion     = "[1]";
      instance.SetReadRules( readrules );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooAbsCollection*)
   {
      return GenerateInitInstanceLocal((::RooAbsCollection*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooAbsCollection*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooArgSet(void *p = 0);
   static void *newArray_RooArgSet(Long_t size, void *p);
   static void delete_RooArgSet(void *p);
   static void deleteArray_RooArgSet(void *p);
   static void destruct_RooArgSet(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooArgSet*)
   {
      ::RooArgSet *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooArgSet >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooArgSet", ::RooArgSet::Class_Version(), "RooArgSet.h", 26,
                  typeid(::RooArgSet), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooArgSet::Dictionary, isa_proxy, 4,
                  sizeof(::RooArgSet) );
      instance.SetNew(&new_RooArgSet);
      instance.SetNewArray(&newArray_RooArgSet);
      instance.SetDelete(&delete_RooArgSet);
      instance.SetDeleteArray(&deleteArray_RooArgSet);
      instance.SetDestructor(&destruct_RooArgSet);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooArgSet*)
   {
      return GenerateInitInstanceLocal((::RooArgSet*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooArgSet*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooPlotable(void *p);
   static void deleteArray_RooPlotable(void *p);
   static void destruct_RooPlotable(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooPlotable*)
   {
      ::RooPlotable *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooPlotable >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooPlotable", ::RooPlotable::Class_Version(), "RooPlotable.h", 26,
                  typeid(::RooPlotable), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooPlotable::Dictionary, isa_proxy, 4,
                  sizeof(::RooPlotable) );
      instance.SetDelete(&delete_RooPlotable);
      instance.SetDeleteArray(&deleteArray_RooPlotable);
      instance.SetDestructor(&destruct_RooPlotable);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooPlotable*)
   {
      return GenerateInitInstanceLocal((::RooPlotable*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooPlotable*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooCurve(void *p = 0);
   static void *newArray_RooCurve(Long_t size, void *p);
   static void delete_RooCurve(void *p);
   static void deleteArray_RooCurve(void *p);
   static void destruct_RooCurve(void *p);
   static Long64_t merge_RooCurve(void *obj, TCollection *coll,TFileMergeInfo *info);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooCurve*)
   {
      ::RooCurve *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooCurve >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooCurve", ::RooCurve::Class_Version(), "RooCurve.h", 32,
                  typeid(::RooCurve), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooCurve::Dictionary, isa_proxy, 4,
                  sizeof(::RooCurve) );
      instance.SetNew(&new_RooCurve);
      instance.SetNewArray(&newArray_RooCurve);
      instance.SetDelete(&delete_RooCurve);
      instance.SetDeleteArray(&deleteArray_RooCurve);
      instance.SetDestructor(&destruct_RooCurve);
      instance.SetMerge(&merge_RooCurve);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooCurve*)
   {
      return GenerateInitInstanceLocal((::RooCurve*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooCurve*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooArgList(void *p = 0);
   static void *newArray_RooArgList(Long_t size, void *p);
   static void delete_RooArgList(void *p);
   static void deleteArray_RooArgList(void *p);
   static void destruct_RooArgList(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooArgList*)
   {
      ::RooArgList *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooArgList >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooArgList", ::RooArgList::Class_Version(), "RooArgList.h", 21,
                  typeid(::RooArgList), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooArgList::Dictionary, isa_proxy, 4,
                  sizeof(::RooArgList) );
      instance.SetNew(&new_RooArgList);
      instance.SetNewArray(&newArray_RooArgList);
      instance.SetDelete(&delete_RooArgList);
      instance.SetDeleteArray(&deleteArray_RooArgList);
      instance.SetDestructor(&destruct_RooArgList);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooArgList*)
   {
      return GenerateInitInstanceLocal((::RooArgList*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooArgList*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static TClass *RooGlobalFunc_Dictionary();
   static void RooGlobalFunc_TClassManip(TClass*);
   static void *new_RooGlobalFunc(void *p = 0);
   static void *newArray_RooGlobalFunc(Long_t size, void *p);
   static void delete_RooGlobalFunc(void *p);
   static void deleteArray_RooGlobalFunc(void *p);
   static void destruct_RooGlobalFunc(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooGlobalFunc*)
   {
      ::RooGlobalFunc *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::RooGlobalFunc));
      static ::ROOT::TGenericClassInfo 
         instance("RooGlobalFunc", "RooGlobalFunc.h", 338,
                  typeid(::RooGlobalFunc), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &RooGlobalFunc_Dictionary, isa_proxy, 0,
                  sizeof(::RooGlobalFunc) );
      instance.SetNew(&new_RooGlobalFunc);
      instance.SetNewArray(&newArray_RooGlobalFunc);
      instance.SetDelete(&delete_RooGlobalFunc);
      instance.SetDeleteArray(&deleteArray_RooGlobalFunc);
      instance.SetDestructor(&destruct_RooGlobalFunc);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooGlobalFunc*)
   {
      return GenerateInitInstanceLocal((::RooGlobalFunc*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooGlobalFunc*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *RooGlobalFunc_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::RooGlobalFunc*)0x0)->GetClass();
      RooGlobalFunc_TClassManip(theClass);
   return theClass;
   }

   static void RooGlobalFunc_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static void delete_RooAbsReal(void *p);
   static void deleteArray_RooAbsReal(void *p);
   static void destruct_RooAbsReal(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooAbsReal*)
   {
      ::RooAbsReal *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooAbsReal >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooAbsReal", ::RooAbsReal::Class_Version(), "RooAbsReal.h", 53,
                  typeid(::RooAbsReal), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooAbsReal::Dictionary, isa_proxy, 4,
                  sizeof(::RooAbsReal) );
      instance.SetDelete(&delete_RooAbsReal);
      instance.SetDeleteArray(&deleteArray_RooAbsReal);
      instance.SetDestructor(&destruct_RooAbsReal);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooAbsReal*)
   {
      return GenerateInitInstanceLocal((::RooAbsReal*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooAbsReal*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooFormula(void *p = 0);
   static void *newArray_RooFormula(Long_t size, void *p);
   static void delete_RooFormula(void *p);
   static void deleteArray_RooFormula(void *p);
   static void destruct_RooFormula(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooFormula*)
   {
      ::RooFormula *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooFormula >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooFormula", ::RooFormula::Class_Version(), "RooFormula.h", 27,
                  typeid(::RooFormula), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooFormula::Dictionary, isa_proxy, 4,
                  sizeof(::RooFormula) );
      instance.SetNew(&new_RooFormula);
      instance.SetNewArray(&newArray_RooFormula);
      instance.SetDelete(&delete_RooFormula);
      instance.SetDeleteArray(&deleteArray_RooFormula);
      instance.SetDestructor(&destruct_RooFormula);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooFormula*)
   {
      return GenerateInitInstanceLocal((::RooFormula*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooFormula*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooAbsProxy(void *p);
   static void deleteArray_RooAbsProxy(void *p);
   static void destruct_RooAbsProxy(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooAbsProxy*)
   {
      ::RooAbsProxy *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooAbsProxy >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooAbsProxy", ::RooAbsProxy::Class_Version(), "RooAbsProxy.h", 31,
                  typeid(::RooAbsProxy), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooAbsProxy::Dictionary, isa_proxy, 4,
                  sizeof(::RooAbsProxy) );
      instance.SetDelete(&delete_RooAbsProxy);
      instance.SetDeleteArray(&deleteArray_RooAbsProxy);
      instance.SetDestructor(&destruct_RooAbsProxy);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooAbsProxy*)
   {
      return GenerateInitInstanceLocal((::RooAbsProxy*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooAbsProxy*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooListProxy(void *p = 0);
   static void *newArray_RooListProxy(Long_t size, void *p);
   static void delete_RooListProxy(void *p);
   static void deleteArray_RooListProxy(void *p);
   static void destruct_RooListProxy(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooListProxy*)
   {
      ::RooListProxy *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooListProxy >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooListProxy", ::RooListProxy::Class_Version(), "RooListProxy.h", 25,
                  typeid(::RooListProxy), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooListProxy::Dictionary, isa_proxy, 4,
                  sizeof(::RooListProxy) );
      instance.SetNew(&new_RooListProxy);
      instance.SetNewArray(&newArray_RooListProxy);
      instance.SetDelete(&delete_RooListProxy);
      instance.SetDeleteArray(&deleteArray_RooListProxy);
      instance.SetDestructor(&destruct_RooListProxy);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooListProxy*)
   {
      return GenerateInitInstanceLocal((::RooListProxy*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooListProxy*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooTrace(void *p = 0);
   static void *newArray_RooTrace(Long_t size, void *p);
   static void delete_RooTrace(void *p);
   static void deleteArray_RooTrace(void *p);
   static void destruct_RooTrace(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooTrace*)
   {
      ::RooTrace *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooTrace >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooTrace", ::RooTrace::Class_Version(), "RooTrace.h", 25,
                  typeid(::RooTrace), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooTrace::Dictionary, isa_proxy, 4,
                  sizeof(::RooTrace) );
      instance.SetNew(&new_RooTrace);
      instance.SetNewArray(&newArray_RooTrace);
      instance.SetDelete(&delete_RooTrace);
      instance.SetDeleteArray(&deleteArray_RooTrace);
      instance.SetDestructor(&destruct_RooTrace);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooTrace*)
   {
      return GenerateInitInstanceLocal((::RooTrace*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooTrace*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooFormulaVar(void *p = 0);
   static void *newArray_RooFormulaVar(Long_t size, void *p);
   static void delete_RooFormulaVar(void *p);
   static void deleteArray_RooFormulaVar(void *p);
   static void destruct_RooFormulaVar(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooFormulaVar*)
   {
      ::RooFormulaVar *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooFormulaVar >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooFormulaVar", ::RooFormulaVar::Class_Version(), "RooFormulaVar.h", 27,
                  typeid(::RooFormulaVar), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooFormulaVar::Dictionary, isa_proxy, 4,
                  sizeof(::RooFormulaVar) );
      instance.SetNew(&new_RooFormulaVar);
      instance.SetNewArray(&newArray_RooFormulaVar);
      instance.SetDelete(&delete_RooFormulaVar);
      instance.SetDeleteArray(&deleteArray_RooFormulaVar);
      instance.SetDestructor(&destruct_RooFormulaVar);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooFormulaVar*)
   {
      return GenerateInitInstanceLocal((::RooFormulaVar*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooFormulaVar*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooAbsData(void *p);
   static void deleteArray_RooAbsData(void *p);
   static void destruct_RooAbsData(void *p);
   static void streamer_RooAbsData(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooAbsData*)
   {
      ::RooAbsData *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooAbsData >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooAbsData", ::RooAbsData::Class_Version(), "RooAbsData.h", 37,
                  typeid(::RooAbsData), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooAbsData::Dictionary, isa_proxy, 17,
                  sizeof(::RooAbsData) );
      instance.SetDelete(&delete_RooAbsData);
      instance.SetDeleteArray(&deleteArray_RooAbsData);
      instance.SetDestructor(&destruct_RooAbsData);
      instance.SetStreamerFunc(&streamer_RooAbsData);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooAbsData*)
   {
      return GenerateInitInstanceLocal((::RooAbsData*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooAbsData*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooAbsFunc(void *p);
   static void deleteArray_RooAbsFunc(void *p);
   static void destruct_RooAbsFunc(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooAbsFunc*)
   {
      ::RooAbsFunc *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooAbsFunc >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooAbsFunc", ::RooAbsFunc::Class_Version(), "RooAbsFunc.h", 23,
                  typeid(::RooAbsFunc), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooAbsFunc::Dictionary, isa_proxy, 4,
                  sizeof(::RooAbsFunc) );
      instance.SetDelete(&delete_RooAbsFunc);
      instance.SetDeleteArray(&deleteArray_RooAbsFunc);
      instance.SetDestructor(&destruct_RooAbsFunc);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooAbsFunc*)
   {
      return GenerateInitInstanceLocal((::RooAbsFunc*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooAbsFunc*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooNameSet(void *p = 0);
   static void *newArray_RooNameSet(Long_t size, void *p);
   static void delete_RooNameSet(void *p);
   static void deleteArray_RooNameSet(void *p);
   static void destruct_RooNameSet(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooNameSet*)
   {
      ::RooNameSet *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooNameSet >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooNameSet", ::RooNameSet::Class_Version(), "RooNameSet.h", 24,
                  typeid(::RooNameSet), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooNameSet::Dictionary, isa_proxy, 4,
                  sizeof(::RooNameSet) );
      instance.SetNew(&new_RooNameSet);
      instance.SetNewArray(&newArray_RooNameSet);
      instance.SetDelete(&delete_RooNameSet);
      instance.SetDeleteArray(&deleteArray_RooNameSet);
      instance.SetDestructor(&destruct_RooNameSet);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooNameSet*)
   {
      return GenerateInitInstanceLocal((::RooNameSet*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooNameSet*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooNormSetCache(void *p = 0);
   static void *newArray_RooNormSetCache(Long_t size, void *p);
   static void delete_RooNormSetCache(void *p);
   static void deleteArray_RooNormSetCache(void *p);
   static void destruct_RooNormSetCache(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooNormSetCache*)
   {
      ::RooNormSetCache *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooNormSetCache >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooNormSetCache", ::RooNormSetCache::Class_Version(), "RooNormSetCache.h", 31,
                  typeid(::RooNormSetCache), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooNormSetCache::Dictionary, isa_proxy, 4,
                  sizeof(::RooNormSetCache) );
      instance.SetNew(&new_RooNormSetCache);
      instance.SetNewArray(&newArray_RooNormSetCache);
      instance.SetDelete(&delete_RooNormSetCache);
      instance.SetDeleteArray(&deleteArray_RooNormSetCache);
      instance.SetDestructor(&destruct_RooNormSetCache);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooNormSetCache*)
   {
      return GenerateInitInstanceLocal((::RooNormSetCache*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooNormSetCache*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooAbsCacheElement(void *p);
   static void deleteArray_RooAbsCacheElement(void *p);
   static void destruct_RooAbsCacheElement(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooAbsCacheElement*)
   {
      ::RooAbsCacheElement *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooAbsCacheElement >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooAbsCacheElement", ::RooAbsCacheElement::Class_Version(), "RooAbsCacheElement.h", 26,
                  typeid(::RooAbsCacheElement), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooAbsCacheElement::Dictionary, isa_proxy, 4,
                  sizeof(::RooAbsCacheElement) );
      instance.SetDelete(&delete_RooAbsCacheElement);
      instance.SetDeleteArray(&deleteArray_RooAbsCacheElement);
      instance.SetDestructor(&destruct_RooAbsCacheElement);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooAbsCacheElement*)
   {
      return GenerateInitInstanceLocal((::RooAbsCacheElement*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooAbsCacheElement*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooMsgService(void *p);
   static void deleteArray_RooMsgService(void *p);
   static void destruct_RooMsgService(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooMsgService*)
   {
      ::RooMsgService *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooMsgService >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooMsgService", ::RooMsgService::Class_Version(), "RooMsgService.h", 104,
                  typeid(::RooMsgService), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooMsgService::Dictionary, isa_proxy, 4,
                  sizeof(::RooMsgService) );
      instance.SetDelete(&delete_RooMsgService);
      instance.SetDeleteArray(&deleteArray_RooMsgService);
      instance.SetDestructor(&destruct_RooMsgService);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooMsgService*)
   {
      return GenerateInitInstanceLocal((::RooMsgService*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooMsgService*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static TClass *RooMsgServicecLcLStreamConfig_Dictionary();
   static void RooMsgServicecLcLStreamConfig_TClassManip(TClass*);
   static void *new_RooMsgServicecLcLStreamConfig(void *p = 0);
   static void *newArray_RooMsgServicecLcLStreamConfig(Long_t size, void *p);
   static void delete_RooMsgServicecLcLStreamConfig(void *p);
   static void deleteArray_RooMsgServicecLcLStreamConfig(void *p);
   static void destruct_RooMsgServicecLcLStreamConfig(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooMsgService::StreamConfig*)
   {
      ::RooMsgService::StreamConfig *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::RooMsgService::StreamConfig));
      static ::ROOT::TGenericClassInfo 
         instance("RooMsgService::StreamConfig", "RooMsgService.h", 109,
                  typeid(::RooMsgService::StreamConfig), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &RooMsgServicecLcLStreamConfig_Dictionary, isa_proxy, 4,
                  sizeof(::RooMsgService::StreamConfig) );
      instance.SetNew(&new_RooMsgServicecLcLStreamConfig);
      instance.SetNewArray(&newArray_RooMsgServicecLcLStreamConfig);
      instance.SetDelete(&delete_RooMsgServicecLcLStreamConfig);
      instance.SetDeleteArray(&deleteArray_RooMsgServicecLcLStreamConfig);
      instance.SetDestructor(&destruct_RooMsgServicecLcLStreamConfig);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooMsgService::StreamConfig*)
   {
      return GenerateInitInstanceLocal((::RooMsgService::StreamConfig*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooMsgService::StreamConfig*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *RooMsgServicecLcLStreamConfig_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::RooMsgService::StreamConfig*)0x0)->GetClass();
      RooMsgServicecLcLStreamConfig_TClassManip(theClass);
   return theClass;
   }

   static void RooMsgServicecLcLStreamConfig_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *RooCacheManagerlERooAbsCacheElementgR_Dictionary();
   static void RooCacheManagerlERooAbsCacheElementgR_TClassManip(TClass*);
   static void *new_RooCacheManagerlERooAbsCacheElementgR(void *p = 0);
   static void *newArray_RooCacheManagerlERooAbsCacheElementgR(Long_t size, void *p);
   static void delete_RooCacheManagerlERooAbsCacheElementgR(void *p);
   static void deleteArray_RooCacheManagerlERooAbsCacheElementgR(void *p);
   static void destruct_RooCacheManagerlERooAbsCacheElementgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooCacheManager<RooAbsCacheElement>*)
   {
      ::RooCacheManager<RooAbsCacheElement> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooCacheManager<RooAbsCacheElement> >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooCacheManager<RooAbsCacheElement>", ::RooCacheManager<RooAbsCacheElement>::Class_Version(), "RooCacheManager.h", 35,
                  typeid(::RooCacheManager<RooAbsCacheElement>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &RooCacheManagerlERooAbsCacheElementgR_Dictionary, isa_proxy, 4,
                  sizeof(::RooCacheManager<RooAbsCacheElement>) );
      instance.SetNew(&new_RooCacheManagerlERooAbsCacheElementgR);
      instance.SetNewArray(&newArray_RooCacheManagerlERooAbsCacheElementgR);
      instance.SetDelete(&delete_RooCacheManagerlERooAbsCacheElementgR);
      instance.SetDeleteArray(&deleteArray_RooCacheManagerlERooAbsCacheElementgR);
      instance.SetDestructor(&destruct_RooCacheManagerlERooAbsCacheElementgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooCacheManager<RooAbsCacheElement>*)
   {
      return GenerateInitInstanceLocal((::RooCacheManager<RooAbsCacheElement>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooCacheManager<RooAbsCacheElement>*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *RooCacheManagerlERooAbsCacheElementgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::RooCacheManager<RooAbsCacheElement>*)0x0)->GetClass();
      RooCacheManagerlERooAbsCacheElementgR_TClassManip(theClass);
   return theClass;
   }

   static void RooCacheManagerlERooAbsCacheElementgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *RooCacheManagerlEvectorlEdoublegRsPgR_Dictionary();
   static void RooCacheManagerlEvectorlEdoublegRsPgR_TClassManip(TClass*);
   static void *new_RooCacheManagerlEvectorlEdoublegRsPgR(void *p = 0);
   static void *newArray_RooCacheManagerlEvectorlEdoublegRsPgR(Long_t size, void *p);
   static void delete_RooCacheManagerlEvectorlEdoublegRsPgR(void *p);
   static void deleteArray_RooCacheManagerlEvectorlEdoublegRsPgR(void *p);
   static void destruct_RooCacheManagerlEvectorlEdoublegRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooCacheManager<vector<double> >*)
   {
      ::RooCacheManager<vector<double> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooCacheManager<vector<double> > >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooCacheManager<vector<double> >", ::RooCacheManager<vector<double> >::Class_Version(), "RooCacheManager.h", 35,
                  typeid(::RooCacheManager<vector<double> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &RooCacheManagerlEvectorlEdoublegRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(::RooCacheManager<vector<double> >) );
      instance.SetNew(&new_RooCacheManagerlEvectorlEdoublegRsPgR);
      instance.SetNewArray(&newArray_RooCacheManagerlEvectorlEdoublegRsPgR);
      instance.SetDelete(&delete_RooCacheManagerlEvectorlEdoublegRsPgR);
      instance.SetDeleteArray(&deleteArray_RooCacheManagerlEvectorlEdoublegRsPgR);
      instance.SetDestructor(&destruct_RooCacheManagerlEvectorlEdoublegRsPgR);

      ::ROOT::AddClassAlternate("RooCacheManager<vector<double> >","RooCacheManager<std::vector<double> >");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooCacheManager<vector<double> >*)
   {
      return GenerateInitInstanceLocal((::RooCacheManager<vector<double> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooCacheManager<vector<double> >*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *RooCacheManagerlEvectorlEdoublegRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::RooCacheManager<vector<double> >*)0x0)->GetClass();
      RooCacheManagerlEvectorlEdoublegRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void RooCacheManagerlEvectorlEdoublegRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static void *new_RooObjCacheManager(void *p = 0);
   static void *newArray_RooObjCacheManager(Long_t size, void *p);
   static void delete_RooObjCacheManager(void *p);
   static void deleteArray_RooObjCacheManager(void *p);
   static void destruct_RooObjCacheManager(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooObjCacheManager*)
   {
      ::RooObjCacheManager *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooObjCacheManager >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooObjCacheManager", ::RooObjCacheManager::Class_Version(), "RooObjCacheManager.h", 33,
                  typeid(::RooObjCacheManager), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooObjCacheManager::Dictionary, isa_proxy, 4,
                  sizeof(::RooObjCacheManager) );
      instance.SetNew(&new_RooObjCacheManager);
      instance.SetNewArray(&newArray_RooObjCacheManager);
      instance.SetDelete(&delete_RooObjCacheManager);
      instance.SetDeleteArray(&deleteArray_RooObjCacheManager);
      instance.SetDestructor(&destruct_RooObjCacheManager);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooObjCacheManager*)
   {
      return GenerateInitInstanceLocal((::RooObjCacheManager*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooObjCacheManager*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooAbsPdf(void *p);
   static void deleteArray_RooAbsPdf(void *p);
   static void destruct_RooAbsPdf(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooAbsPdf*)
   {
      ::RooAbsPdf *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooAbsPdf >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooAbsPdf", ::RooAbsPdf::Class_Version(), "RooAbsPdf.h", 41,
                  typeid(::RooAbsPdf), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooAbsPdf::Dictionary, isa_proxy, 4,
                  sizeof(::RooAbsPdf) );
      instance.SetDelete(&delete_RooAbsPdf);
      instance.SetDeleteArray(&deleteArray_RooAbsPdf);
      instance.SetDestructor(&destruct_RooAbsPdf);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooAbsPdf*)
   {
      return GenerateInitInstanceLocal((::RooAbsPdf*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooAbsPdf*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooAbsPdfcLcLGenSpec(void *p = 0);
   static void *newArray_RooAbsPdfcLcLGenSpec(Long_t size, void *p);
   static void delete_RooAbsPdfcLcLGenSpec(void *p);
   static void deleteArray_RooAbsPdfcLcLGenSpec(void *p);
   static void destruct_RooAbsPdfcLcLGenSpec(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooAbsPdf::GenSpec*)
   {
      ::RooAbsPdf::GenSpec *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooAbsPdf::GenSpec >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooAbsPdf::GenSpec", ::RooAbsPdf::GenSpec::Class_Version(), "RooAbsPdf.h", 65,
                  typeid(::RooAbsPdf::GenSpec), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooAbsPdf::GenSpec::Dictionary, isa_proxy, 4,
                  sizeof(::RooAbsPdf::GenSpec) );
      instance.SetNew(&new_RooAbsPdfcLcLGenSpec);
      instance.SetNewArray(&newArray_RooAbsPdfcLcLGenSpec);
      instance.SetDelete(&delete_RooAbsPdfcLcLGenSpec);
      instance.SetDeleteArray(&deleteArray_RooAbsPdfcLcLGenSpec);
      instance.SetDestructor(&destruct_RooAbsPdfcLcLGenSpec);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooAbsPdf::GenSpec*)
   {
      return GenerateInitInstanceLocal((::RooAbsPdf::GenSpec*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooAbsPdf::GenSpec*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooAbsGenContext(void *p);
   static void deleteArray_RooAbsGenContext(void *p);
   static void destruct_RooAbsGenContext(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooAbsGenContext*)
   {
      ::RooAbsGenContext *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooAbsGenContext >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooAbsGenContext", ::RooAbsGenContext::Class_Version(), "RooAbsGenContext.h", 26,
                  typeid(::RooAbsGenContext), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooAbsGenContext::Dictionary, isa_proxy, 4,
                  sizeof(::RooAbsGenContext) );
      instance.SetDelete(&delete_RooAbsGenContext);
      instance.SetDeleteArray(&deleteArray_RooAbsGenContext);
      instance.SetDestructor(&destruct_RooAbsGenContext);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooAbsGenContext*)
   {
      return GenerateInitInstanceLocal((::RooAbsGenContext*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooAbsGenContext*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooSetProxy(void *p = 0);
   static void *newArray_RooSetProxy(Long_t size, void *p);
   static void delete_RooSetProxy(void *p);
   static void deleteArray_RooSetProxy(void *p);
   static void destruct_RooSetProxy(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooSetProxy*)
   {
      ::RooSetProxy *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooSetProxy >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooSetProxy", ::RooSetProxy::Class_Version(), "RooSetProxy.h", 24,
                  typeid(::RooSetProxy), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooSetProxy::Dictionary, isa_proxy, 4,
                  sizeof(::RooSetProxy) );
      instance.SetNew(&new_RooSetProxy);
      instance.SetNewArray(&newArray_RooSetProxy);
      instance.SetDelete(&delete_RooSetProxy);
      instance.SetDeleteArray(&deleteArray_RooSetProxy);
      instance.SetDestructor(&destruct_RooSetProxy);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooSetProxy*)
   {
      return GenerateInitInstanceLocal((::RooSetProxy*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooSetProxy*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooArgProxy(void *p = 0);
   static void *newArray_RooArgProxy(Long_t size, void *p);
   static void delete_RooArgProxy(void *p);
   static void deleteArray_RooArgProxy(void *p);
   static void destruct_RooArgProxy(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooArgProxy*)
   {
      ::RooArgProxy *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooArgProxy >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooArgProxy", ::RooArgProxy::Class_Version(), "RooArgProxy.h", 24,
                  typeid(::RooArgProxy), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooArgProxy::Dictionary, isa_proxy, 4,
                  sizeof(::RooArgProxy) );
      instance.SetNew(&new_RooArgProxy);
      instance.SetNewArray(&newArray_RooArgProxy);
      instance.SetDelete(&delete_RooArgProxy);
      instance.SetDeleteArray(&deleteArray_RooArgProxy);
      instance.SetDestructor(&destruct_RooArgProxy);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooArgProxy*)
   {
      return GenerateInitInstanceLocal((::RooArgProxy*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooArgProxy*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooNumber(void *p = 0);
   static void *newArray_RooNumber(Long_t size, void *p);
   static void delete_RooNumber(void *p);
   static void deleteArray_RooNumber(void *p);
   static void destruct_RooNumber(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooNumber*)
   {
      ::RooNumber *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooNumber >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooNumber", ::RooNumber::Class_Version(), "RooNumber.h", 21,
                  typeid(::RooNumber), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooNumber::Dictionary, isa_proxy, 4,
                  sizeof(::RooNumber) );
      instance.SetNew(&new_RooNumber);
      instance.SetNewArray(&newArray_RooNumber);
      instance.SetDelete(&delete_RooNumber);
      instance.SetDeleteArray(&deleteArray_RooNumber);
      instance.SetDestructor(&destruct_RooNumber);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooNumber*)
   {
      return GenerateInitInstanceLocal((::RooNumber*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooNumber*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooAbsRealLValue(void *p);
   static void deleteArray_RooAbsRealLValue(void *p);
   static void destruct_RooAbsRealLValue(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooAbsRealLValue*)
   {
      ::RooAbsRealLValue *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooAbsRealLValue >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooAbsRealLValue", ::RooAbsRealLValue::Class_Version(), "RooAbsRealLValue.h", 30,
                  typeid(::RooAbsRealLValue), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooAbsRealLValue::Dictionary, isa_proxy, 4,
                  sizeof(::RooAbsRealLValue) );
      instance.SetDelete(&delete_RooAbsRealLValue);
      instance.SetDeleteArray(&deleteArray_RooAbsRealLValue);
      instance.SetDestructor(&destruct_RooAbsRealLValue);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooAbsRealLValue*)
   {
      return GenerateInitInstanceLocal((::RooAbsRealLValue*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooAbsRealLValue*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooRealProxy(void *p = 0);
   static void *newArray_RooRealProxy(Long_t size, void *p);
   static void delete_RooRealProxy(void *p);
   static void deleteArray_RooRealProxy(void *p);
   static void destruct_RooRealProxy(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooRealProxy*)
   {
      ::RooRealProxy *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooRealProxy >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooRealProxy", ::RooRealProxy::Class_Version(), "RooRealProxy.h", 23,
                  typeid(::RooRealProxy), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooRealProxy::Dictionary, isa_proxy, 4,
                  sizeof(::RooRealProxy) );
      instance.SetNew(&new_RooRealProxy);
      instance.SetNewArray(&newArray_RooRealProxy);
      instance.SetDelete(&delete_RooRealProxy);
      instance.SetDeleteArray(&deleteArray_RooRealProxy);
      instance.SetDestructor(&destruct_RooRealProxy);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooRealProxy*)
   {
      return GenerateInitInstanceLocal((::RooRealProxy*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooRealProxy*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooAbsTestStatistic(void *p);
   static void deleteArray_RooAbsTestStatistic(void *p);
   static void destruct_RooAbsTestStatistic(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooAbsTestStatistic*)
   {
      ::RooAbsTestStatistic *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooAbsTestStatistic >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooAbsTestStatistic", ::RooAbsTestStatistic::Class_Version(), "RooAbsTestStatistic.h", 36,
                  typeid(::RooAbsTestStatistic), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooAbsTestStatistic::Dictionary, isa_proxy, 4,
                  sizeof(::RooAbsTestStatistic) );
      instance.SetDelete(&delete_RooAbsTestStatistic);
      instance.SetDeleteArray(&deleteArray_RooAbsTestStatistic);
      instance.SetDestructor(&destruct_RooAbsTestStatistic);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooAbsTestStatistic*)
   {
      return GenerateInitInstanceLocal((::RooAbsTestStatistic*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooAbsTestStatistic*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooCategoryProxy(void *p = 0);
   static void *newArray_RooCategoryProxy(Long_t size, void *p);
   static void delete_RooCategoryProxy(void *p);
   static void deleteArray_RooCategoryProxy(void *p);
   static void destruct_RooCategoryProxy(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooCategoryProxy*)
   {
      ::RooCategoryProxy *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooCategoryProxy >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooCategoryProxy", ::RooCategoryProxy::Class_Version(), "RooCategoryProxy.h", 23,
                  typeid(::RooCategoryProxy), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooCategoryProxy::Dictionary, isa_proxy, 4,
                  sizeof(::RooCategoryProxy) );
      instance.SetNew(&new_RooCategoryProxy);
      instance.SetNewArray(&newArray_RooCategoryProxy);
      instance.SetDelete(&delete_RooCategoryProxy);
      instance.SetDeleteArray(&deleteArray_RooCategoryProxy);
      instance.SetDestructor(&destruct_RooCategoryProxy);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooCategoryProxy*)
   {
      return GenerateInitInstanceLocal((::RooCategoryProxy*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooCategoryProxy*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooAbsHiddenReal(void *p);
   static void deleteArray_RooAbsHiddenReal(void *p);
   static void destruct_RooAbsHiddenReal(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooAbsHiddenReal*)
   {
      ::RooAbsHiddenReal *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooAbsHiddenReal >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooAbsHiddenReal", ::RooAbsHiddenReal::Class_Version(), "RooAbsHiddenReal.h", 25,
                  typeid(::RooAbsHiddenReal), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooAbsHiddenReal::Dictionary, isa_proxy, 4,
                  sizeof(::RooAbsHiddenReal) );
      instance.SetDelete(&delete_RooAbsHiddenReal);
      instance.SetDeleteArray(&deleteArray_RooAbsHiddenReal);
      instance.SetDestructor(&destruct_RooAbsHiddenReal);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooAbsHiddenReal*)
   {
      return GenerateInitInstanceLocal((::RooAbsHiddenReal*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooAbsHiddenReal*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooSharedProperties(void *p);
   static void deleteArray_RooSharedProperties(void *p);
   static void destruct_RooSharedProperties(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooSharedProperties*)
   {
      ::RooSharedProperties *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooSharedProperties >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooSharedProperties", ::RooSharedProperties::Class_Version(), "RooSharedProperties.h", 23,
                  typeid(::RooSharedProperties), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooSharedProperties::Dictionary, isa_proxy, 4,
                  sizeof(::RooSharedProperties) );
      instance.SetDelete(&delete_RooSharedProperties);
      instance.SetDeleteArray(&deleteArray_RooSharedProperties);
      instance.SetDestructor(&destruct_RooSharedProperties);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooSharedProperties*)
   {
      return GenerateInitInstanceLocal((::RooSharedProperties*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooSharedProperties*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooSharedPropertiesList(void *p = 0);
   static void *newArray_RooSharedPropertiesList(Long_t size, void *p);
   static void delete_RooSharedPropertiesList(void *p);
   static void deleteArray_RooSharedPropertiesList(void *p);
   static void destruct_RooSharedPropertiesList(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooSharedPropertiesList*)
   {
      ::RooSharedPropertiesList *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooSharedPropertiesList >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooSharedPropertiesList", ::RooSharedPropertiesList::Class_Version(), "RooSharedPropertiesList.h", 25,
                  typeid(::RooSharedPropertiesList), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooSharedPropertiesList::Dictionary, isa_proxy, 4,
                  sizeof(::RooSharedPropertiesList) );
      instance.SetNew(&new_RooSharedPropertiesList);
      instance.SetNewArray(&newArray_RooSharedPropertiesList);
      instance.SetDelete(&delete_RooSharedPropertiesList);
      instance.SetDeleteArray(&deleteArray_RooSharedPropertiesList);
      instance.SetDestructor(&destruct_RooSharedPropertiesList);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooSharedPropertiesList*)
   {
      return GenerateInitInstanceLocal((::RooSharedPropertiesList*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooSharedPropertiesList*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooCategorySharedProperties(void *p = 0);
   static void *newArray_RooCategorySharedProperties(Long_t size, void *p);
   static void delete_RooCategorySharedProperties(void *p);
   static void deleteArray_RooCategorySharedProperties(void *p);
   static void destruct_RooCategorySharedProperties(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooCategorySharedProperties*)
   {
      ::RooCategorySharedProperties *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooCategorySharedProperties >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooCategorySharedProperties", ::RooCategorySharedProperties::Class_Version(), "RooCategorySharedProperties.h", 22,
                  typeid(::RooCategorySharedProperties), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooCategorySharedProperties::Dictionary, isa_proxy, 4,
                  sizeof(::RooCategorySharedProperties) );
      instance.SetNew(&new_RooCategorySharedProperties);
      instance.SetNewArray(&newArray_RooCategorySharedProperties);
      instance.SetDelete(&delete_RooCategorySharedProperties);
      instance.SetDeleteArray(&deleteArray_RooCategorySharedProperties);
      instance.SetDestructor(&destruct_RooCategorySharedProperties);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooCategorySharedProperties*)
   {
      return GenerateInitInstanceLocal((::RooCategorySharedProperties*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooCategorySharedProperties*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooCategory(void *p = 0);
   static void *newArray_RooCategory(Long_t size, void *p);
   static void delete_RooCategory(void *p);
   static void deleteArray_RooCategory(void *p);
   static void destruct_RooCategory(void *p);
   static void streamer_RooCategory(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooCategory*)
   {
      ::RooCategory *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooCategory >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooCategory", ::RooCategory::Class_Version(), "RooCategory.h", 24,
                  typeid(::RooCategory), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooCategory::Dictionary, isa_proxy, 17,
                  sizeof(::RooCategory) );
      instance.SetNew(&new_RooCategory);
      instance.SetNewArray(&newArray_RooCategory);
      instance.SetDelete(&delete_RooCategory);
      instance.SetDeleteArray(&deleteArray_RooCategory);
      instance.SetDestructor(&destruct_RooCategory);
      instance.SetStreamerFunc(&streamer_RooCategory);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooCategory*)
   {
      return GenerateInitInstanceLocal((::RooCategory*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooCategory*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooNumIntConfig(void *p = 0);
   static void *newArray_RooNumIntConfig(Long_t size, void *p);
   static void delete_RooNumIntConfig(void *p);
   static void deleteArray_RooNumIntConfig(void *p);
   static void destruct_RooNumIntConfig(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooNumIntConfig*)
   {
      ::RooNumIntConfig *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooNumIntConfig >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooNumIntConfig", ::RooNumIntConfig::Class_Version(), "RooNumIntConfig.h", 25,
                  typeid(::RooNumIntConfig), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooNumIntConfig::Dictionary, isa_proxy, 4,
                  sizeof(::RooNumIntConfig) );
      instance.SetNew(&new_RooNumIntConfig);
      instance.SetNewArray(&newArray_RooNumIntConfig);
      instance.SetDelete(&delete_RooNumIntConfig);
      instance.SetDeleteArray(&deleteArray_RooNumIntConfig);
      instance.SetDestructor(&destruct_RooNumIntConfig);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooNumIntConfig*)
   {
      return GenerateInitInstanceLocal((::RooNumIntConfig*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooNumIntConfig*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooAbsIntegrator(void *p);
   static void deleteArray_RooAbsIntegrator(void *p);
   static void destruct_RooAbsIntegrator(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooAbsIntegrator*)
   {
      ::RooAbsIntegrator *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooAbsIntegrator >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooAbsIntegrator", ::RooAbsIntegrator::Class_Version(), "RooAbsIntegrator.h", 22,
                  typeid(::RooAbsIntegrator), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooAbsIntegrator::Dictionary, isa_proxy, 4,
                  sizeof(::RooAbsIntegrator) );
      instance.SetDelete(&delete_RooAbsIntegrator);
      instance.SetDeleteArray(&deleteArray_RooAbsIntegrator);
      instance.SetDestructor(&destruct_RooAbsIntegrator);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooAbsIntegrator*)
   {
      return GenerateInitInstanceLocal((::RooAbsIntegrator*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooAbsIntegrator*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooMCStudy(void *p);
   static void deleteArray_RooMCStudy(void *p);
   static void destruct_RooMCStudy(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooMCStudy*)
   {
      ::RooMCStudy *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooMCStudy >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooMCStudy", ::RooMCStudy::Class_Version(), "RooMCStudy.h", 32,
                  typeid(::RooMCStudy), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooMCStudy::Dictionary, isa_proxy, 4,
                  sizeof(::RooMCStudy) );
      instance.SetDelete(&delete_RooMCStudy);
      instance.SetDeleteArray(&deleteArray_RooMCStudy);
      instance.SetDestructor(&destruct_RooMCStudy);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooMCStudy*)
   {
      return GenerateInitInstanceLocal((::RooMCStudy*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooMCStudy*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooAbsMCStudyModule(void *p);
   static void deleteArray_RooAbsMCStudyModule(void *p);
   static void destruct_RooAbsMCStudyModule(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooAbsMCStudyModule*)
   {
      ::RooAbsMCStudyModule *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooAbsMCStudyModule >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooAbsMCStudyModule", ::RooAbsMCStudyModule::Class_Version(), "RooAbsMCStudyModule.h", 31,
                  typeid(::RooAbsMCStudyModule), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooAbsMCStudyModule::Dictionary, isa_proxy, 4,
                  sizeof(::RooAbsMCStudyModule) );
      instance.SetDelete(&delete_RooAbsMCStudyModule);
      instance.SetDeleteArray(&deleteArray_RooAbsMCStudyModule);
      instance.SetDestructor(&destruct_RooAbsMCStudyModule);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooAbsMCStudyModule*)
   {
      return GenerateInitInstanceLocal((::RooAbsMCStudyModule*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooAbsMCStudyModule*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooAbsOptTestStatistic(void *p);
   static void deleteArray_RooAbsOptTestStatistic(void *p);
   static void destruct_RooAbsOptTestStatistic(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooAbsOptTestStatistic*)
   {
      ::RooAbsOptTestStatistic *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooAbsOptTestStatistic >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooAbsOptTestStatistic", ::RooAbsOptTestStatistic::Class_Version(), "RooAbsOptTestStatistic.h", 28,
                  typeid(::RooAbsOptTestStatistic), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooAbsOptTestStatistic::Dictionary, isa_proxy, 4,
                  sizeof(::RooAbsOptTestStatistic) );
      instance.SetDelete(&delete_RooAbsOptTestStatistic);
      instance.SetDeleteArray(&deleteArray_RooAbsOptTestStatistic);
      instance.SetDestructor(&destruct_RooAbsOptTestStatistic);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooAbsOptTestStatistic*)
   {
      return GenerateInitInstanceLocal((::RooAbsOptTestStatistic*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooAbsOptTestStatistic*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooAbsRootFinder(void *p);
   static void deleteArray_RooAbsRootFinder(void *p);
   static void destruct_RooAbsRootFinder(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooAbsRootFinder*)
   {
      ::RooAbsRootFinder *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooAbsRootFinder >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooAbsRootFinder", ::RooAbsRootFinder::Class_Version(), "RooAbsRootFinder.h", 23,
                  typeid(::RooAbsRootFinder), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooAbsRootFinder::Dictionary, isa_proxy, 4,
                  sizeof(::RooAbsRootFinder) );
      instance.SetDelete(&delete_RooAbsRootFinder);
      instance.SetDeleteArray(&deleteArray_RooAbsRootFinder);
      instance.SetDestructor(&destruct_RooAbsRootFinder);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooAbsRootFinder*)
   {
      return GenerateInitInstanceLocal((::RooAbsRootFinder*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooAbsRootFinder*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooAbsString(void *p);
   static void deleteArray_RooAbsString(void *p);
   static void destruct_RooAbsString(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooAbsString*)
   {
      ::RooAbsString *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooAbsString >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooAbsString", ::RooAbsString::Class_Version(), "RooAbsString.h", 25,
                  typeid(::RooAbsString), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooAbsString::Dictionary, isa_proxy, 4,
                  sizeof(::RooAbsString) );
      instance.SetDelete(&delete_RooAbsString);
      instance.SetDeleteArray(&deleteArray_RooAbsString);
      instance.SetDestructor(&destruct_RooAbsString);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooAbsString*)
   {
      return GenerateInitInstanceLocal((::RooAbsString*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooAbsString*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooAbsNumGenerator(void *p);
   static void deleteArray_RooAbsNumGenerator(void *p);
   static void destruct_RooAbsNumGenerator(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooAbsNumGenerator*)
   {
      ::RooAbsNumGenerator *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooAbsNumGenerator >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooAbsNumGenerator", ::RooAbsNumGenerator::Class_Version(), "RooAbsNumGenerator.h", 30,
                  typeid(::RooAbsNumGenerator), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooAbsNumGenerator::Dictionary, isa_proxy, 4,
                  sizeof(::RooAbsNumGenerator) );
      instance.SetDelete(&delete_RooAbsNumGenerator);
      instance.SetDeleteArray(&deleteArray_RooAbsNumGenerator);
      instance.SetDestructor(&destruct_RooAbsNumGenerator);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooAbsNumGenerator*)
   {
      return GenerateInitInstanceLocal((::RooAbsNumGenerator*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooAbsNumGenerator*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooAcceptReject(void *p = 0);
   static void *newArray_RooAcceptReject(Long_t size, void *p);
   static void delete_RooAcceptReject(void *p);
   static void deleteArray_RooAcceptReject(void *p);
   static void destruct_RooAcceptReject(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooAcceptReject*)
   {
      ::RooAcceptReject *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooAcceptReject >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooAcceptReject", ::RooAcceptReject::Class_Version(), "RooAcceptReject.h", 29,
                  typeid(::RooAcceptReject), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooAcceptReject::Dictionary, isa_proxy, 4,
                  sizeof(::RooAcceptReject) );
      instance.SetNew(&new_RooAcceptReject);
      instance.SetNewArray(&newArray_RooAcceptReject);
      instance.SetDelete(&delete_RooAcceptReject);
      instance.SetDeleteArray(&deleteArray_RooAcceptReject);
      instance.SetDestructor(&destruct_RooAcceptReject);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooAcceptReject*)
   {
      return GenerateInitInstanceLocal((::RooAcceptReject*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooAcceptReject*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooAdaptiveGaussKronrodIntegrator1D(void *p = 0);
   static void *newArray_RooAdaptiveGaussKronrodIntegrator1D(Long_t size, void *p);
   static void delete_RooAdaptiveGaussKronrodIntegrator1D(void *p);
   static void deleteArray_RooAdaptiveGaussKronrodIntegrator1D(void *p);
   static void destruct_RooAdaptiveGaussKronrodIntegrator1D(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooAdaptiveGaussKronrodIntegrator1D*)
   {
      ::RooAdaptiveGaussKronrodIntegrator1D *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooAdaptiveGaussKronrodIntegrator1D >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooAdaptiveGaussKronrodIntegrator1D", ::RooAdaptiveGaussKronrodIntegrator1D::Class_Version(), "RooAdaptiveGaussKronrodIntegrator1D.h", 24,
                  typeid(::RooAdaptiveGaussKronrodIntegrator1D), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooAdaptiveGaussKronrodIntegrator1D::Dictionary, isa_proxy, 4,
                  sizeof(::RooAdaptiveGaussKronrodIntegrator1D) );
      instance.SetNew(&new_RooAdaptiveGaussKronrodIntegrator1D);
      instance.SetNewArray(&newArray_RooAdaptiveGaussKronrodIntegrator1D);
      instance.SetDelete(&delete_RooAdaptiveGaussKronrodIntegrator1D);
      instance.SetDeleteArray(&deleteArray_RooAdaptiveGaussKronrodIntegrator1D);
      instance.SetDestructor(&destruct_RooAdaptiveGaussKronrodIntegrator1D);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooAdaptiveGaussKronrodIntegrator1D*)
   {
      return GenerateInitInstanceLocal((::RooAdaptiveGaussKronrodIntegrator1D*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooAdaptiveGaussKronrodIntegrator1D*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooAICRegistry(void *p = 0);
   static void *newArray_RooAICRegistry(Long_t size, void *p);
   static void delete_RooAICRegistry(void *p);
   static void deleteArray_RooAICRegistry(void *p);
   static void destruct_RooAICRegistry(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooAICRegistry*)
   {
      ::RooAICRegistry *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooAICRegistry >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooAICRegistry", ::RooAICRegistry::Class_Version(), "RooAICRegistry.h", 26,
                  typeid(::RooAICRegistry), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooAICRegistry::Dictionary, isa_proxy, 4,
                  sizeof(::RooAICRegistry) );
      instance.SetNew(&new_RooAICRegistry);
      instance.SetNewArray(&newArray_RooAICRegistry);
      instance.SetDelete(&delete_RooAICRegistry);
      instance.SetDeleteArray(&deleteArray_RooAICRegistry);
      instance.SetDestructor(&destruct_RooAICRegistry);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooAICRegistry*)
   {
      return GenerateInitInstanceLocal((::RooAICRegistry*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooAICRegistry*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooAddPdf(void *p = 0);
   static void *newArray_RooAddPdf(Long_t size, void *p);
   static void delete_RooAddPdf(void *p);
   static void deleteArray_RooAddPdf(void *p);
   static void destruct_RooAddPdf(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooAddPdf*)
   {
      ::RooAddPdf *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooAddPdf >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooAddPdf", ::RooAddPdf::Class_Version(), "RooAddPdf.h", 29,
                  typeid(::RooAddPdf), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooAddPdf::Dictionary, isa_proxy, 4,
                  sizeof(::RooAddPdf) );
      instance.SetNew(&new_RooAddPdf);
      instance.SetNewArray(&newArray_RooAddPdf);
      instance.SetDelete(&delete_RooAddPdf);
      instance.SetDeleteArray(&deleteArray_RooAddPdf);
      instance.SetDestructor(&destruct_RooAddPdf);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooAddPdf*)
   {
      return GenerateInitInstanceLocal((::RooAddPdf*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooAddPdf*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooUniformBinning(void *p = 0);
   static void *newArray_RooUniformBinning(Long_t size, void *p);
   static void delete_RooUniformBinning(void *p);
   static void deleteArray_RooUniformBinning(void *p);
   static void destruct_RooUniformBinning(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooUniformBinning*)
   {
      ::RooUniformBinning *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooUniformBinning >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooUniformBinning", ::RooUniformBinning::Class_Version(), "RooUniformBinning.h", 23,
                  typeid(::RooUniformBinning), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooUniformBinning::Dictionary, isa_proxy, 4,
                  sizeof(::RooUniformBinning) );
      instance.SetNew(&new_RooUniformBinning);
      instance.SetNewArray(&newArray_RooUniformBinning);
      instance.SetDelete(&delete_RooUniformBinning);
      instance.SetDeleteArray(&deleteArray_RooUniformBinning);
      instance.SetDestructor(&destruct_RooUniformBinning);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooUniformBinning*)
   {
      return GenerateInitInstanceLocal((::RooUniformBinning*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooUniformBinning*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooRealVarSharedProperties(void *p = 0);
   static void *newArray_RooRealVarSharedProperties(Long_t size, void *p);
   static void delete_RooRealVarSharedProperties(void *p);
   static void deleteArray_RooRealVarSharedProperties(void *p);
   static void destruct_RooRealVarSharedProperties(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooRealVarSharedProperties*)
   {
      ::RooRealVarSharedProperties *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooRealVarSharedProperties >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooRealVarSharedProperties", ::RooRealVarSharedProperties::Class_Version(), "RooRealVarSharedProperties.h", 23,
                  typeid(::RooRealVarSharedProperties), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooRealVarSharedProperties::Dictionary, isa_proxy, 4,
                  sizeof(::RooRealVarSharedProperties) );
      instance.SetNew(&new_RooRealVarSharedProperties);
      instance.SetNewArray(&newArray_RooRealVarSharedProperties);
      instance.SetDelete(&delete_RooRealVarSharedProperties);
      instance.SetDeleteArray(&deleteArray_RooRealVarSharedProperties);
      instance.SetDestructor(&destruct_RooRealVarSharedProperties);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooRealVarSharedProperties*)
   {
      return GenerateInitInstanceLocal((::RooRealVarSharedProperties*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooRealVarSharedProperties*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooRealVar(void *p = 0);
   static void *newArray_RooRealVar(Long_t size, void *p);
   static void delete_RooRealVar(void *p);
   static void deleteArray_RooRealVar(void *p);
   static void destruct_RooRealVar(void *p);
   static void streamer_RooRealVar(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooRealVar*)
   {
      ::RooRealVar *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooRealVar >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooRealVar", ::RooRealVar::Class_Version(), "RooRealVar.h", 36,
                  typeid(::RooRealVar), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooRealVar::Dictionary, isa_proxy, 17,
                  sizeof(::RooRealVar) );
      instance.SetNew(&new_RooRealVar);
      instance.SetNewArray(&newArray_RooRealVar);
      instance.SetDelete(&delete_RooRealVar);
      instance.SetDeleteArray(&deleteArray_RooRealVar);
      instance.SetDestructor(&destruct_RooRealVar);
      instance.SetStreamerFunc(&streamer_RooRealVar);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooRealVar*)
   {
      return GenerateInitInstanceLocal((::RooRealVar*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooRealVar*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooResolutionModel(void *p);
   static void deleteArray_RooResolutionModel(void *p);
   static void destruct_RooResolutionModel(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooResolutionModel*)
   {
      ::RooResolutionModel *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooResolutionModel >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooResolutionModel", ::RooResolutionModel::Class_Version(), "RooResolutionModel.h", 26,
                  typeid(::RooResolutionModel), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooResolutionModel::Dictionary, isa_proxy, 4,
                  sizeof(::RooResolutionModel) );
      instance.SetDelete(&delete_RooResolutionModel);
      instance.SetDeleteArray(&deleteArray_RooResolutionModel);
      instance.SetDestructor(&destruct_RooResolutionModel);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooResolutionModel*)
   {
      return GenerateInitInstanceLocal((::RooResolutionModel*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooResolutionModel*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooAddModel(void *p = 0);
   static void *newArray_RooAddModel(Long_t size, void *p);
   static void delete_RooAddModel(void *p);
   static void deleteArray_RooAddModel(void *p);
   static void destruct_RooAddModel(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooAddModel*)
   {
      ::RooAddModel *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooAddModel >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooAddModel", ::RooAddModel::Class_Version(), "RooAddModel.h", 28,
                  typeid(::RooAddModel), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooAddModel::Dictionary, isa_proxy, 4,
                  sizeof(::RooAddModel) );
      instance.SetNew(&new_RooAddModel);
      instance.SetNewArray(&newArray_RooAddModel);
      instance.SetDelete(&delete_RooAddModel);
      instance.SetDeleteArray(&deleteArray_RooAddModel);
      instance.SetDestructor(&destruct_RooAddModel);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooAddModel*)
   {
      return GenerateInitInstanceLocal((::RooAddModel*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooAddModel*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooAddGenContext(void *p);
   static void deleteArray_RooAddGenContext(void *p);
   static void destruct_RooAddGenContext(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooAddGenContext*)
   {
      ::RooAddGenContext *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooAddGenContext >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooAddGenContext", ::RooAddGenContext::Class_Version(), "RooAddGenContext.h", 33,
                  typeid(::RooAddGenContext), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooAddGenContext::Dictionary, isa_proxy, 4,
                  sizeof(::RooAddGenContext) );
      instance.SetDelete(&delete_RooAddGenContext);
      instance.SetDeleteArray(&deleteArray_RooAddGenContext);
      instance.SetDestructor(&destruct_RooAddGenContext);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooAddGenContext*)
   {
      return GenerateInitInstanceLocal((::RooAddGenContext*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooAddGenContext*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooAddition(void *p = 0);
   static void *newArray_RooAddition(Long_t size, void *p);
   static void delete_RooAddition(void *p);
   static void deleteArray_RooAddition(void *p);
   static void destruct_RooAddition(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooAddition*)
   {
      ::RooAddition *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooAddition >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooAddition", ::RooAddition::Class_Version(), "RooAddition.h", 26,
                  typeid(::RooAddition), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooAddition::Dictionary, isa_proxy, 4,
                  sizeof(::RooAddition) );
      instance.SetNew(&new_RooAddition);
      instance.SetNewArray(&newArray_RooAddition);
      instance.SetDelete(&delete_RooAddition);
      instance.SetDeleteArray(&deleteArray_RooAddition);
      instance.SetDestructor(&destruct_RooAddition);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooAddition*)
   {
      return GenerateInitInstanceLocal((::RooAddition*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooAddition*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooDouble(void *p = 0);
   static void *newArray_RooDouble(Long_t size, void *p);
   static void delete_RooDouble(void *p);
   static void deleteArray_RooDouble(void *p);
   static void destruct_RooDouble(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooDouble*)
   {
      ::RooDouble *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooDouble >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooDouble", ::RooDouble::Class_Version(), "RooDouble.h", 22,
                  typeid(::RooDouble), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooDouble::Dictionary, isa_proxy, 4,
                  sizeof(::RooDouble) );
      instance.SetNew(&new_RooDouble);
      instance.SetNewArray(&newArray_RooDouble);
      instance.SetDelete(&delete_RooDouble);
      instance.SetDeleteArray(&deleteArray_RooDouble);
      instance.SetDestructor(&destruct_RooDouble);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooDouble*)
   {
      return GenerateInitInstanceLocal((::RooDouble*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooDouble*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooBinning(void *p = 0);
   static void *newArray_RooBinning(Long_t size, void *p);
   static void delete_RooBinning(void *p);
   static void deleteArray_RooBinning(void *p);
   static void destruct_RooBinning(void *p);
   static void streamer_RooBinning(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooBinning*)
   {
      ::RooBinning *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooBinning >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooBinning", ::RooBinning::Class_Version(), "RooBinning.h", 29,
                  typeid(::RooBinning), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooBinning::Dictionary, isa_proxy, 17,
                  sizeof(::RooBinning) );
      instance.SetNew(&new_RooBinning);
      instance.SetNewArray(&newArray_RooBinning);
      instance.SetDelete(&delete_RooBinning);
      instance.SetDeleteArray(&deleteArray_RooBinning);
      instance.SetDestructor(&destruct_RooBinning);
      instance.SetStreamerFunc(&streamer_RooBinning);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooBinning*)
   {
      return GenerateInitInstanceLocal((::RooBinning*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooBinning*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooBinnedGenContext(void *p);
   static void deleteArray_RooBinnedGenContext(void *p);
   static void destruct_RooBinnedGenContext(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooBinnedGenContext*)
   {
      ::RooBinnedGenContext *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooBinnedGenContext >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooBinnedGenContext", ::RooBinnedGenContext::Class_Version(), "RooBinnedGenContext.h", 30,
                  typeid(::RooBinnedGenContext), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooBinnedGenContext::Dictionary, isa_proxy, 4,
                  sizeof(::RooBinnedGenContext) );
      instance.SetDelete(&delete_RooBinnedGenContext);
      instance.SetDeleteArray(&deleteArray_RooBinnedGenContext);
      instance.SetDestructor(&destruct_RooBinnedGenContext);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooBinnedGenContext*)
   {
      return GenerateInitInstanceLocal((::RooBinnedGenContext*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooBinnedGenContext*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooBrentRootFinder(void *p);
   static void deleteArray_RooBrentRootFinder(void *p);
   static void destruct_RooBrentRootFinder(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooBrentRootFinder*)
   {
      ::RooBrentRootFinder *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooBrentRootFinder >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooBrentRootFinder", ::RooBrentRootFinder::Class_Version(), "RooBrentRootFinder.h", 21,
                  typeid(::RooBrentRootFinder), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooBrentRootFinder::Dictionary, isa_proxy, 4,
                  sizeof(::RooBrentRootFinder) );
      instance.SetDelete(&delete_RooBrentRootFinder);
      instance.SetDeleteArray(&deleteArray_RooBrentRootFinder);
      instance.SetDestructor(&destruct_RooBrentRootFinder);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooBrentRootFinder*)
   {
      return GenerateInitInstanceLocal((::RooBrentRootFinder*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooBrentRootFinder*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooDirItem(void *p = 0);
   static void *newArray_RooDirItem(Long_t size, void *p);
   static void delete_RooDirItem(void *p);
   static void deleteArray_RooDirItem(void *p);
   static void destruct_RooDirItem(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooDirItem*)
   {
      ::RooDirItem *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooDirItem >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooDirItem", ::RooDirItem::Class_Version(), "RooDirItem.h", 22,
                  typeid(::RooDirItem), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooDirItem::Dictionary, isa_proxy, 4,
                  sizeof(::RooDirItem) );
      instance.SetNew(&new_RooDirItem);
      instance.SetNewArray(&newArray_RooDirItem);
      instance.SetDelete(&delete_RooDirItem);
      instance.SetDeleteArray(&deleteArray_RooDirItem);
      instance.SetDestructor(&destruct_RooDirItem);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooDirItem*)
   {
      return GenerateInitInstanceLocal((::RooDirItem*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooDirItem*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooDataHist(void *p = 0);
   static void *newArray_RooDataHist(Long_t size, void *p);
   static void delete_RooDataHist(void *p);
   static void deleteArray_RooDataHist(void *p);
   static void destruct_RooDataHist(void *p);
   static void streamer_RooDataHist(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooDataHist*)
   {
      ::RooDataHist *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooDataHist >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooDataHist", ::RooDataHist::Class_Version(), "RooDataHist.h", 40,
                  typeid(::RooDataHist), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooDataHist::Dictionary, isa_proxy, 17,
                  sizeof(::RooDataHist) );
      instance.SetNew(&new_RooDataHist);
      instance.SetNewArray(&newArray_RooDataHist);
      instance.SetDelete(&delete_RooDataHist);
      instance.SetDeleteArray(&deleteArray_RooDataHist);
      instance.SetDestructor(&destruct_RooDataHist);
      instance.SetStreamerFunc(&streamer_RooDataHist);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooDataHist*)
   {
      return GenerateInitInstanceLocal((::RooDataHist*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooDataHist*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooChi2Var(void *p);
   static void deleteArray_RooChi2Var(void *p);
   static void destruct_RooChi2Var(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooChi2Var*)
   {
      ::RooChi2Var *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooChi2Var >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooChi2Var", ::RooChi2Var::Class_Version(), "RooChi2Var.h", 25,
                  typeid(::RooChi2Var), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooChi2Var::Dictionary, isa_proxy, 4,
                  sizeof(::RooChi2Var) );
      instance.SetDelete(&delete_RooChi2Var);
      instance.SetDeleteArray(&deleteArray_RooChi2Var);
      instance.SetDestructor(&destruct_RooChi2Var);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooChi2Var*)
   {
      return GenerateInitInstanceLocal((::RooChi2Var*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooChi2Var*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooFactoryWSTool(void *p);
   static void deleteArray_RooFactoryWSTool(void *p);
   static void destruct_RooFactoryWSTool(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooFactoryWSTool*)
   {
      ::RooFactoryWSTool *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooFactoryWSTool >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooFactoryWSTool", ::RooFactoryWSTool::Class_Version(), "RooFactoryWSTool.h", 47,
                  typeid(::RooFactoryWSTool), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooFactoryWSTool::Dictionary, isa_proxy, 4,
                  sizeof(::RooFactoryWSTool) );
      instance.SetDelete(&delete_RooFactoryWSTool);
      instance.SetDeleteArray(&deleteArray_RooFactoryWSTool);
      instance.SetDestructor(&destruct_RooFactoryWSTool);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooFactoryWSTool*)
   {
      return GenerateInitInstanceLocal((::RooFactoryWSTool*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooFactoryWSTool*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooClassFactory(void *p = 0);
   static void *newArray_RooClassFactory(Long_t size, void *p);
   static void delete_RooClassFactory(void *p);
   static void deleteArray_RooClassFactory(void *p);
   static void destruct_RooClassFactory(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooClassFactory*)
   {
      ::RooClassFactory *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooClassFactory >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooClassFactory", ::RooClassFactory::Class_Version(), "RooClassFactory.h", 28,
                  typeid(::RooClassFactory), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooClassFactory::Dictionary, isa_proxy, 4,
                  sizeof(::RooClassFactory) );
      instance.SetNew(&new_RooClassFactory);
      instance.SetNewArray(&newArray_RooClassFactory);
      instance.SetDelete(&delete_RooClassFactory);
      instance.SetDeleteArray(&deleteArray_RooClassFactory);
      instance.SetDestructor(&destruct_RooClassFactory);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooClassFactory*)
   {
      return GenerateInitInstanceLocal((::RooClassFactory*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooClassFactory*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooCmdConfig(void *p);
   static void deleteArray_RooCmdConfig(void *p);
   static void destruct_RooCmdConfig(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooCmdConfig*)
   {
      ::RooCmdConfig *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooCmdConfig >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooCmdConfig", ::RooCmdConfig::Class_Version(), "RooCmdConfig.h", 27,
                  typeid(::RooCmdConfig), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooCmdConfig::Dictionary, isa_proxy, 4,
                  sizeof(::RooCmdConfig) );
      instance.SetDelete(&delete_RooCmdConfig);
      instance.SetDeleteArray(&deleteArray_RooCmdConfig);
      instance.SetDestructor(&destruct_RooCmdConfig);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooCmdConfig*)
   {
      return GenerateInitInstanceLocal((::RooCmdConfig*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooCmdConfig*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooConstVar(void *p = 0);
   static void *newArray_RooConstVar(Long_t size, void *p);
   static void delete_RooConstVar(void *p);
   static void deleteArray_RooConstVar(void *p);
   static void destruct_RooConstVar(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooConstVar*)
   {
      ::RooConstVar *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooConstVar >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooConstVar", ::RooConstVar::Class_Version(), "RooConstVar.h", 25,
                  typeid(::RooConstVar), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooConstVar::Dictionary, isa_proxy, 4,
                  sizeof(::RooConstVar) );
      instance.SetNew(&new_RooConstVar);
      instance.SetNewArray(&newArray_RooConstVar);
      instance.SetDelete(&delete_RooConstVar);
      instance.SetDeleteArray(&deleteArray_RooConstVar);
      instance.SetDestructor(&destruct_RooConstVar);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooConstVar*)
   {
      return GenerateInitInstanceLocal((::RooConstVar*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooConstVar*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooConvCoefVar(void *p = 0);
   static void *newArray_RooConvCoefVar(Long_t size, void *p);
   static void delete_RooConvCoefVar(void *p);
   static void deleteArray_RooConvCoefVar(void *p);
   static void destruct_RooConvCoefVar(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooConvCoefVar*)
   {
      ::RooConvCoefVar *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooConvCoefVar >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooConvCoefVar", ::RooConvCoefVar::Class_Version(), "RooConvCoefVar.h", 28,
                  typeid(::RooConvCoefVar), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooConvCoefVar::Dictionary, isa_proxy, 4,
                  sizeof(::RooConvCoefVar) );
      instance.SetNew(&new_RooConvCoefVar);
      instance.SetNewArray(&newArray_RooConvCoefVar);
      instance.SetDelete(&delete_RooConvCoefVar);
      instance.SetDeleteArray(&deleteArray_RooConvCoefVar);
      instance.SetDestructor(&destruct_RooConvCoefVar);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooConvCoefVar*)
   {
      return GenerateInitInstanceLocal((::RooConvCoefVar*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooConvCoefVar*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooConvGenContext(void *p);
   static void deleteArray_RooConvGenContext(void *p);
   static void destruct_RooConvGenContext(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooConvGenContext*)
   {
      ::RooConvGenContext *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooConvGenContext >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooConvGenContext", ::RooConvGenContext::Class_Version(), "RooConvGenContext.h", 32,
                  typeid(::RooConvGenContext), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooConvGenContext::Dictionary, isa_proxy, 4,
                  sizeof(::RooConvGenContext) );
      instance.SetDelete(&delete_RooConvGenContext);
      instance.SetDeleteArray(&deleteArray_RooConvGenContext);
      instance.SetDestructor(&destruct_RooConvGenContext);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooConvGenContext*)
   {
      return GenerateInitInstanceLocal((::RooConvGenContext*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooConvGenContext*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooConvIntegrandBinding(void *p);
   static void deleteArray_RooConvIntegrandBinding(void *p);
   static void destruct_RooConvIntegrandBinding(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooConvIntegrandBinding*)
   {
      ::RooConvIntegrandBinding *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooConvIntegrandBinding >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooConvIntegrandBinding", ::RooConvIntegrandBinding::Class_Version(), "RooConvIntegrandBinding.h", 25,
                  typeid(::RooConvIntegrandBinding), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooConvIntegrandBinding::Dictionary, isa_proxy, 4,
                  sizeof(::RooConvIntegrandBinding) );
      instance.SetDelete(&delete_RooConvIntegrandBinding);
      instance.SetDeleteArray(&deleteArray_RooConvIntegrandBinding);
      instance.SetDestructor(&destruct_RooConvIntegrandBinding);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooConvIntegrandBinding*)
   {
      return GenerateInitInstanceLocal((::RooConvIntegrandBinding*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooConvIntegrandBinding*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooCustomizer(void *p);
   static void deleteArray_RooCustomizer(void *p);
   static void destruct_RooCustomizer(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooCustomizer*)
   {
      ::RooCustomizer *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooCustomizer >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooCustomizer", ::RooCustomizer::Class_Version(), "RooCustomizer.h", 32,
                  typeid(::RooCustomizer), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooCustomizer::Dictionary, isa_proxy, 4,
                  sizeof(::RooCustomizer) );
      instance.SetDelete(&delete_RooCustomizer);
      instance.SetDeleteArray(&deleteArray_RooCustomizer);
      instance.SetDestructor(&destruct_RooCustomizer);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooCustomizer*)
   {
      return GenerateInitInstanceLocal((::RooCustomizer*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooCustomizer*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooRealBinding(void *p);
   static void deleteArray_RooRealBinding(void *p);
   static void destruct_RooRealBinding(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooRealBinding*)
   {
      ::RooRealBinding *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooRealBinding >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooRealBinding", ::RooRealBinding::Class_Version(), "RooRealBinding.h", 26,
                  typeid(::RooRealBinding), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooRealBinding::Dictionary, isa_proxy, 4,
                  sizeof(::RooRealBinding) );
      instance.SetDelete(&delete_RooRealBinding);
      instance.SetDeleteArray(&deleteArray_RooRealBinding);
      instance.SetDestructor(&destruct_RooRealBinding);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooRealBinding*)
   {
      return GenerateInitInstanceLocal((::RooRealBinding*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooRealBinding*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooDataProjBinding(void *p);
   static void deleteArray_RooDataProjBinding(void *p);
   static void destruct_RooDataProjBinding(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooDataProjBinding*)
   {
      ::RooDataProjBinding *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooDataProjBinding >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooDataProjBinding", ::RooDataProjBinding::Class_Version(), "RooDataProjBinding.h", 25,
                  typeid(::RooDataProjBinding), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooDataProjBinding::Dictionary, isa_proxy, 4,
                  sizeof(::RooDataProjBinding) );
      instance.SetDelete(&delete_RooDataProjBinding);
      instance.SetDeleteArray(&deleteArray_RooDataProjBinding);
      instance.SetDestructor(&destruct_RooDataProjBinding);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooDataProjBinding*)
   {
      return GenerateInitInstanceLocal((::RooDataProjBinding*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooDataProjBinding*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooDataSet(void *p = 0);
   static void *newArray_RooDataSet(Long_t size, void *p);
   static void delete_RooDataSet(void *p);
   static void deleteArray_RooDataSet(void *p);
   static void destruct_RooDataSet(void *p);
   static void streamer_RooDataSet(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooDataSet*)
   {
      ::RooDataSet *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooDataSet >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooDataSet", ::RooDataSet::Class_Version(), "RooDataSet.h", 29,
                  typeid(::RooDataSet), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooDataSet::Dictionary, isa_proxy, 17,
                  sizeof(::RooDataSet) );
      instance.SetNew(&new_RooDataSet);
      instance.SetNewArray(&newArray_RooDataSet);
      instance.SetDelete(&delete_RooDataSet);
      instance.SetDeleteArray(&deleteArray_RooDataSet);
      instance.SetDestructor(&destruct_RooDataSet);
      instance.SetStreamerFunc(&streamer_RooDataSet);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooDataSet*)
   {
      return GenerateInitInstanceLocal((::RooDataSet*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooDataSet*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooDLLSignificanceMCSModule(void *p);
   static void deleteArray_RooDLLSignificanceMCSModule(void *p);
   static void destruct_RooDLLSignificanceMCSModule(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooDLLSignificanceMCSModule*)
   {
      ::RooDLLSignificanceMCSModule *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooDLLSignificanceMCSModule >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooDLLSignificanceMCSModule", ::RooDLLSignificanceMCSModule::Class_Version(), "RooDLLSignificanceMCSModule.h", 23,
                  typeid(::RooDLLSignificanceMCSModule), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooDLLSignificanceMCSModule::Dictionary, isa_proxy, 4,
                  sizeof(::RooDLLSignificanceMCSModule) );
      instance.SetDelete(&delete_RooDLLSignificanceMCSModule);
      instance.SetDeleteArray(&deleteArray_RooDLLSignificanceMCSModule);
      instance.SetDestructor(&destruct_RooDLLSignificanceMCSModule);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooDLLSignificanceMCSModule*)
   {
      return GenerateInitInstanceLocal((::RooDLLSignificanceMCSModule*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooDLLSignificanceMCSModule*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooAbsAnaConvPdf(void *p);
   static void deleteArray_RooAbsAnaConvPdf(void *p);
   static void destruct_RooAbsAnaConvPdf(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooAbsAnaConvPdf*)
   {
      ::RooAbsAnaConvPdf *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooAbsAnaConvPdf >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooAbsAnaConvPdf", ::RooAbsAnaConvPdf::Class_Version(), "RooAbsAnaConvPdf.h", 34,
                  typeid(::RooAbsAnaConvPdf), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooAbsAnaConvPdf::Dictionary, isa_proxy, 4,
                  sizeof(::RooAbsAnaConvPdf) );
      instance.SetDelete(&delete_RooAbsAnaConvPdf);
      instance.SetDeleteArray(&deleteArray_RooAbsAnaConvPdf);
      instance.SetDestructor(&destruct_RooAbsAnaConvPdf);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooAbsAnaConvPdf*)
   {
      return GenerateInitInstanceLocal((::RooAbsAnaConvPdf*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooAbsAnaConvPdf*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooEfficiency(void *p = 0);
   static void *newArray_RooEfficiency(Long_t size, void *p);
   static void delete_RooEfficiency(void *p);
   static void deleteArray_RooEfficiency(void *p);
   static void destruct_RooEfficiency(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooEfficiency*)
   {
      ::RooEfficiency *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooEfficiency >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooEfficiency", ::RooEfficiency::Class_Version(), "RooEfficiency.h", 27,
                  typeid(::RooEfficiency), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooEfficiency::Dictionary, isa_proxy, 4,
                  sizeof(::RooEfficiency) );
      instance.SetNew(&new_RooEfficiency);
      instance.SetNewArray(&newArray_RooEfficiency);
      instance.SetDelete(&delete_RooEfficiency);
      instance.SetDeleteArray(&deleteArray_RooEfficiency);
      instance.SetDestructor(&destruct_RooEfficiency);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooEfficiency*)
   {
      return GenerateInitInstanceLocal((::RooEfficiency*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooEfficiency*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooEffProd(void *p = 0);
   static void *newArray_RooEffProd(Long_t size, void *p);
   static void delete_RooEffProd(void *p);
   static void deleteArray_RooEffProd(void *p);
   static void destruct_RooEffProd(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooEffProd*)
   {
      ::RooEffProd *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooEffProd >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooEffProd", ::RooEffProd::Class_Version(), "RooEffProd.h", 20,
                  typeid(::RooEffProd), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooEffProd::Dictionary, isa_proxy, 4,
                  sizeof(::RooEffProd) );
      instance.SetNew(&new_RooEffProd);
      instance.SetNewArray(&newArray_RooEffProd);
      instance.SetDelete(&delete_RooEffProd);
      instance.SetDeleteArray(&deleteArray_RooEffProd);
      instance.SetDestructor(&destruct_RooEffProd);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooEffProd*)
   {
      return GenerateInitInstanceLocal((::RooEffProd*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooEffProd*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooExtendPdf(void *p = 0);
   static void *newArray_RooExtendPdf(Long_t size, void *p);
   static void delete_RooExtendPdf(void *p);
   static void deleteArray_RooExtendPdf(void *p);
   static void destruct_RooExtendPdf(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooExtendPdf*)
   {
      ::RooExtendPdf *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooExtendPdf >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooExtendPdf", ::RooExtendPdf::Class_Version(), "RooExtendPdf.h", 22,
                  typeid(::RooExtendPdf), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooExtendPdf::Dictionary, isa_proxy, 4,
                  sizeof(::RooExtendPdf) );
      instance.SetNew(&new_RooExtendPdf);
      instance.SetNewArray(&newArray_RooExtendPdf);
      instance.SetDelete(&delete_RooExtendPdf);
      instance.SetDeleteArray(&deleteArray_RooExtendPdf);
      instance.SetDestructor(&destruct_RooExtendPdf);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooExtendPdf*)
   {
      return GenerateInitInstanceLocal((::RooExtendPdf*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooExtendPdf*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooEffGenContext(void *p);
   static void deleteArray_RooEffGenContext(void *p);
   static void destruct_RooEffGenContext(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooEffGenContext*)
   {
      ::RooEffGenContext *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooEffGenContext >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooEffGenContext", ::RooEffGenContext::Class_Version(), "RooEffGenContext.h", 23,
                  typeid(::RooEffGenContext), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooEffGenContext::Dictionary, isa_proxy, 4,
                  sizeof(::RooEffGenContext) );
      instance.SetDelete(&delete_RooEffGenContext);
      instance.SetDeleteArray(&deleteArray_RooEffGenContext);
      instance.SetDestructor(&destruct_RooEffGenContext);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooEffGenContext*)
   {
      return GenerateInitInstanceLocal((::RooEffGenContext*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooEffGenContext*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooEllipse(void *p = 0);
   static void *newArray_RooEllipse(Long_t size, void *p);
   static void delete_RooEllipse(void *p);
   static void deleteArray_RooEllipse(void *p);
   static void destruct_RooEllipse(void *p);
   static Long64_t merge_RooEllipse(void *obj, TCollection *coll,TFileMergeInfo *info);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooEllipse*)
   {
      ::RooEllipse *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooEllipse >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooEllipse", ::RooEllipse::Class_Version(), "RooEllipse.h", 22,
                  typeid(::RooEllipse), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooEllipse::Dictionary, isa_proxy, 4,
                  sizeof(::RooEllipse) );
      instance.SetNew(&new_RooEllipse);
      instance.SetNewArray(&newArray_RooEllipse);
      instance.SetDelete(&delete_RooEllipse);
      instance.SetDeleteArray(&deleteArray_RooEllipse);
      instance.SetDestructor(&destruct_RooEllipse);
      instance.SetMerge(&merge_RooEllipse);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooEllipse*)
   {
      return GenerateInitInstanceLocal((::RooEllipse*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooEllipse*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooErrorVar(void *p = 0);
   static void *newArray_RooErrorVar(Long_t size, void *p);
   static void delete_RooErrorVar(void *p);
   static void deleteArray_RooErrorVar(void *p);
   static void destruct_RooErrorVar(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooErrorVar*)
   {
      ::RooErrorVar *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooErrorVar >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooErrorVar", ::RooErrorVar::Class_Version(), "RooErrorVar.h", 28,
                  typeid(::RooErrorVar), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooErrorVar::Dictionary, isa_proxy, 4,
                  sizeof(::RooErrorVar) );
      instance.SetNew(&new_RooErrorVar);
      instance.SetNewArray(&newArray_RooErrorVar);
      instance.SetDelete(&delete_RooErrorVar);
      instance.SetDeleteArray(&deleteArray_RooErrorVar);
      instance.SetDestructor(&destruct_RooErrorVar);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooErrorVar*)
   {
      return GenerateInitInstanceLocal((::RooErrorVar*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooErrorVar*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooFitResult(void *p = 0);
   static void *newArray_RooFitResult(Long_t size, void *p);
   static void delete_RooFitResult(void *p);
   static void deleteArray_RooFitResult(void *p);
   static void destruct_RooFitResult(void *p);
   static void streamer_RooFitResult(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooFitResult*)
   {
      ::RooFitResult *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooFitResult >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooFitResult", ::RooFitResult::Class_Version(), "RooFitResult.h", 40,
                  typeid(::RooFitResult), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooFitResult::Dictionary, isa_proxy, 17,
                  sizeof(::RooFitResult) );
      instance.SetNew(&new_RooFitResult);
      instance.SetNewArray(&newArray_RooFitResult);
      instance.SetDelete(&delete_RooFitResult);
      instance.SetDeleteArray(&deleteArray_RooFitResult);
      instance.SetDestructor(&destruct_RooFitResult);
      instance.SetStreamerFunc(&streamer_RooFitResult);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooFitResult*)
   {
      return GenerateInitInstanceLocal((::RooFitResult*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooFitResult*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooGaussKronrodIntegrator1D(void *p = 0);
   static void *newArray_RooGaussKronrodIntegrator1D(Long_t size, void *p);
   static void delete_RooGaussKronrodIntegrator1D(void *p);
   static void deleteArray_RooGaussKronrodIntegrator1D(void *p);
   static void destruct_RooGaussKronrodIntegrator1D(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooGaussKronrodIntegrator1D*)
   {
      ::RooGaussKronrodIntegrator1D *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooGaussKronrodIntegrator1D >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooGaussKronrodIntegrator1D", ::RooGaussKronrodIntegrator1D::Class_Version(), "RooGaussKronrodIntegrator1D.h", 24,
                  typeid(::RooGaussKronrodIntegrator1D), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooGaussKronrodIntegrator1D::Dictionary, isa_proxy, 4,
                  sizeof(::RooGaussKronrodIntegrator1D) );
      instance.SetNew(&new_RooGaussKronrodIntegrator1D);
      instance.SetNewArray(&newArray_RooGaussKronrodIntegrator1D);
      instance.SetDelete(&delete_RooGaussKronrodIntegrator1D);
      instance.SetDeleteArray(&deleteArray_RooGaussKronrodIntegrator1D);
      instance.SetDestructor(&destruct_RooGaussKronrodIntegrator1D);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooGaussKronrodIntegrator1D*)
   {
      return GenerateInitInstanceLocal((::RooGaussKronrodIntegrator1D*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooGaussKronrodIntegrator1D*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooGenContext(void *p);
   static void deleteArray_RooGenContext(void *p);
   static void destruct_RooGenContext(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooGenContext*)
   {
      ::RooGenContext *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooGenContext >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooGenContext", ::RooGenContext::Class_Version(), "RooGenContext.h", 30,
                  typeid(::RooGenContext), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooGenContext::Dictionary, isa_proxy, 4,
                  sizeof(::RooGenContext) );
      instance.SetDelete(&delete_RooGenContext);
      instance.SetDeleteArray(&deleteArray_RooGenContext);
      instance.SetDestructor(&destruct_RooGenContext);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooGenContext*)
   {
      return GenerateInitInstanceLocal((::RooGenContext*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooGenContext*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooGenericPdf(void *p = 0);
   static void *newArray_RooGenericPdf(Long_t size, void *p);
   static void delete_RooGenericPdf(void *p);
   static void deleteArray_RooGenericPdf(void *p);
   static void destruct_RooGenericPdf(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooGenericPdf*)
   {
      ::RooGenericPdf *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooGenericPdf >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooGenericPdf", ::RooGenericPdf::Class_Version(), "RooGenericPdf.h", 25,
                  typeid(::RooGenericPdf), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooGenericPdf::Dictionary, isa_proxy, 4,
                  sizeof(::RooGenericPdf) );
      instance.SetNew(&new_RooGenericPdf);
      instance.SetNewArray(&newArray_RooGenericPdf);
      instance.SetDelete(&delete_RooGenericPdf);
      instance.SetDeleteArray(&deleteArray_RooGenericPdf);
      instance.SetDestructor(&destruct_RooGenericPdf);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooGenericPdf*)
   {
      return GenerateInitInstanceLocal((::RooGenericPdf*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooGenericPdf*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooGenProdProj(void *p = 0);
   static void *newArray_RooGenProdProj(Long_t size, void *p);
   static void delete_RooGenProdProj(void *p);
   static void deleteArray_RooGenProdProj(void *p);
   static void destruct_RooGenProdProj(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooGenProdProj*)
   {
      ::RooGenProdProj *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooGenProdProj >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooGenProdProj", ::RooGenProdProj::Class_Version(), "RooGenProdProj.h", 26,
                  typeid(::RooGenProdProj), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooGenProdProj::Dictionary, isa_proxy, 4,
                  sizeof(::RooGenProdProj) );
      instance.SetNew(&new_RooGenProdProj);
      instance.SetNewArray(&newArray_RooGenProdProj);
      instance.SetDelete(&delete_RooGenProdProj);
      instance.SetDeleteArray(&deleteArray_RooGenProdProj);
      instance.SetDestructor(&destruct_RooGenProdProj);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooGenProdProj*)
   {
      return GenerateInitInstanceLocal((::RooGenProdProj*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooGenProdProj*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooGrid(void *p = 0);
   static void *newArray_RooGrid(Long_t size, void *p);
   static void delete_RooGrid(void *p);
   static void deleteArray_RooGrid(void *p);
   static void destruct_RooGrid(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooGrid*)
   {
      ::RooGrid *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooGrid >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooGrid", ::RooGrid::Class_Version(), "RooGrid.h", 24,
                  typeid(::RooGrid), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooGrid::Dictionary, isa_proxy, 4,
                  sizeof(::RooGrid) );
      instance.SetNew(&new_RooGrid);
      instance.SetNewArray(&newArray_RooGrid);
      instance.SetDelete(&delete_RooGrid);
      instance.SetDeleteArray(&deleteArray_RooGrid);
      instance.SetDestructor(&destruct_RooGrid);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooGrid*)
   {
      return GenerateInitInstanceLocal((::RooGrid*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooGrid*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooHistError(void *p);
   static void deleteArray_RooHistError(void *p);
   static void destruct_RooHistError(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooHistError*)
   {
      ::RooHistError *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooHistError >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooHistError", ::RooHistError::Class_Version(), "RooHistError.h", 25,
                  typeid(::RooHistError), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooHistError::Dictionary, isa_proxy, 4,
                  sizeof(::RooHistError) );
      instance.SetDelete(&delete_RooHistError);
      instance.SetDeleteArray(&deleteArray_RooHistError);
      instance.SetDestructor(&destruct_RooHistError);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooHistError*)
   {
      return GenerateInitInstanceLocal((::RooHistError*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooHistError*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooHist(void *p = 0);
   static void *newArray_RooHist(Long_t size, void *p);
   static void delete_RooHist(void *p);
   static void deleteArray_RooHist(void *p);
   static void destruct_RooHist(void *p);
   static Long64_t merge_RooHist(void *obj, TCollection *coll,TFileMergeInfo *info);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooHist*)
   {
      ::RooHist *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooHist >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooHist", ::RooHist::Class_Version(), "RooHist.h", 26,
                  typeid(::RooHist), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooHist::Dictionary, isa_proxy, 4,
                  sizeof(::RooHist) );
      instance.SetNew(&new_RooHist);
      instance.SetNewArray(&newArray_RooHist);
      instance.SetDelete(&delete_RooHist);
      instance.SetDeleteArray(&deleteArray_RooHist);
      instance.SetDestructor(&destruct_RooHist);
      instance.SetMerge(&merge_RooHist);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooHist*)
   {
      return GenerateInitInstanceLocal((::RooHist*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooHist*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooImproperIntegrator1D(void *p = 0);
   static void *newArray_RooImproperIntegrator1D(Long_t size, void *p);
   static void delete_RooImproperIntegrator1D(void *p);
   static void deleteArray_RooImproperIntegrator1D(void *p);
   static void destruct_RooImproperIntegrator1D(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooImproperIntegrator1D*)
   {
      ::RooImproperIntegrator1D *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooImproperIntegrator1D >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooImproperIntegrator1D", ::RooImproperIntegrator1D::Class_Version(), "RooImproperIntegrator1D.h", 25,
                  typeid(::RooImproperIntegrator1D), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooImproperIntegrator1D::Dictionary, isa_proxy, 4,
                  sizeof(::RooImproperIntegrator1D) );
      instance.SetNew(&new_RooImproperIntegrator1D);
      instance.SetNewArray(&newArray_RooImproperIntegrator1D);
      instance.SetDelete(&delete_RooImproperIntegrator1D);
      instance.SetDeleteArray(&deleteArray_RooImproperIntegrator1D);
      instance.SetDestructor(&destruct_RooImproperIntegrator1D);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooImproperIntegrator1D*)
   {
      return GenerateInitInstanceLocal((::RooImproperIntegrator1D*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooImproperIntegrator1D*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooBinIntegrator(void *p = 0);
   static void *newArray_RooBinIntegrator(Long_t size, void *p);
   static void delete_RooBinIntegrator(void *p);
   static void deleteArray_RooBinIntegrator(void *p);
   static void destruct_RooBinIntegrator(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooBinIntegrator*)
   {
      ::RooBinIntegrator *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooBinIntegrator >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooBinIntegrator", ::RooBinIntegrator::Class_Version(), "RooBinIntegrator.h", 23,
                  typeid(::RooBinIntegrator), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooBinIntegrator::Dictionary, isa_proxy, 4,
                  sizeof(::RooBinIntegrator) );
      instance.SetNew(&new_RooBinIntegrator);
      instance.SetNewArray(&newArray_RooBinIntegrator);
      instance.SetDelete(&delete_RooBinIntegrator);
      instance.SetDeleteArray(&deleteArray_RooBinIntegrator);
      instance.SetDestructor(&destruct_RooBinIntegrator);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooBinIntegrator*)
   {
      return GenerateInitInstanceLocal((::RooBinIntegrator*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooBinIntegrator*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooIntegrator1D(void *p = 0);
   static void *newArray_RooIntegrator1D(Long_t size, void *p);
   static void delete_RooIntegrator1D(void *p);
   static void deleteArray_RooIntegrator1D(void *p);
   static void destruct_RooIntegrator1D(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooIntegrator1D*)
   {
      ::RooIntegrator1D *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooIntegrator1D >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooIntegrator1D", ::RooIntegrator1D::Class_Version(), "RooIntegrator1D.h", 22,
                  typeid(::RooIntegrator1D), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooIntegrator1D::Dictionary, isa_proxy, 4,
                  sizeof(::RooIntegrator1D) );
      instance.SetNew(&new_RooIntegrator1D);
      instance.SetNewArray(&newArray_RooIntegrator1D);
      instance.SetDelete(&delete_RooIntegrator1D);
      instance.SetDeleteArray(&deleteArray_RooIntegrator1D);
      instance.SetDestructor(&destruct_RooIntegrator1D);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooIntegrator1D*)
   {
      return GenerateInitInstanceLocal((::RooIntegrator1D*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooIntegrator1D*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooIntegrator2D(void *p = 0);
   static void *newArray_RooIntegrator2D(Long_t size, void *p);
   static void delete_RooIntegrator2D(void *p);
   static void deleteArray_RooIntegrator2D(void *p);
   static void destruct_RooIntegrator2D(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooIntegrator2D*)
   {
      ::RooIntegrator2D *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooIntegrator2D >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooIntegrator2D", ::RooIntegrator2D::Class_Version(), "RooIntegrator2D.h", 22,
                  typeid(::RooIntegrator2D), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooIntegrator2D::Dictionary, isa_proxy, 4,
                  sizeof(::RooIntegrator2D) );
      instance.SetNew(&new_RooIntegrator2D);
      instance.SetNewArray(&newArray_RooIntegrator2D);
      instance.SetDelete(&delete_RooIntegrator2D);
      instance.SetDeleteArray(&deleteArray_RooIntegrator2D);
      instance.SetDestructor(&destruct_RooIntegrator2D);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooIntegrator2D*)
   {
      return GenerateInitInstanceLocal((::RooIntegrator2D*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooIntegrator2D*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooIntegratorBinding(void *p);
   static void deleteArray_RooIntegratorBinding(void *p);
   static void destruct_RooIntegratorBinding(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooIntegratorBinding*)
   {
      ::RooIntegratorBinding *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooIntegratorBinding >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooIntegratorBinding", ::RooIntegratorBinding::Class_Version(), "RooIntegratorBinding.h", 22,
                  typeid(::RooIntegratorBinding), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooIntegratorBinding::Dictionary, isa_proxy, 4,
                  sizeof(::RooIntegratorBinding) );
      instance.SetDelete(&delete_RooIntegratorBinding);
      instance.SetDeleteArray(&deleteArray_RooIntegratorBinding);
      instance.SetDestructor(&destruct_RooIntegratorBinding);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooIntegratorBinding*)
   {
      return GenerateInitInstanceLocal((::RooIntegratorBinding*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooIntegratorBinding*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooInt(void *p = 0);
   static void *newArray_RooInt(Long_t size, void *p);
   static void delete_RooInt(void *p);
   static void deleteArray_RooInt(void *p);
   static void destruct_RooInt(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooInt*)
   {
      ::RooInt *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooInt >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooInt", ::RooInt::Class_Version(), "RooInt.h", 22,
                  typeid(::RooInt), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooInt::Dictionary, isa_proxy, 4,
                  sizeof(::RooInt) );
      instance.SetNew(&new_RooInt);
      instance.SetNewArray(&newArray_RooInt);
      instance.SetDelete(&delete_RooInt);
      instance.SetDeleteArray(&deleteArray_RooInt);
      instance.SetDestructor(&destruct_RooInt);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooInt*)
   {
      return GenerateInitInstanceLocal((::RooInt*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooInt*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooInvTransform(void *p);
   static void deleteArray_RooInvTransform(void *p);
   static void destruct_RooInvTransform(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooInvTransform*)
   {
      ::RooInvTransform *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooInvTransform >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooInvTransform", ::RooInvTransform::Class_Version(), "RooInvTransform.h", 21,
                  typeid(::RooInvTransform), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooInvTransform::Dictionary, isa_proxy, 4,
                  sizeof(::RooInvTransform) );
      instance.SetDelete(&delete_RooInvTransform);
      instance.SetDeleteArray(&deleteArray_RooInvTransform);
      instance.SetDestructor(&destruct_RooInvTransform);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooInvTransform*)
   {
      return GenerateInitInstanceLocal((::RooInvTransform*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooInvTransform*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooLinTransBinning(void *p = 0);
   static void *newArray_RooLinTransBinning(Long_t size, void *p);
   static void delete_RooLinTransBinning(void *p);
   static void deleteArray_RooLinTransBinning(void *p);
   static void destruct_RooLinTransBinning(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooLinTransBinning*)
   {
      ::RooLinTransBinning *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooLinTransBinning >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooLinTransBinning", ::RooLinTransBinning::Class_Version(), "RooLinTransBinning.h", 22,
                  typeid(::RooLinTransBinning), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooLinTransBinning::Dictionary, isa_proxy, 4,
                  sizeof(::RooLinTransBinning) );
      instance.SetNew(&new_RooLinTransBinning);
      instance.SetNewArray(&newArray_RooLinTransBinning);
      instance.SetDelete(&delete_RooLinTransBinning);
      instance.SetDeleteArray(&deleteArray_RooLinTransBinning);
      instance.SetDestructor(&destruct_RooLinTransBinning);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooLinTransBinning*)
   {
      return GenerateInitInstanceLocal((::RooLinTransBinning*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooLinTransBinning*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooLinearVar(void *p = 0);
   static void *newArray_RooLinearVar(Long_t size, void *p);
   static void delete_RooLinearVar(void *p);
   static void deleteArray_RooLinearVar(void *p);
   static void destruct_RooLinearVar(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooLinearVar*)
   {
      ::RooLinearVar *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooLinearVar >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooLinearVar", ::RooLinearVar::Class_Version(), "RooLinearVar.h", 29,
                  typeid(::RooLinearVar), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooLinearVar::Dictionary, isa_proxy, 4,
                  sizeof(::RooLinearVar) );
      instance.SetNew(&new_RooLinearVar);
      instance.SetNewArray(&newArray_RooLinearVar);
      instance.SetDelete(&delete_RooLinearVar);
      instance.SetDeleteArray(&deleteArray_RooLinearVar);
      instance.SetDestructor(&destruct_RooLinearVar);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooLinearVar*)
   {
      return GenerateInitInstanceLocal((::RooLinearVar*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooLinearVar*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooList(void *p = 0);
   static void *newArray_RooList(Long_t size, void *p);
   static void delete_RooList(void *p);
   static void deleteArray_RooList(void *p);
   static void destruct_RooList(void *p);
   static Long64_t merge_RooList(void *obj, TCollection *coll,TFileMergeInfo *info);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooList*)
   {
      ::RooList *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooList >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooList", ::RooList::Class_Version(), "RooList.h", 21,
                  typeid(::RooList), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooList::Dictionary, isa_proxy, 4,
                  sizeof(::RooList) );
      instance.SetNew(&new_RooList);
      instance.SetNewArray(&newArray_RooList);
      instance.SetDelete(&delete_RooList);
      instance.SetDeleteArray(&deleteArray_RooList);
      instance.SetDestructor(&destruct_RooList);
      instance.SetMerge(&merge_RooList);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooList*)
   {
      return GenerateInitInstanceLocal((::RooList*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooList*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooMapCatEntry(void *p = 0);
   static void *newArray_RooMapCatEntry(Long_t size, void *p);
   static void delete_RooMapCatEntry(void *p);
   static void deleteArray_RooMapCatEntry(void *p);
   static void destruct_RooMapCatEntry(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooMapCatEntry*)
   {
      ::RooMapCatEntry *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooMapCatEntry >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooMapCatEntry", ::RooMapCatEntry::Class_Version(), "RooMapCatEntry.h", 23,
                  typeid(::RooMapCatEntry), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooMapCatEntry::Dictionary, isa_proxy, 4,
                  sizeof(::RooMapCatEntry) );
      instance.SetNew(&new_RooMapCatEntry);
      instance.SetNewArray(&newArray_RooMapCatEntry);
      instance.SetDelete(&delete_RooMapCatEntry);
      instance.SetDeleteArray(&deleteArray_RooMapCatEntry);
      instance.SetDestructor(&destruct_RooMapCatEntry);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooMapCatEntry*)
   {
      return GenerateInitInstanceLocal((::RooMapCatEntry*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooMapCatEntry*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooMappedCategory(void *p = 0);
   static void *newArray_RooMappedCategory(Long_t size, void *p);
   static void delete_RooMappedCategory(void *p);
   static void deleteArray_RooMappedCategory(void *p);
   static void destruct_RooMappedCategory(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooMappedCategory*)
   {
      ::RooMappedCategory *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooMappedCategory >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooMappedCategory", ::RooMappedCategory::Class_Version(), "RooMappedCategory.h", 29,
                  typeid(::RooMappedCategory), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooMappedCategory::Dictionary, isa_proxy, 4,
                  sizeof(::RooMappedCategory) );
      instance.SetNew(&new_RooMappedCategory);
      instance.SetNewArray(&newArray_RooMappedCategory);
      instance.SetDelete(&delete_RooMappedCategory);
      instance.SetDeleteArray(&deleteArray_RooMappedCategory);
      instance.SetDestructor(&destruct_RooMappedCategory);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooMappedCategory*)
   {
      return GenerateInitInstanceLocal((::RooMappedCategory*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooMappedCategory*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooMappedCategorycLcLEntry(void *p = 0);
   static void *newArray_RooMappedCategorycLcLEntry(Long_t size, void *p);
   static void delete_RooMappedCategorycLcLEntry(void *p);
   static void deleteArray_RooMappedCategorycLcLEntry(void *p);
   static void destruct_RooMappedCategorycLcLEntry(void *p);
   static void streamer_RooMappedCategorycLcLEntry(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooMappedCategory::Entry*)
   {
      ::RooMappedCategory::Entry *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooMappedCategory::Entry >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooMappedCategory::Entry", ::RooMappedCategory::Entry::Class_Version(), "RooMappedCategory.h", 51,
                  typeid(::RooMappedCategory::Entry), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooMappedCategory::Entry::Dictionary, isa_proxy, 17,
                  sizeof(::RooMappedCategory::Entry) );
      instance.SetNew(&new_RooMappedCategorycLcLEntry);
      instance.SetNewArray(&newArray_RooMappedCategorycLcLEntry);
      instance.SetDelete(&delete_RooMappedCategorycLcLEntry);
      instance.SetDeleteArray(&deleteArray_RooMappedCategorycLcLEntry);
      instance.SetDestructor(&destruct_RooMappedCategorycLcLEntry);
      instance.SetStreamerFunc(&streamer_RooMappedCategorycLcLEntry);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooMappedCategory::Entry*)
   {
      return GenerateInitInstanceLocal((::RooMappedCategory::Entry*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooMappedCategory::Entry*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static TClass *RooMath_Dictionary();
   static void RooMath_TClassManip(TClass*);
   static void *new_RooMath(void *p = 0);
   static void *newArray_RooMath(Long_t size, void *p);
   static void delete_RooMath(void *p);
   static void deleteArray_RooMath(void *p);
   static void destruct_RooMath(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooMath*)
   {
      ::RooMath *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::RooMath));
      static ::ROOT::TGenericClassInfo 
         instance("RooMath", "RooMath.h", 27,
                  typeid(::RooMath), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &RooMath_Dictionary, isa_proxy, 4,
                  sizeof(::RooMath) );
      instance.SetNew(&new_RooMath);
      instance.SetNewArray(&newArray_RooMath);
      instance.SetDelete(&delete_RooMath);
      instance.SetDeleteArray(&deleteArray_RooMath);
      instance.SetDestructor(&destruct_RooMath);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooMath*)
   {
      return GenerateInitInstanceLocal((::RooMath*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooMath*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *RooMath_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::RooMath*)0x0)->GetClass();
      RooMath_TClassManip(theClass);
   return theClass;
   }

   static void RooMath_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static void *new_RooMCIntegrator(void *p = 0);
   static void *newArray_RooMCIntegrator(Long_t size, void *p);
   static void delete_RooMCIntegrator(void *p);
   static void deleteArray_RooMCIntegrator(void *p);
   static void destruct_RooMCIntegrator(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooMCIntegrator*)
   {
      ::RooMCIntegrator *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooMCIntegrator >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooMCIntegrator", ::RooMCIntegrator::Class_Version(), "RooMCIntegrator.h", 24,
                  typeid(::RooMCIntegrator), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooMCIntegrator::Dictionary, isa_proxy, 4,
                  sizeof(::RooMCIntegrator) );
      instance.SetNew(&new_RooMCIntegrator);
      instance.SetNewArray(&newArray_RooMCIntegrator);
      instance.SetDelete(&delete_RooMCIntegrator);
      instance.SetDeleteArray(&deleteArray_RooMCIntegrator);
      instance.SetDestructor(&destruct_RooMCIntegrator);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooMCIntegrator*)
   {
      return GenerateInitInstanceLocal((::RooMCIntegrator*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooMCIntegrator*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooMinuit(void *p);
   static void deleteArray_RooMinuit(void *p);
   static void destruct_RooMinuit(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooMinuit*)
   {
      ::RooMinuit *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooMinuit >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooMinuit", ::RooMinuit::Class_Version(), "RooMinuit.h", 39,
                  typeid(::RooMinuit), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooMinuit::Dictionary, isa_proxy, 4,
                  sizeof(::RooMinuit) );
      instance.SetDelete(&delete_RooMinuit);
      instance.SetDeleteArray(&deleteArray_RooMinuit);
      instance.SetDestructor(&destruct_RooMinuit);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooMinuit*)
   {
      return GenerateInitInstanceLocal((::RooMinuit*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooMinuit*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooMPSentinel(void *p = 0);
   static void *newArray_RooMPSentinel(Long_t size, void *p);
   static void delete_RooMPSentinel(void *p);
   static void deleteArray_RooMPSentinel(void *p);
   static void destruct_RooMPSentinel(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooMPSentinel*)
   {
      ::RooMPSentinel *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooMPSentinel >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooMPSentinel", ::RooMPSentinel::Class_Version(), "RooMPSentinel.h", 23,
                  typeid(::RooMPSentinel), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooMPSentinel::Dictionary, isa_proxy, 4,
                  sizeof(::RooMPSentinel) );
      instance.SetNew(&new_RooMPSentinel);
      instance.SetNewArray(&newArray_RooMPSentinel);
      instance.SetDelete(&delete_RooMPSentinel);
      instance.SetDeleteArray(&deleteArray_RooMPSentinel);
      instance.SetDestructor(&destruct_RooMPSentinel);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooMPSentinel*)
   {
      return GenerateInitInstanceLocal((::RooMPSentinel*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooMPSentinel*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooMultiCategory(void *p = 0);
   static void *newArray_RooMultiCategory(Long_t size, void *p);
   static void delete_RooMultiCategory(void *p);
   static void deleteArray_RooMultiCategory(void *p);
   static void destruct_RooMultiCategory(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooMultiCategory*)
   {
      ::RooMultiCategory *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooMultiCategory >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooMultiCategory", ::RooMultiCategory::Class_Version(), "RooMultiCategory.h", 26,
                  typeid(::RooMultiCategory), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooMultiCategory::Dictionary, isa_proxy, 4,
                  sizeof(::RooMultiCategory) );
      instance.SetNew(&new_RooMultiCategory);
      instance.SetNewArray(&newArray_RooMultiCategory);
      instance.SetDelete(&delete_RooMultiCategory);
      instance.SetDeleteArray(&deleteArray_RooMultiCategory);
      instance.SetDestructor(&destruct_RooMultiCategory);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooMultiCategory*)
   {
      return GenerateInitInstanceLocal((::RooMultiCategory*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooMultiCategory*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooMultiCatIter(void *p);
   static void deleteArray_RooMultiCatIter(void *p);
   static void destruct_RooMultiCatIter(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooMultiCatIter*)
   {
      ::RooMultiCatIter *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooMultiCatIter >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooMultiCatIter", ::RooMultiCatIter::Class_Version(), "RooMultiCatIter.h", 29,
                  typeid(::RooMultiCatIter), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooMultiCatIter::Dictionary, isa_proxy, 4,
                  sizeof(::RooMultiCatIter) );
      instance.SetDelete(&delete_RooMultiCatIter);
      instance.SetDeleteArray(&deleteArray_RooMultiCatIter);
      instance.SetDestructor(&destruct_RooMultiCatIter);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooMultiCatIter*)
   {
      return GenerateInitInstanceLocal((::RooMultiCatIter*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooMultiCatIter*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooNLLVar(void *p = 0);
   static void *newArray_RooNLLVar(Long_t size, void *p);
   static void delete_RooNLLVar(void *p);
   static void deleteArray_RooNLLVar(void *p);
   static void destruct_RooNLLVar(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooNLLVar*)
   {
      ::RooNLLVar *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooNLLVar >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooNLLVar", ::RooNLLVar::Class_Version(), "RooNLLVar.h", 26,
                  typeid(::RooNLLVar), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooNLLVar::Dictionary, isa_proxy, 4,
                  sizeof(::RooNLLVar) );
      instance.SetNew(&new_RooNLLVar);
      instance.SetNewArray(&newArray_RooNLLVar);
      instance.SetDelete(&delete_RooNLLVar);
      instance.SetDeleteArray(&deleteArray_RooNLLVar);
      instance.SetDestructor(&destruct_RooNLLVar);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooNLLVar*)
   {
      return GenerateInitInstanceLocal((::RooNLLVar*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooNLLVar*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooNumConvolution(void *p = 0);
   static void *newArray_RooNumConvolution(Long_t size, void *p);
   static void delete_RooNumConvolution(void *p);
   static void deleteArray_RooNumConvolution(void *p);
   static void destruct_RooNumConvolution(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooNumConvolution*)
   {
      ::RooNumConvolution *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooNumConvolution >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooNumConvolution", ::RooNumConvolution::Class_Version(), "RooNumConvolution.h", 29,
                  typeid(::RooNumConvolution), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooNumConvolution::Dictionary, isa_proxy, 4,
                  sizeof(::RooNumConvolution) );
      instance.SetNew(&new_RooNumConvolution);
      instance.SetNewArray(&newArray_RooNumConvolution);
      instance.SetDelete(&delete_RooNumConvolution);
      instance.SetDeleteArray(&deleteArray_RooNumConvolution);
      instance.SetDestructor(&destruct_RooNumConvolution);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooNumConvolution*)
   {
      return GenerateInitInstanceLocal((::RooNumConvolution*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooNumConvolution*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooNumConvPdf(void *p = 0);
   static void *newArray_RooNumConvPdf(Long_t size, void *p);
   static void delete_RooNumConvPdf(void *p);
   static void deleteArray_RooNumConvPdf(void *p);
   static void destruct_RooNumConvPdf(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooNumConvPdf*)
   {
      ::RooNumConvPdf *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooNumConvPdf >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooNumConvPdf", ::RooNumConvPdf::Class_Version(), "RooNumConvPdf.h", 26,
                  typeid(::RooNumConvPdf), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooNumConvPdf::Dictionary, isa_proxy, 4,
                  sizeof(::RooNumConvPdf) );
      instance.SetNew(&new_RooNumConvPdf);
      instance.SetNewArray(&newArray_RooNumConvPdf);
      instance.SetDelete(&delete_RooNumConvPdf);
      instance.SetDeleteArray(&deleteArray_RooNumConvPdf);
      instance.SetDestructor(&destruct_RooNumConvPdf);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooNumConvPdf*)
   {
      return GenerateInitInstanceLocal((::RooNumConvPdf*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooNumConvPdf*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooNumIntFactory(void *p);
   static void deleteArray_RooNumIntFactory(void *p);
   static void destruct_RooNumIntFactory(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooNumIntFactory*)
   {
      ::RooNumIntFactory *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooNumIntFactory >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooNumIntFactory", ::RooNumIntFactory::Class_Version(), "RooNumIntFactory.h", 30,
                  typeid(::RooNumIntFactory), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooNumIntFactory::Dictionary, isa_proxy, 4,
                  sizeof(::RooNumIntFactory) );
      instance.SetDelete(&delete_RooNumIntFactory);
      instance.SetDeleteArray(&deleteArray_RooNumIntFactory);
      instance.SetDestructor(&destruct_RooNumIntFactory);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooNumIntFactory*)
   {
      return GenerateInitInstanceLocal((::RooNumIntFactory*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooNumIntFactory*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooPlot(void *p = 0);
   static void *newArray_RooPlot(Long_t size, void *p);
   static void delete_RooPlot(void *p);
   static void deleteArray_RooPlot(void *p);
   static void destruct_RooPlot(void *p);
   static void streamer_RooPlot(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooPlot*)
   {
      ::RooPlot *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooPlot >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooPlot", ::RooPlot::Class_Version(), "RooPlot.h", 41,
                  typeid(::RooPlot), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooPlot::Dictionary, isa_proxy, 17,
                  sizeof(::RooPlot) );
      instance.SetNew(&new_RooPlot);
      instance.SetNewArray(&newArray_RooPlot);
      instance.SetDelete(&delete_RooPlot);
      instance.SetDeleteArray(&deleteArray_RooPlot);
      instance.SetDestructor(&destruct_RooPlot);
      instance.SetStreamerFunc(&streamer_RooPlot);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooPlot*)
   {
      return GenerateInitInstanceLocal((::RooPlot*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooPlot*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooPolyVar(void *p = 0);
   static void *newArray_RooPolyVar(Long_t size, void *p);
   static void delete_RooPolyVar(void *p);
   static void deleteArray_RooPolyVar(void *p);
   static void destruct_RooPolyVar(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooPolyVar*)
   {
      ::RooPolyVar *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooPolyVar >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooPolyVar", ::RooPolyVar::Class_Version(), "RooPolyVar.h", 28,
                  typeid(::RooPolyVar), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooPolyVar::Dictionary, isa_proxy, 4,
                  sizeof(::RooPolyVar) );
      instance.SetNew(&new_RooPolyVar);
      instance.SetNewArray(&newArray_RooPolyVar);
      instance.SetDelete(&delete_RooPolyVar);
      instance.SetDeleteArray(&deleteArray_RooPolyVar);
      instance.SetDestructor(&destruct_RooPolyVar);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooPolyVar*)
   {
      return GenerateInitInstanceLocal((::RooPolyVar*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooPolyVar*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooProdGenContext(void *p);
   static void deleteArray_RooProdGenContext(void *p);
   static void destruct_RooProdGenContext(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooProdGenContext*)
   {
      ::RooProdGenContext *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooProdGenContext >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooProdGenContext", ::RooProdGenContext::Class_Version(), "RooProdGenContext.h", 31,
                  typeid(::RooProdGenContext), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooProdGenContext::Dictionary, isa_proxy, 4,
                  sizeof(::RooProdGenContext) );
      instance.SetDelete(&delete_RooProdGenContext);
      instance.SetDeleteArray(&deleteArray_RooProdGenContext);
      instance.SetDestructor(&destruct_RooProdGenContext);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooProdGenContext*)
   {
      return GenerateInitInstanceLocal((::RooProdGenContext*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooProdGenContext*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooProduct(void *p = 0);
   static void *newArray_RooProduct(Long_t size, void *p);
   static void delete_RooProduct(void *p);
   static void deleteArray_RooProduct(void *p);
   static void destruct_RooProduct(void *p);

   // Schema evolution read functions
   static void read_RooProduct_0( char* target, TVirtualObject *oldObj )
   {
      //--- Automatically generated variables ---
#if 0
      static Int_t id__compRSet = oldObj->GetId("_compRSet");
#endif
      struct RooProduct_Onfile {
         RooSetProxy &_compRSet;
         RooProduct_Onfile(RooSetProxy &onfile__compRSet ): _compRSet(onfile__compRSet) {}
      };
      static Long_t offset_Onfile_RooProduct__compRSet = oldObj->GetClass()->GetDataMemberOffset("_compRSet");
      char *onfile_add = (char*)oldObj->GetObject();
      RooProduct_Onfile onfile(
         *(RooSetProxy*)(onfile_add+offset_Onfile_RooProduct__compRSet) );

      static TClassRef cls("RooProduct");
      static Long_t offset__compRSet = cls->GetDataMemberOffset("_compRSet");
      RooListProxy& _compRSet = *(RooListProxy*)(target+offset__compRSet);
      RooProduct* newObj = (RooProduct*)target;
      // Supress warning message.
      if (oldObj) {}

      if (newObj) {}

      //--- User's code ---
      _compRSet.add(onfile._compRSet) ; 
   }
   static void read_RooProduct_1( char* target, TVirtualObject *oldObj )
   {
      //--- Automatically generated variables ---
#if 0
      static Int_t id__compCSet = oldObj->GetId("_compCSet");
#endif
      struct RooProduct_Onfile {
         RooSetProxy &_compCSet;
         RooProduct_Onfile(RooSetProxy &onfile__compCSet ): _compCSet(onfile__compCSet) {}
      };
      static Long_t offset_Onfile_RooProduct__compCSet = oldObj->GetClass()->GetDataMemberOffset("_compCSet");
      char *onfile_add = (char*)oldObj->GetObject();
      RooProduct_Onfile onfile(
         *(RooSetProxy*)(onfile_add+offset_Onfile_RooProduct__compCSet) );

      static TClassRef cls("RooProduct");
      static Long_t offset__compCSet = cls->GetDataMemberOffset("_compCSet");
      RooListProxy& _compCSet = *(RooListProxy*)(target+offset__compCSet);
      RooProduct* newObj = (RooProduct*)target;
      // Supress warning message.
      if (oldObj) {}

      if (newObj) {}

      //--- User's code ---
      _compCSet.add(onfile._compCSet) ; 
   }

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooProduct*)
   {
      ::RooProduct *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooProduct >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooProduct", ::RooProduct::Class_Version(), "RooProduct.h", 32,
                  typeid(::RooProduct), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooProduct::Dictionary, isa_proxy, 4,
                  sizeof(::RooProduct) );
      instance.SetNew(&new_RooProduct);
      instance.SetNewArray(&newArray_RooProduct);
      instance.SetDelete(&delete_RooProduct);
      instance.SetDeleteArray(&deleteArray_RooProduct);
      instance.SetDestructor(&destruct_RooProduct);

      ROOT::Internal::TSchemaHelper* rule;

      // the io read rules
      std::vector<ROOT::Internal::TSchemaHelper> readrules(2);
      rule = &readrules[0];
      rule->fSourceClass = "RooProduct";
      rule->fTarget      = "_compRSet";
      rule->fSource      = "RooSetProxy _compRSet";
      rule->fFunctionPtr = (void *)TFunc2void( read_RooProduct_0);
      rule->fCode        = " _compRSet.add(onfile._compRSet) ; ";
      rule->fVersion     = "[1]";
      rule = &readrules[1];
      rule->fSourceClass = "RooProduct";
      rule->fTarget      = "_compCSet";
      rule->fSource      = "RooSetProxy _compCSet";
      rule->fFunctionPtr = (void *)TFunc2void( read_RooProduct_1);
      rule->fCode        = " _compCSet.add(onfile._compCSet) ; ";
      rule->fVersion     = "[1]";
      instance.SetReadRules( readrules );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooProduct*)
   {
      return GenerateInitInstanceLocal((::RooProduct*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooProduct*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooPullVar(void *p = 0);
   static void *newArray_RooPullVar(Long_t size, void *p);
   static void delete_RooPullVar(void *p);
   static void deleteArray_RooPullVar(void *p);
   static void destruct_RooPullVar(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooPullVar*)
   {
      ::RooPullVar *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooPullVar >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooPullVar", ::RooPullVar::Class_Version(), "RooPullVar.h", 25,
                  typeid(::RooPullVar), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooPullVar::Dictionary, isa_proxy, 4,
                  sizeof(::RooPullVar) );
      instance.SetNew(&new_RooPullVar);
      instance.SetNewArray(&newArray_RooPullVar);
      instance.SetDelete(&delete_RooPullVar);
      instance.SetDeleteArray(&deleteArray_RooPullVar);
      instance.SetDestructor(&destruct_RooPullVar);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooPullVar*)
   {
      return GenerateInitInstanceLocal((::RooPullVar*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooPullVar*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooQuasiRandomGenerator(void *p = 0);
   static void *newArray_RooQuasiRandomGenerator(Long_t size, void *p);
   static void delete_RooQuasiRandomGenerator(void *p);
   static void deleteArray_RooQuasiRandomGenerator(void *p);
   static void destruct_RooQuasiRandomGenerator(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooQuasiRandomGenerator*)
   {
      ::RooQuasiRandomGenerator *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooQuasiRandomGenerator >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooQuasiRandomGenerator", ::RooQuasiRandomGenerator::Class_Version(), "RooQuasiRandomGenerator.h", 21,
                  typeid(::RooQuasiRandomGenerator), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooQuasiRandomGenerator::Dictionary, isa_proxy, 4,
                  sizeof(::RooQuasiRandomGenerator) );
      instance.SetNew(&new_RooQuasiRandomGenerator);
      instance.SetNewArray(&newArray_RooQuasiRandomGenerator);
      instance.SetDelete(&delete_RooQuasiRandomGenerator);
      instance.SetDeleteArray(&deleteArray_RooQuasiRandomGenerator);
      instance.SetDestructor(&destruct_RooQuasiRandomGenerator);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooQuasiRandomGenerator*)
   {
      return GenerateInitInstanceLocal((::RooQuasiRandomGenerator*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooQuasiRandomGenerator*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooRandom(void *p);
   static void deleteArray_RooRandom(void *p);
   static void destruct_RooRandom(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooRandom*)
   {
      ::RooRandom *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooRandom >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooRandom", ::RooRandom::Class_Version(), "RooRandom.h", 24,
                  typeid(::RooRandom), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooRandom::Dictionary, isa_proxy, 4,
                  sizeof(::RooRandom) );
      instance.SetDelete(&delete_RooRandom);
      instance.SetDeleteArray(&deleteArray_RooRandom);
      instance.SetDestructor(&destruct_RooRandom);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooRandom*)
   {
      return GenerateInitInstanceLocal((::RooRandom*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooRandom*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooRandomizeParamMCSModule(void *p = 0);
   static void *newArray_RooRandomizeParamMCSModule(Long_t size, void *p);
   static void delete_RooRandomizeParamMCSModule(void *p);
   static void deleteArray_RooRandomizeParamMCSModule(void *p);
   static void destruct_RooRandomizeParamMCSModule(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooRandomizeParamMCSModule*)
   {
      ::RooRandomizeParamMCSModule *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooRandomizeParamMCSModule >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooRandomizeParamMCSModule", ::RooRandomizeParamMCSModule::Class_Version(), "RooRandomizeParamMCSModule.h", 24,
                  typeid(::RooRandomizeParamMCSModule), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooRandomizeParamMCSModule::Dictionary, isa_proxy, 4,
                  sizeof(::RooRandomizeParamMCSModule) );
      instance.SetNew(&new_RooRandomizeParamMCSModule);
      instance.SetNewArray(&newArray_RooRandomizeParamMCSModule);
      instance.SetDelete(&delete_RooRandomizeParamMCSModule);
      instance.SetDeleteArray(&deleteArray_RooRandomizeParamMCSModule);
      instance.SetDestructor(&destruct_RooRandomizeParamMCSModule);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooRandomizeParamMCSModule*)
   {
      return GenerateInitInstanceLocal((::RooRandomizeParamMCSModule*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooRandomizeParamMCSModule*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooRangeBinning(void *p = 0);
   static void *newArray_RooRangeBinning(Long_t size, void *p);
   static void delete_RooRangeBinning(void *p);
   static void deleteArray_RooRangeBinning(void *p);
   static void destruct_RooRangeBinning(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooRangeBinning*)
   {
      ::RooRangeBinning *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooRangeBinning >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooRangeBinning", ::RooRangeBinning::Class_Version(), "RooRangeBinning.h", 21,
                  typeid(::RooRangeBinning), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooRangeBinning::Dictionary, isa_proxy, 4,
                  sizeof(::RooRangeBinning) );
      instance.SetNew(&new_RooRangeBinning);
      instance.SetNewArray(&newArray_RooRangeBinning);
      instance.SetDelete(&delete_RooRangeBinning);
      instance.SetDeleteArray(&deleteArray_RooRangeBinning);
      instance.SetDestructor(&destruct_RooRangeBinning);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooRangeBinning*)
   {
      return GenerateInitInstanceLocal((::RooRangeBinning*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooRangeBinning*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooRealAnalytic(void *p);
   static void deleteArray_RooRealAnalytic(void *p);
   static void destruct_RooRealAnalytic(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooRealAnalytic*)
   {
      ::RooRealAnalytic *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooRealAnalytic >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooRealAnalytic", ::RooRealAnalytic::Class_Version(), "RooRealAnalytic.h", 21,
                  typeid(::RooRealAnalytic), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooRealAnalytic::Dictionary, isa_proxy, 4,
                  sizeof(::RooRealAnalytic) );
      instance.SetDelete(&delete_RooRealAnalytic);
      instance.SetDeleteArray(&deleteArray_RooRealAnalytic);
      instance.SetDestructor(&destruct_RooRealAnalytic);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooRealAnalytic*)
   {
      return GenerateInitInstanceLocal((::RooRealAnalytic*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooRealAnalytic*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooRealConstant(void *p = 0);
   static void *newArray_RooRealConstant(Long_t size, void *p);
   static void delete_RooRealConstant(void *p);
   static void deleteArray_RooRealConstant(void *p);
   static void destruct_RooRealConstant(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooRealConstant*)
   {
      ::RooRealConstant *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooRealConstant >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooRealConstant", ::RooRealConstant::Class_Version(), "RooRealConstant.h", 26,
                  typeid(::RooRealConstant), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooRealConstant::Dictionary, isa_proxy, 4,
                  sizeof(::RooRealConstant) );
      instance.SetNew(&new_RooRealConstant);
      instance.SetNewArray(&newArray_RooRealConstant);
      instance.SetDelete(&delete_RooRealConstant);
      instance.SetDeleteArray(&deleteArray_RooRealConstant);
      instance.SetDestructor(&destruct_RooRealConstant);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooRealConstant*)
   {
      return GenerateInitInstanceLocal((::RooRealConstant*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooRealConstant*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooRealIntegral(void *p = 0);
   static void *newArray_RooRealIntegral(Long_t size, void *p);
   static void delete_RooRealIntegral(void *p);
   static void deleteArray_RooRealIntegral(void *p);
   static void destruct_RooRealIntegral(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooRealIntegral*)
   {
      ::RooRealIntegral *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooRealIntegral >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooRealIntegral", ::RooRealIntegral::Class_Version(), "RooRealIntegral.h", 33,
                  typeid(::RooRealIntegral), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooRealIntegral::Dictionary, isa_proxy, 4,
                  sizeof(::RooRealIntegral) );
      instance.SetNew(&new_RooRealIntegral);
      instance.SetNewArray(&newArray_RooRealIntegral);
      instance.SetDelete(&delete_RooRealIntegral);
      instance.SetDeleteArray(&deleteArray_RooRealIntegral);
      instance.SetDestructor(&destruct_RooRealIntegral);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooRealIntegral*)
   {
      return GenerateInitInstanceLocal((::RooRealIntegral*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooRealIntegral*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooRealMPFE(void *p);
   static void deleteArray_RooRealMPFE(void *p);
   static void destruct_RooRealMPFE(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooRealMPFE*)
   {
      ::RooRealMPFE *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooRealMPFE >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooRealMPFE", ::RooRealMPFE::Class_Version(), "RooRealMPFE.h", 30,
                  typeid(::RooRealMPFE), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooRealMPFE::Dictionary, isa_proxy, 4,
                  sizeof(::RooRealMPFE) );
      instance.SetDelete(&delete_RooRealMPFE);
      instance.SetDeleteArray(&deleteArray_RooRealMPFE);
      instance.SetDestructor(&destruct_RooRealMPFE);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooRealMPFE*)
   {
      return GenerateInitInstanceLocal((::RooRealMPFE*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooRealMPFE*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooScaledFunc(void *p);
   static void deleteArray_RooScaledFunc(void *p);
   static void destruct_RooScaledFunc(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooScaledFunc*)
   {
      ::RooScaledFunc *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooScaledFunc >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooScaledFunc", ::RooScaledFunc::Class_Version(), "RooScaledFunc.h", 21,
                  typeid(::RooScaledFunc), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooScaledFunc::Dictionary, isa_proxy, 4,
                  sizeof(::RooScaledFunc) );
      instance.SetDelete(&delete_RooScaledFunc);
      instance.SetDeleteArray(&deleteArray_RooScaledFunc);
      instance.SetDestructor(&destruct_RooScaledFunc);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooScaledFunc*)
   {
      return GenerateInitInstanceLocal((::RooScaledFunc*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooScaledFunc*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooSegmentedIntegrator1D(void *p = 0);
   static void *newArray_RooSegmentedIntegrator1D(Long_t size, void *p);
   static void delete_RooSegmentedIntegrator1D(void *p);
   static void deleteArray_RooSegmentedIntegrator1D(void *p);
   static void destruct_RooSegmentedIntegrator1D(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooSegmentedIntegrator1D*)
   {
      ::RooSegmentedIntegrator1D *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooSegmentedIntegrator1D >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooSegmentedIntegrator1D", ::RooSegmentedIntegrator1D::Class_Version(), "RooSegmentedIntegrator1D.h", 23,
                  typeid(::RooSegmentedIntegrator1D), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooSegmentedIntegrator1D::Dictionary, isa_proxy, 4,
                  sizeof(::RooSegmentedIntegrator1D) );
      instance.SetNew(&new_RooSegmentedIntegrator1D);
      instance.SetNewArray(&newArray_RooSegmentedIntegrator1D);
      instance.SetDelete(&delete_RooSegmentedIntegrator1D);
      instance.SetDeleteArray(&deleteArray_RooSegmentedIntegrator1D);
      instance.SetDestructor(&destruct_RooSegmentedIntegrator1D);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooSegmentedIntegrator1D*)
   {
      return GenerateInitInstanceLocal((::RooSegmentedIntegrator1D*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooSegmentedIntegrator1D*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooSegmentedIntegrator2D(void *p = 0);
   static void *newArray_RooSegmentedIntegrator2D(Long_t size, void *p);
   static void delete_RooSegmentedIntegrator2D(void *p);
   static void deleteArray_RooSegmentedIntegrator2D(void *p);
   static void destruct_RooSegmentedIntegrator2D(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooSegmentedIntegrator2D*)
   {
      ::RooSegmentedIntegrator2D *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooSegmentedIntegrator2D >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooSegmentedIntegrator2D", ::RooSegmentedIntegrator2D::Class_Version(), "RooSegmentedIntegrator2D.h", 23,
                  typeid(::RooSegmentedIntegrator2D), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooSegmentedIntegrator2D::Dictionary, isa_proxy, 4,
                  sizeof(::RooSegmentedIntegrator2D) );
      instance.SetNew(&new_RooSegmentedIntegrator2D);
      instance.SetNewArray(&newArray_RooSegmentedIntegrator2D);
      instance.SetDelete(&delete_RooSegmentedIntegrator2D);
      instance.SetDeleteArray(&deleteArray_RooSegmentedIntegrator2D);
      instance.SetDestructor(&destruct_RooSegmentedIntegrator2D);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooSegmentedIntegrator2D*)
   {
      return GenerateInitInstanceLocal((::RooSegmentedIntegrator2D*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooSegmentedIntegrator2D*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooSetPair(void *p = 0);
   static void *newArray_RooSetPair(Long_t size, void *p);
   static void delete_RooSetPair(void *p);
   static void deleteArray_RooSetPair(void *p);
   static void destruct_RooSetPair(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooSetPair*)
   {
      ::RooSetPair *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooSetPair >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooSetPair", ::RooSetPair::Class_Version(), "RooSetPair.h", 26,
                  typeid(::RooSetPair), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooSetPair::Dictionary, isa_proxy, 4,
                  sizeof(::RooSetPair) );
      instance.SetNew(&new_RooSetPair);
      instance.SetNewArray(&newArray_RooSetPair);
      instance.SetDelete(&delete_RooSetPair);
      instance.SetDeleteArray(&deleteArray_RooSetPair);
      instance.SetDestructor(&destruct_RooSetPair);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooSetPair*)
   {
      return GenerateInitInstanceLocal((::RooSetPair*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooSetPair*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooSimGenContext(void *p);
   static void deleteArray_RooSimGenContext(void *p);
   static void destruct_RooSimGenContext(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooSimGenContext*)
   {
      ::RooSimGenContext *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooSimGenContext >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooSimGenContext", ::RooSimGenContext::Class_Version(), "RooSimGenContext.h", 28,
                  typeid(::RooSimGenContext), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooSimGenContext::Dictionary, isa_proxy, 4,
                  sizeof(::RooSimGenContext) );
      instance.SetDelete(&delete_RooSimGenContext);
      instance.SetDeleteArray(&deleteArray_RooSimGenContext);
      instance.SetDestructor(&destruct_RooSimGenContext);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooSimGenContext*)
   {
      return GenerateInitInstanceLocal((::RooSimGenContext*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooSimGenContext*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooSimSplitGenContext(void *p);
   static void deleteArray_RooSimSplitGenContext(void *p);
   static void destruct_RooSimSplitGenContext(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooSimSplitGenContext*)
   {
      ::RooSimSplitGenContext *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooSimSplitGenContext >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooSimSplitGenContext", ::RooSimSplitGenContext::Class_Version(), "RooSimSplitGenContext.h", 28,
                  typeid(::RooSimSplitGenContext), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooSimSplitGenContext::Dictionary, isa_proxy, 4,
                  sizeof(::RooSimSplitGenContext) );
      instance.SetDelete(&delete_RooSimSplitGenContext);
      instance.SetDeleteArray(&deleteArray_RooSimSplitGenContext);
      instance.SetDestructor(&destruct_RooSimSplitGenContext);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooSimSplitGenContext*)
   {
      return GenerateInitInstanceLocal((::RooSimSplitGenContext*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooSimSplitGenContext*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooStreamParser(void *p);
   static void deleteArray_RooStreamParser(void *p);
   static void destruct_RooStreamParser(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooStreamParser*)
   {
      ::RooStreamParser *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooStreamParser >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooStreamParser", ::RooStreamParser::Class_Version(), "RooStreamParser.h", 21,
                  typeid(::RooStreamParser), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooStreamParser::Dictionary, isa_proxy, 4,
                  sizeof(::RooStreamParser) );
      instance.SetDelete(&delete_RooStreamParser);
      instance.SetDeleteArray(&deleteArray_RooStreamParser);
      instance.SetDestructor(&destruct_RooStreamParser);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooStreamParser*)
   {
      return GenerateInitInstanceLocal((::RooStreamParser*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooStreamParser*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooStringVar(void *p = 0);
   static void *newArray_RooStringVar(Long_t size, void *p);
   static void delete_RooStringVar(void *p);
   static void deleteArray_RooStringVar(void *p);
   static void destruct_RooStringVar(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooStringVar*)
   {
      ::RooStringVar *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooStringVar >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooStringVar", ::RooStringVar::Class_Version(), "RooStringVar.h", 23,
                  typeid(::RooStringVar), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooStringVar::Dictionary, isa_proxy, 4,
                  sizeof(::RooStringVar) );
      instance.SetNew(&new_RooStringVar);
      instance.SetNewArray(&newArray_RooStringVar);
      instance.SetDelete(&delete_RooStringVar);
      instance.SetDeleteArray(&deleteArray_RooStringVar);
      instance.SetDestructor(&destruct_RooStringVar);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooStringVar*)
   {
      return GenerateInitInstanceLocal((::RooStringVar*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooStringVar*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooSuperCategory(void *p = 0);
   static void *newArray_RooSuperCategory(Long_t size, void *p);
   static void delete_RooSuperCategory(void *p);
   static void deleteArray_RooSuperCategory(void *p);
   static void destruct_RooSuperCategory(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooSuperCategory*)
   {
      ::RooSuperCategory *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooSuperCategory >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooSuperCategory", ::RooSuperCategory::Class_Version(), "RooSuperCategory.h", 26,
                  typeid(::RooSuperCategory), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooSuperCategory::Dictionary, isa_proxy, 4,
                  sizeof(::RooSuperCategory) );
      instance.SetNew(&new_RooSuperCategory);
      instance.SetNewArray(&newArray_RooSuperCategory);
      instance.SetDelete(&delete_RooSuperCategory);
      instance.SetDeleteArray(&deleteArray_RooSuperCategory);
      instance.SetDestructor(&destruct_RooSuperCategory);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooSuperCategory*)
   {
      return GenerateInitInstanceLocal((::RooSuperCategory*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooSuperCategory*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooThreshEntry(void *p = 0);
   static void *newArray_RooThreshEntry(Long_t size, void *p);
   static void delete_RooThreshEntry(void *p);
   static void deleteArray_RooThreshEntry(void *p);
   static void destruct_RooThreshEntry(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooThreshEntry*)
   {
      ::RooThreshEntry *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooThreshEntry >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooThreshEntry", ::RooThreshEntry::Class_Version(), "RooThreshEntry.h", 22,
                  typeid(::RooThreshEntry), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooThreshEntry::Dictionary, isa_proxy, 4,
                  sizeof(::RooThreshEntry) );
      instance.SetNew(&new_RooThreshEntry);
      instance.SetNewArray(&newArray_RooThreshEntry);
      instance.SetDelete(&delete_RooThreshEntry);
      instance.SetDeleteArray(&deleteArray_RooThreshEntry);
      instance.SetDestructor(&destruct_RooThreshEntry);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooThreshEntry*)
   {
      return GenerateInitInstanceLocal((::RooThreshEntry*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooThreshEntry*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooThresholdCategory(void *p = 0);
   static void *newArray_RooThresholdCategory(Long_t size, void *p);
   static void delete_RooThresholdCategory(void *p);
   static void deleteArray_RooThresholdCategory(void *p);
   static void destruct_RooThresholdCategory(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooThresholdCategory*)
   {
      ::RooThresholdCategory *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooThresholdCategory >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooThresholdCategory", ::RooThresholdCategory::Class_Version(), "RooThresholdCategory.h", 24,
                  typeid(::RooThresholdCategory), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooThresholdCategory::Dictionary, isa_proxy, 4,
                  sizeof(::RooThresholdCategory) );
      instance.SetNew(&new_RooThresholdCategory);
      instance.SetNewArray(&newArray_RooThresholdCategory);
      instance.SetDelete(&delete_RooThresholdCategory);
      instance.SetDeleteArray(&deleteArray_RooThresholdCategory);
      instance.SetDestructor(&destruct_RooThresholdCategory);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooThresholdCategory*)
   {
      return GenerateInitInstanceLocal((::RooThresholdCategory*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooThresholdCategory*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooTObjWrap(void *p = 0);
   static void *newArray_RooTObjWrap(Long_t size, void *p);
   static void delete_RooTObjWrap(void *p);
   static void deleteArray_RooTObjWrap(void *p);
   static void destruct_RooTObjWrap(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooTObjWrap*)
   {
      ::RooTObjWrap *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooTObjWrap >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooTObjWrap", ::RooTObjWrap::Class_Version(), "RooTObjWrap.h", 23,
                  typeid(::RooTObjWrap), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooTObjWrap::Dictionary, isa_proxy, 4,
                  sizeof(::RooTObjWrap) );
      instance.SetNew(&new_RooTObjWrap);
      instance.SetNewArray(&newArray_RooTObjWrap);
      instance.SetDelete(&delete_RooTObjWrap);
      instance.SetDeleteArray(&deleteArray_RooTObjWrap);
      instance.SetDestructor(&destruct_RooTObjWrap);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooTObjWrap*)
   {
      return GenerateInitInstanceLocal((::RooTObjWrap*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooTObjWrap*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooSimultaneous(void *p = 0);
   static void *newArray_RooSimultaneous(Long_t size, void *p);
   static void delete_RooSimultaneous(void *p);
   static void deleteArray_RooSimultaneous(void *p);
   static void destruct_RooSimultaneous(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooSimultaneous*)
   {
      ::RooSimultaneous *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooSimultaneous >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooSimultaneous", ::RooSimultaneous::Class_Version(), "RooSimultaneous.h", 37,
                  typeid(::RooSimultaneous), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooSimultaneous::Dictionary, isa_proxy, 4,
                  sizeof(::RooSimultaneous) );
      instance.SetNew(&new_RooSimultaneous);
      instance.SetNewArray(&newArray_RooSimultaneous);
      instance.SetDelete(&delete_RooSimultaneous);
      instance.SetDeleteArray(&deleteArray_RooSimultaneous);
      instance.SetDestructor(&destruct_RooSimultaneous);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooSimultaneous*)
   {
      return GenerateInitInstanceLocal((::RooSimultaneous*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooSimultaneous*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooRealSumPdf(void *p = 0);
   static void *newArray_RooRealSumPdf(Long_t size, void *p);
   static void delete_RooRealSumPdf(void *p);
   static void deleteArray_RooRealSumPdf(void *p);
   static void destruct_RooRealSumPdf(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooRealSumPdf*)
   {
      ::RooRealSumPdf *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooRealSumPdf >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooRealSumPdf", ::RooRealSumPdf::Class_Version(), "RooRealSumPdf.h", 24,
                  typeid(::RooRealSumPdf), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooRealSumPdf::Dictionary, isa_proxy, 4,
                  sizeof(::RooRealSumPdf) );
      instance.SetNew(&new_RooRealSumPdf);
      instance.SetNewArray(&newArray_RooRealSumPdf);
      instance.SetDelete(&delete_RooRealSumPdf);
      instance.SetDeleteArray(&deleteArray_RooRealSumPdf);
      instance.SetDestructor(&destruct_RooRealSumPdf);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooRealSumPdf*)
   {
      return GenerateInitInstanceLocal((::RooRealSumPdf*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooRealSumPdf*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooProdPdf(void *p = 0);
   static void *newArray_RooProdPdf(Long_t size, void *p);
   static void delete_RooProdPdf(void *p);
   static void deleteArray_RooProdPdf(void *p);
   static void destruct_RooProdPdf(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooProdPdf*)
   {
      ::RooProdPdf *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooProdPdf >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooProdPdf", ::RooProdPdf::Class_Version(), "RooProdPdf.h", 31,
                  typeid(::RooProdPdf), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooProdPdf::Dictionary, isa_proxy, 4,
                  sizeof(::RooProdPdf) );
      instance.SetNew(&new_RooProdPdf);
      instance.SetNewArray(&newArray_RooProdPdf);
      instance.SetDelete(&delete_RooProdPdf);
      instance.SetDeleteArray(&deleteArray_RooProdPdf);
      instance.SetDestructor(&destruct_RooProdPdf);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooProdPdf*)
   {
      return GenerateInitInstanceLocal((::RooProdPdf*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooProdPdf*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooSimPdfBuilder(void *p);
   static void deleteArray_RooSimPdfBuilder(void *p);
   static void destruct_RooSimPdfBuilder(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooSimPdfBuilder*)
   {
      ::RooSimPdfBuilder *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooSimPdfBuilder >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooSimPdfBuilder", ::RooSimPdfBuilder::Class_Version(), "RooSimPdfBuilder.h", 30,
                  typeid(::RooSimPdfBuilder), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooSimPdfBuilder::Dictionary, isa_proxy, 4,
                  sizeof(::RooSimPdfBuilder) );
      instance.SetDelete(&delete_RooSimPdfBuilder);
      instance.SetDeleteArray(&deleteArray_RooSimPdfBuilder);
      instance.SetDestructor(&destruct_RooSimPdfBuilder);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooSimPdfBuilder*)
   {
      return GenerateInitInstanceLocal((::RooSimPdfBuilder*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooSimPdfBuilder*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooTruthModel(void *p = 0);
   static void *newArray_RooTruthModel(Long_t size, void *p);
   static void delete_RooTruthModel(void *p);
   static void deleteArray_RooTruthModel(void *p);
   static void destruct_RooTruthModel(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooTruthModel*)
   {
      ::RooTruthModel *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooTruthModel >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooTruthModel", ::RooTruthModel::Class_Version(), "RooTruthModel.h", 21,
                  typeid(::RooTruthModel), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooTruthModel::Dictionary, isa_proxy, 4,
                  sizeof(::RooTruthModel) );
      instance.SetNew(&new_RooTruthModel);
      instance.SetNewArray(&newArray_RooTruthModel);
      instance.SetDelete(&delete_RooTruthModel);
      instance.SetDeleteArray(&deleteArray_RooTruthModel);
      instance.SetDestructor(&destruct_RooTruthModel);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooTruthModel*)
   {
      return GenerateInitInstanceLocal((::RooTruthModel*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooTruthModel*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooProjectedPdf(void *p = 0);
   static void *newArray_RooProjectedPdf(Long_t size, void *p);
   static void delete_RooProjectedPdf(void *p);
   static void deleteArray_RooProjectedPdf(void *p);
   static void destruct_RooProjectedPdf(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooProjectedPdf*)
   {
      ::RooProjectedPdf *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooProjectedPdf >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooProjectedPdf", ::RooProjectedPdf::Class_Version(), "RooProjectedPdf.h", 21,
                  typeid(::RooProjectedPdf), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooProjectedPdf::Dictionary, isa_proxy, 4,
                  sizeof(::RooProjectedPdf) );
      instance.SetNew(&new_RooProjectedPdf);
      instance.SetNewArray(&newArray_RooProjectedPdf);
      instance.SetDelete(&delete_RooProjectedPdf);
      instance.SetDeleteArray(&deleteArray_RooProjectedPdf);
      instance.SetDestructor(&destruct_RooProjectedPdf);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooProjectedPdf*)
   {
      return GenerateInitInstanceLocal((::RooProjectedPdf*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooProjectedPdf*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooExpensiveObjectCache(void *p = 0);
   static void *newArray_RooExpensiveObjectCache(Long_t size, void *p);
   static void delete_RooExpensiveObjectCache(void *p);
   static void deleteArray_RooExpensiveObjectCache(void *p);
   static void destruct_RooExpensiveObjectCache(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooExpensiveObjectCache*)
   {
      ::RooExpensiveObjectCache *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooExpensiveObjectCache >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooExpensiveObjectCache", ::RooExpensiveObjectCache::Class_Version(), "RooExpensiveObjectCache.h", 25,
                  typeid(::RooExpensiveObjectCache), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooExpensiveObjectCache::Dictionary, isa_proxy, 4,
                  sizeof(::RooExpensiveObjectCache) );
      instance.SetNew(&new_RooExpensiveObjectCache);
      instance.SetNewArray(&newArray_RooExpensiveObjectCache);
      instance.SetDelete(&delete_RooExpensiveObjectCache);
      instance.SetDeleteArray(&deleteArray_RooExpensiveObjectCache);
      instance.SetDestructor(&destruct_RooExpensiveObjectCache);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooExpensiveObjectCache*)
   {
      return GenerateInitInstanceLocal((::RooExpensiveObjectCache*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooExpensiveObjectCache*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooExpensiveObjectCachecLcLExpensiveObject(void *p = 0);
   static void *newArray_RooExpensiveObjectCachecLcLExpensiveObject(Long_t size, void *p);
   static void delete_RooExpensiveObjectCachecLcLExpensiveObject(void *p);
   static void deleteArray_RooExpensiveObjectCachecLcLExpensiveObject(void *p);
   static void destruct_RooExpensiveObjectCachecLcLExpensiveObject(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooExpensiveObjectCache::ExpensiveObject*)
   {
      ::RooExpensiveObjectCache::ExpensiveObject *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooExpensiveObjectCache::ExpensiveObject >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooExpensiveObjectCache::ExpensiveObject", ::RooExpensiveObjectCache::ExpensiveObject::Class_Version(), "RooExpensiveObjectCache.h", 51,
                  typeid(::RooExpensiveObjectCache::ExpensiveObject), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooExpensiveObjectCache::ExpensiveObject::Dictionary, isa_proxy, 4,
                  sizeof(::RooExpensiveObjectCache::ExpensiveObject) );
      instance.SetNew(&new_RooExpensiveObjectCachecLcLExpensiveObject);
      instance.SetNewArray(&newArray_RooExpensiveObjectCachecLcLExpensiveObject);
      instance.SetDelete(&delete_RooExpensiveObjectCachecLcLExpensiveObject);
      instance.SetDeleteArray(&deleteArray_RooExpensiveObjectCachecLcLExpensiveObject);
      instance.SetDestructor(&destruct_RooExpensiveObjectCachecLcLExpensiveObject);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooExpensiveObjectCache::ExpensiveObject*)
   {
      return GenerateInitInstanceLocal((::RooExpensiveObjectCache::ExpensiveObject*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooExpensiveObjectCache::ExpensiveObject*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooWorkspace(void *p = 0);
   static void *newArray_RooWorkspace(Long_t size, void *p);
   static void delete_RooWorkspace(void *p);
   static void deleteArray_RooWorkspace(void *p);
   static void destruct_RooWorkspace(void *p);
   static void streamer_RooWorkspace(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooWorkspace*)
   {
      ::RooWorkspace *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooWorkspace >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooWorkspace", ::RooWorkspace::Class_Version(), "RooWorkspace.h", 42,
                  typeid(::RooWorkspace), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooWorkspace::Dictionary, isa_proxy, 17,
                  sizeof(::RooWorkspace) );
      instance.SetNew(&new_RooWorkspace);
      instance.SetNewArray(&newArray_RooWorkspace);
      instance.SetDelete(&delete_RooWorkspace);
      instance.SetDeleteArray(&deleteArray_RooWorkspace);
      instance.SetDestructor(&destruct_RooWorkspace);
      instance.SetStreamerFunc(&streamer_RooWorkspace);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooWorkspace*)
   {
      return GenerateInitInstanceLocal((::RooWorkspace*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooWorkspace*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooWorkspacecLcLCodeRepo(void *p = 0);
   static void *newArray_RooWorkspacecLcLCodeRepo(Long_t size, void *p);
   static void delete_RooWorkspacecLcLCodeRepo(void *p);
   static void deleteArray_RooWorkspacecLcLCodeRepo(void *p);
   static void destruct_RooWorkspacecLcLCodeRepo(void *p);
   static void streamer_RooWorkspacecLcLCodeRepo(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooWorkspace::CodeRepo*)
   {
      ::RooWorkspace::CodeRepo *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooWorkspace::CodeRepo >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooWorkspace::CodeRepo", ::RooWorkspace::CodeRepo::Class_Version(), "RooWorkspace.h", 156,
                  typeid(::RooWorkspace::CodeRepo), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooWorkspace::CodeRepo::Dictionary, isa_proxy, 17,
                  sizeof(::RooWorkspace::CodeRepo) );
      instance.SetNew(&new_RooWorkspacecLcLCodeRepo);
      instance.SetNewArray(&newArray_RooWorkspacecLcLCodeRepo);
      instance.SetDelete(&delete_RooWorkspacecLcLCodeRepo);
      instance.SetDeleteArray(&deleteArray_RooWorkspacecLcLCodeRepo);
      instance.SetDestructor(&destruct_RooWorkspacecLcLCodeRepo);
      instance.SetStreamerFunc(&streamer_RooWorkspacecLcLCodeRepo);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooWorkspace::CodeRepo*)
   {
      return GenerateInitInstanceLocal((::RooWorkspace::CodeRepo*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooWorkspace::CodeRepo*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooWorkspacecLcLWSDir(void *p);
   static void deleteArray_RooWorkspacecLcLWSDir(void *p);
   static void destruct_RooWorkspacecLcLWSDir(void *p);
   static void reset_RooWorkspacecLcLWSDir(void *obj, TFileMergeInfo *info);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooWorkspace::WSDir*)
   {
      ::RooWorkspace::WSDir *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooWorkspace::WSDir >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooWorkspace::WSDir", ::RooWorkspace::WSDir::Class_Version(), "RooWorkspace.h", 211,
                  typeid(::RooWorkspace::WSDir), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooWorkspace::WSDir::Dictionary, isa_proxy, 4,
                  sizeof(::RooWorkspace::WSDir) );
      instance.SetDelete(&delete_RooWorkspacecLcLWSDir);
      instance.SetDeleteArray(&deleteArray_RooWorkspacecLcLWSDir);
      instance.SetDestructor(&destruct_RooWorkspacecLcLWSDir);
      instance.SetResetAfterMerge(&reset_RooWorkspacecLcLWSDir);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooWorkspace::WSDir*)
   {
      return GenerateInitInstanceLocal((::RooWorkspace::WSDir*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooWorkspace::WSDir*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooProfileLL(void *p = 0);
   static void *newArray_RooProfileLL(Long_t size, void *p);
   static void delete_RooProfileLL(void *p);
   static void deleteArray_RooProfileLL(void *p);
   static void destruct_RooProfileLL(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooProfileLL*)
   {
      ::RooProfileLL *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooProfileLL >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooProfileLL", ::RooProfileLL::Class_Version(), "RooProfileLL.h", 26,
                  typeid(::RooProfileLL), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooProfileLL::Dictionary, isa_proxy, 4,
                  sizeof(::RooProfileLL) );
      instance.SetNew(&new_RooProfileLL);
      instance.SetNewArray(&newArray_RooProfileLL);
      instance.SetDelete(&delete_RooProfileLL);
      instance.SetDeleteArray(&deleteArray_RooProfileLL);
      instance.SetDestructor(&destruct_RooProfileLL);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooProfileLL*)
   {
      return GenerateInitInstanceLocal((::RooProfileLL*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooProfileLL*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooHistPdf(void *p = 0);
   static void *newArray_RooHistPdf(Long_t size, void *p);
   static void delete_RooHistPdf(void *p);
   static void deleteArray_RooHistPdf(void *p);
   static void destruct_RooHistPdf(void *p);
   static void streamer_RooHistPdf(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooHistPdf*)
   {
      ::RooHistPdf *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooHistPdf >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooHistPdf", ::RooHistPdf::Class_Version(), "RooHistPdf.h", 28,
                  typeid(::RooHistPdf), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooHistPdf::Dictionary, isa_proxy, 17,
                  sizeof(::RooHistPdf) );
      instance.SetNew(&new_RooHistPdf);
      instance.SetNewArray(&newArray_RooHistPdf);
      instance.SetDelete(&delete_RooHistPdf);
      instance.SetDeleteArray(&deleteArray_RooHistPdf);
      instance.SetDestructor(&destruct_RooHistPdf);
      instance.SetStreamerFunc(&streamer_RooHistPdf);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooHistPdf*)
   {
      return GenerateInitInstanceLocal((::RooHistPdf*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooHistPdf*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooAbsCachedPdf(void *p);
   static void deleteArray_RooAbsCachedPdf(void *p);
   static void destruct_RooAbsCachedPdf(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooAbsCachedPdf*)
   {
      ::RooAbsCachedPdf *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooAbsCachedPdf >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooAbsCachedPdf", ::RooAbsCachedPdf::Class_Version(), "RooAbsCachedPdf.h", 25,
                  typeid(::RooAbsCachedPdf), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooAbsCachedPdf::Dictionary, isa_proxy, 4,
                  sizeof(::RooAbsCachedPdf) );
      instance.SetDelete(&delete_RooAbsCachedPdf);
      instance.SetDeleteArray(&deleteArray_RooAbsCachedPdf);
      instance.SetDestructor(&destruct_RooAbsCachedPdf);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooAbsCachedPdf*)
   {
      return GenerateInitInstanceLocal((::RooAbsCachedPdf*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooAbsCachedPdf*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static TClass *RooAbsCachedPdfcLcLPdfCacheElem_Dictionary();
   static void RooAbsCachedPdfcLcLPdfCacheElem_TClassManip(TClass*);
   static void delete_RooAbsCachedPdfcLcLPdfCacheElem(void *p);
   static void deleteArray_RooAbsCachedPdfcLcLPdfCacheElem(void *p);
   static void destruct_RooAbsCachedPdfcLcLPdfCacheElem(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooAbsCachedPdf::PdfCacheElem*)
   {
      ::RooAbsCachedPdf::PdfCacheElem *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::RooAbsCachedPdf::PdfCacheElem));
      static ::ROOT::TGenericClassInfo 
         instance("RooAbsCachedPdf::PdfCacheElem", "RooAbsCachedPdf.h", 63,
                  typeid(::RooAbsCachedPdf::PdfCacheElem), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &RooAbsCachedPdfcLcLPdfCacheElem_Dictionary, isa_proxy, 4,
                  sizeof(::RooAbsCachedPdf::PdfCacheElem) );
      instance.SetDelete(&delete_RooAbsCachedPdfcLcLPdfCacheElem);
      instance.SetDeleteArray(&deleteArray_RooAbsCachedPdfcLcLPdfCacheElem);
      instance.SetDestructor(&destruct_RooAbsCachedPdfcLcLPdfCacheElem);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooAbsCachedPdf::PdfCacheElem*)
   {
      return GenerateInitInstanceLocal((::RooAbsCachedPdf::PdfCacheElem*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooAbsCachedPdf::PdfCacheElem*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *RooAbsCachedPdfcLcLPdfCacheElem_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::RooAbsCachedPdf::PdfCacheElem*)0x0)->GetClass();
      RooAbsCachedPdfcLcLPdfCacheElem_TClassManip(theClass);
   return theClass;
   }

   static void RooAbsCachedPdfcLcLPdfCacheElem_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static void delete_RooAbsSelfCachedPdf(void *p);
   static void deleteArray_RooAbsSelfCachedPdf(void *p);
   static void destruct_RooAbsSelfCachedPdf(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooAbsSelfCachedPdf*)
   {
      ::RooAbsSelfCachedPdf *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooAbsSelfCachedPdf >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooAbsSelfCachedPdf", ::RooAbsSelfCachedPdf::Class_Version(), "RooAbsSelfCachedPdf.h", 21,
                  typeid(::RooAbsSelfCachedPdf), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooAbsSelfCachedPdf::Dictionary, isa_proxy, 4,
                  sizeof(::RooAbsSelfCachedPdf) );
      instance.SetDelete(&delete_RooAbsSelfCachedPdf);
      instance.SetDeleteArray(&deleteArray_RooAbsSelfCachedPdf);
      instance.SetDestructor(&destruct_RooAbsSelfCachedPdf);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooAbsSelfCachedPdf*)
   {
      return GenerateInitInstanceLocal((::RooAbsSelfCachedPdf*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooAbsSelfCachedPdf*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooCachedPdf(void *p = 0);
   static void *newArray_RooCachedPdf(Long_t size, void *p);
   static void delete_RooCachedPdf(void *p);
   static void deleteArray_RooCachedPdf(void *p);
   static void destruct_RooCachedPdf(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooCachedPdf*)
   {
      ::RooCachedPdf *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooCachedPdf >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooCachedPdf", ::RooCachedPdf::Class_Version(), "RooCachedPdf.h", 20,
                  typeid(::RooCachedPdf), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooCachedPdf::Dictionary, isa_proxy, 4,
                  sizeof(::RooCachedPdf) );
      instance.SetNew(&new_RooCachedPdf);
      instance.SetNewArray(&newArray_RooCachedPdf);
      instance.SetDelete(&delete_RooCachedPdf);
      instance.SetDeleteArray(&deleteArray_RooCachedPdf);
      instance.SetDestructor(&destruct_RooCachedPdf);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooCachedPdf*)
   {
      return GenerateInitInstanceLocal((::RooCachedPdf*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooCachedPdf*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooFFTConvPdf(void *p = 0);
   static void *newArray_RooFFTConvPdf(Long_t size, void *p);
   static void delete_RooFFTConvPdf(void *p);
   static void deleteArray_RooFFTConvPdf(void *p);
   static void destruct_RooFFTConvPdf(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooFFTConvPdf*)
   {
      ::RooFFTConvPdf *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooFFTConvPdf >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooFFTConvPdf", ::RooFFTConvPdf::Class_Version(), "RooFFTConvPdf.h", 25,
                  typeid(::RooFFTConvPdf), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooFFTConvPdf::Dictionary, isa_proxy, 4,
                  sizeof(::RooFFTConvPdf) );
      instance.SetNew(&new_RooFFTConvPdf);
      instance.SetNewArray(&newArray_RooFFTConvPdf);
      instance.SetDelete(&delete_RooFFTConvPdf);
      instance.SetDeleteArray(&deleteArray_RooFFTConvPdf);
      instance.SetDestructor(&destruct_RooFFTConvPdf);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooFFTConvPdf*)
   {
      return GenerateInitInstanceLocal((::RooFFTConvPdf*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooFFTConvPdf*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooDataHistSliceIter(void *p);
   static void deleteArray_RooDataHistSliceIter(void *p);
   static void destruct_RooDataHistSliceIter(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooDataHistSliceIter*)
   {
      ::RooDataHistSliceIter *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooDataHistSliceIter >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooDataHistSliceIter", ::RooDataHistSliceIter::Class_Version(), "RooDataHistSliceIter.h", 26,
                  typeid(::RooDataHistSliceIter), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooDataHistSliceIter::Dictionary, isa_proxy, 4,
                  sizeof(::RooDataHistSliceIter) );
      instance.SetDelete(&delete_RooDataHistSliceIter);
      instance.SetDeleteArray(&deleteArray_RooDataHistSliceIter);
      instance.SetDestructor(&destruct_RooDataHistSliceIter);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooDataHistSliceIter*)
   {
      return GenerateInitInstanceLocal((::RooDataHistSliceIter*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooDataHistSliceIter*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooExtendedTerm(void *p = 0);
   static void *newArray_RooExtendedTerm(Long_t size, void *p);
   static void delete_RooExtendedTerm(void *p);
   static void deleteArray_RooExtendedTerm(void *p);
   static void destruct_RooExtendedTerm(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooExtendedTerm*)
   {
      ::RooExtendedTerm *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooExtendedTerm >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooExtendedTerm", ::RooExtendedTerm::Class_Version(), "RooExtendedTerm.h", 22,
                  typeid(::RooExtendedTerm), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooExtendedTerm::Dictionary, isa_proxy, 4,
                  sizeof(::RooExtendedTerm) );
      instance.SetNew(&new_RooExtendedTerm);
      instance.SetNewArray(&newArray_RooExtendedTerm);
      instance.SetDelete(&delete_RooExtendedTerm);
      instance.SetDeleteArray(&deleteArray_RooExtendedTerm);
      instance.SetDestructor(&destruct_RooExtendedTerm);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooExtendedTerm*)
   {
      return GenerateInitInstanceLocal((::RooExtendedTerm*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooExtendedTerm*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static TClass *RooSentinel_Dictionary();
   static void RooSentinel_TClassManip(TClass*);
   static void delete_RooSentinel(void *p);
   static void deleteArray_RooSentinel(void *p);
   static void destruct_RooSentinel(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooSentinel*)
   {
      ::RooSentinel *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::RooSentinel));
      static ::ROOT::TGenericClassInfo 
         instance("RooSentinel", "RooSentinel.h", 21,
                  typeid(::RooSentinel), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &RooSentinel_Dictionary, isa_proxy, 4,
                  sizeof(::RooSentinel) );
      instance.SetDelete(&delete_RooSentinel);
      instance.SetDeleteArray(&deleteArray_RooSentinel);
      instance.SetDestructor(&destruct_RooSentinel);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooSentinel*)
   {
      return GenerateInitInstanceLocal((::RooSentinel*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooSentinel*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *RooSentinel_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::RooSentinel*)0x0)->GetClass();
      RooSentinel_TClassManip(theClass);
   return theClass;
   }

   static void RooSentinel_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static void *new_RooParamBinning(void *p = 0);
   static void *newArray_RooParamBinning(Long_t size, void *p);
   static void delete_RooParamBinning(void *p);
   static void deleteArray_RooParamBinning(void *p);
   static void destruct_RooParamBinning(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooParamBinning*)
   {
      ::RooParamBinning *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooParamBinning >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooParamBinning", ::RooParamBinning::Class_Version(), "RooParamBinning.h", 25,
                  typeid(::RooParamBinning), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooParamBinning::Dictionary, isa_proxy, 4,
                  sizeof(::RooParamBinning) );
      instance.SetNew(&new_RooParamBinning);
      instance.SetNewArray(&newArray_RooParamBinning);
      instance.SetDelete(&delete_RooParamBinning);
      instance.SetDeleteArray(&deleteArray_RooParamBinning);
      instance.SetDestructor(&destruct_RooParamBinning);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooParamBinning*)
   {
      return GenerateInitInstanceLocal((::RooParamBinning*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooParamBinning*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooConstraintSum(void *p = 0);
   static void *newArray_RooConstraintSum(Long_t size, void *p);
   static void delete_RooConstraintSum(void *p);
   static void deleteArray_RooConstraintSum(void *p);
   static void destruct_RooConstraintSum(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooConstraintSum*)
   {
      ::RooConstraintSum *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooConstraintSum >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooConstraintSum", ::RooConstraintSum::Class_Version(), "RooConstraintSum.h", 27,
                  typeid(::RooConstraintSum), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooConstraintSum::Dictionary, isa_proxy, 4,
                  sizeof(::RooConstraintSum) );
      instance.SetNew(&new_RooConstraintSum);
      instance.SetNewArray(&newArray_RooConstraintSum);
      instance.SetDelete(&delete_RooConstraintSum);
      instance.SetDeleteArray(&deleteArray_RooConstraintSum);
      instance.SetDestructor(&destruct_RooConstraintSum);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooConstraintSum*)
   {
      return GenerateInitInstanceLocal((::RooConstraintSum*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooConstraintSum*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooRecursiveFraction(void *p = 0);
   static void *newArray_RooRecursiveFraction(Long_t size, void *p);
   static void delete_RooRecursiveFraction(void *p);
   static void deleteArray_RooRecursiveFraction(void *p);
   static void destruct_RooRecursiveFraction(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooRecursiveFraction*)
   {
      ::RooRecursiveFraction *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooRecursiveFraction >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooRecursiveFraction", ::RooRecursiveFraction::Class_Version(), "RooRecursiveFraction.h", 25,
                  typeid(::RooRecursiveFraction), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooRecursiveFraction::Dictionary, isa_proxy, 4,
                  sizeof(::RooRecursiveFraction) );
      instance.SetNew(&new_RooRecursiveFraction);
      instance.SetNewArray(&newArray_RooRecursiveFraction);
      instance.SetDelete(&delete_RooRecursiveFraction);
      instance.SetDeleteArray(&deleteArray_RooRecursiveFraction);
      instance.SetDestructor(&destruct_RooRecursiveFraction);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooRecursiveFraction*)
   {
      return GenerateInitInstanceLocal((::RooRecursiveFraction*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooRecursiveFraction*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooDataWeightedAverage(void *p = 0);
   static void *newArray_RooDataWeightedAverage(Long_t size, void *p);
   static void delete_RooDataWeightedAverage(void *p);
   static void deleteArray_RooDataWeightedAverage(void *p);
   static void destruct_RooDataWeightedAverage(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooDataWeightedAverage*)
   {
      ::RooDataWeightedAverage *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooDataWeightedAverage >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooDataWeightedAverage", ::RooDataWeightedAverage::Class_Version(), "RooDataWeightedAverage.h", 22,
                  typeid(::RooDataWeightedAverage), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooDataWeightedAverage::Dictionary, isa_proxy, 4,
                  sizeof(::RooDataWeightedAverage) );
      instance.SetNew(&new_RooDataWeightedAverage);
      instance.SetNewArray(&newArray_RooDataWeightedAverage);
      instance.SetDelete(&delete_RooDataWeightedAverage);
      instance.SetDeleteArray(&deleteArray_RooDataWeightedAverage);
      instance.SetDestructor(&destruct_RooDataWeightedAverage);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooDataWeightedAverage*)
   {
      return GenerateInitInstanceLocal((::RooDataWeightedAverage*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooDataWeightedAverage*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooSimWSTool(void *p);
   static void deleteArray_RooSimWSTool(void *p);
   static void destruct_RooSimWSTool(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooSimWSTool*)
   {
      ::RooSimWSTool *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooSimWSTool >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooSimWSTool", ::RooSimWSTool::Class_Version(), "RooSimWSTool.h", 36,
                  typeid(::RooSimWSTool), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooSimWSTool::Dictionary, isa_proxy, 4,
                  sizeof(::RooSimWSTool) );
      instance.SetDelete(&delete_RooSimWSTool);
      instance.SetDeleteArray(&deleteArray_RooSimWSTool);
      instance.SetDestructor(&destruct_RooSimWSTool);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooSimWSTool*)
   {
      return GenerateInitInstanceLocal((::RooSimWSTool*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooSimWSTool*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooSimWSToolcLcLSplitRule(void *p = 0);
   static void *newArray_RooSimWSToolcLcLSplitRule(Long_t size, void *p);
   static void delete_RooSimWSToolcLcLSplitRule(void *p);
   static void deleteArray_RooSimWSToolcLcLSplitRule(void *p);
   static void destruct_RooSimWSToolcLcLSplitRule(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooSimWSTool::SplitRule*)
   {
      ::RooSimWSTool::SplitRule *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooSimWSTool::SplitRule >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooSimWSTool::SplitRule", ::RooSimWSTool::SplitRule::Class_Version(), "RooSimWSTool.h", 79,
                  typeid(::RooSimWSTool::SplitRule), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooSimWSTool::SplitRule::Dictionary, isa_proxy, 4,
                  sizeof(::RooSimWSTool::SplitRule) );
      instance.SetNew(&new_RooSimWSToolcLcLSplitRule);
      instance.SetNewArray(&newArray_RooSimWSToolcLcLSplitRule);
      instance.SetDelete(&delete_RooSimWSToolcLcLSplitRule);
      instance.SetDeleteArray(&deleteArray_RooSimWSToolcLcLSplitRule);
      instance.SetDestructor(&destruct_RooSimWSToolcLcLSplitRule);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooSimWSTool::SplitRule*)
   {
      return GenerateInitInstanceLocal((::RooSimWSTool::SplitRule*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooSimWSTool::SplitRule*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooSimWSToolcLcLBuildConfig(void *p);
   static void deleteArray_RooSimWSToolcLcLBuildConfig(void *p);
   static void destruct_RooSimWSToolcLcLBuildConfig(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooSimWSTool::BuildConfig*)
   {
      ::RooSimWSTool::BuildConfig *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooSimWSTool::BuildConfig >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooSimWSTool::BuildConfig", ::RooSimWSTool::BuildConfig::Class_Version(), "RooSimWSTool.h", 101,
                  typeid(::RooSimWSTool::BuildConfig), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooSimWSTool::BuildConfig::Dictionary, isa_proxy, 4,
                  sizeof(::RooSimWSTool::BuildConfig) );
      instance.SetDelete(&delete_RooSimWSToolcLcLBuildConfig);
      instance.SetDeleteArray(&deleteArray_RooSimWSToolcLcLBuildConfig);
      instance.SetDestructor(&destruct_RooSimWSToolcLcLBuildConfig);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooSimWSTool::BuildConfig*)
   {
      return GenerateInitInstanceLocal((::RooSimWSTool::BuildConfig*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooSimWSTool::BuildConfig*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooSimWSToolcLcLMultiBuildConfig(void *p);
   static void deleteArray_RooSimWSToolcLcLMultiBuildConfig(void *p);
   static void destruct_RooSimWSToolcLcLMultiBuildConfig(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooSimWSTool::MultiBuildConfig*)
   {
      ::RooSimWSTool::MultiBuildConfig *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooSimWSTool::MultiBuildConfig >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooSimWSTool::MultiBuildConfig", ::RooSimWSTool::MultiBuildConfig::Class_Version(), "RooSimWSTool.h", 128,
                  typeid(::RooSimWSTool::MultiBuildConfig), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooSimWSTool::MultiBuildConfig::Dictionary, isa_proxy, 4,
                  sizeof(::RooSimWSTool::MultiBuildConfig) );
      instance.SetDelete(&delete_RooSimWSToolcLcLMultiBuildConfig);
      instance.SetDeleteArray(&deleteArray_RooSimWSToolcLcLMultiBuildConfig);
      instance.SetDestructor(&destruct_RooSimWSToolcLcLMultiBuildConfig);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooSimWSTool::MultiBuildConfig*)
   {
      return GenerateInitInstanceLocal((::RooSimWSTool::MultiBuildConfig*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooSimWSTool::MultiBuildConfig*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooSimWSToolcLcLObjSplitRule(void *p = 0);
   static void *newArray_RooSimWSToolcLcLObjSplitRule(Long_t size, void *p);
   static void delete_RooSimWSToolcLcLObjSplitRule(void *p);
   static void deleteArray_RooSimWSToolcLcLObjSplitRule(void *p);
   static void destruct_RooSimWSToolcLcLObjSplitRule(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooSimWSTool::ObjSplitRule*)
   {
      ::RooSimWSTool::ObjSplitRule *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooSimWSTool::ObjSplitRule >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooSimWSTool::ObjSplitRule", ::RooSimWSTool::ObjSplitRule::Class_Version(), "RooSimWSTool.h", 150,
                  typeid(::RooSimWSTool::ObjSplitRule), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooSimWSTool::ObjSplitRule::Dictionary, isa_proxy, 4,
                  sizeof(::RooSimWSTool::ObjSplitRule) );
      instance.SetNew(&new_RooSimWSToolcLcLObjSplitRule);
      instance.SetNewArray(&newArray_RooSimWSToolcLcLObjSplitRule);
      instance.SetDelete(&delete_RooSimWSToolcLcLObjSplitRule);
      instance.SetDeleteArray(&deleteArray_RooSimWSToolcLcLObjSplitRule);
      instance.SetDestructor(&destruct_RooSimWSToolcLcLObjSplitRule);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooSimWSTool::ObjSplitRule*)
   {
      return GenerateInitInstanceLocal((::RooSimWSTool::ObjSplitRule*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooSimWSTool::ObjSplitRule*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooSimWSToolcLcLObjBuildConfig(void *p = 0);
   static void *newArray_RooSimWSToolcLcLObjBuildConfig(Long_t size, void *p);
   static void delete_RooSimWSToolcLcLObjBuildConfig(void *p);
   static void deleteArray_RooSimWSToolcLcLObjBuildConfig(void *p);
   static void destruct_RooSimWSToolcLcLObjBuildConfig(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooSimWSTool::ObjBuildConfig*)
   {
      ::RooSimWSTool::ObjBuildConfig *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooSimWSTool::ObjBuildConfig >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooSimWSTool::ObjBuildConfig", ::RooSimWSTool::ObjBuildConfig::Class_Version(), "RooSimWSTool.h", 164,
                  typeid(::RooSimWSTool::ObjBuildConfig), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooSimWSTool::ObjBuildConfig::Dictionary, isa_proxy, 4,
                  sizeof(::RooSimWSTool::ObjBuildConfig) );
      instance.SetNew(&new_RooSimWSToolcLcLObjBuildConfig);
      instance.SetNewArray(&newArray_RooSimWSToolcLcLObjBuildConfig);
      instance.SetDelete(&delete_RooSimWSToolcLcLObjBuildConfig);
      instance.SetDeleteArray(&deleteArray_RooSimWSToolcLcLObjBuildConfig);
      instance.SetDestructor(&destruct_RooSimWSToolcLcLObjBuildConfig);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooSimWSTool::ObjBuildConfig*)
   {
      return GenerateInitInstanceLocal((::RooSimWSTool::ObjBuildConfig*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooSimWSTool::ObjBuildConfig*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooFracRemainder(void *p = 0);
   static void *newArray_RooFracRemainder(Long_t size, void *p);
   static void delete_RooFracRemainder(void *p);
   static void deleteArray_RooFracRemainder(void *p);
   static void destruct_RooFracRemainder(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooFracRemainder*)
   {
      ::RooFracRemainder *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooFracRemainder >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooFracRemainder", ::RooFracRemainder::Class_Version(), "RooFracRemainder.h", 25,
                  typeid(::RooFracRemainder), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooFracRemainder::Dictionary, isa_proxy, 4,
                  sizeof(::RooFracRemainder) );
      instance.SetNew(&new_RooFracRemainder);
      instance.SetNewArray(&newArray_RooFracRemainder);
      instance.SetDelete(&delete_RooFracRemainder);
      instance.SetDeleteArray(&deleteArray_RooFracRemainder);
      instance.SetDestructor(&destruct_RooFracRemainder);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooFracRemainder*)
   {
      return GenerateInitInstanceLocal((::RooFracRemainder*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooFracRemainder*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooHistFunc(void *p = 0);
   static void *newArray_RooHistFunc(Long_t size, void *p);
   static void delete_RooHistFunc(void *p);
   static void deleteArray_RooHistFunc(void *p);
   static void destruct_RooHistFunc(void *p);
   static void streamer_RooHistFunc(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooHistFunc*)
   {
      ::RooHistFunc *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooHistFunc >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooHistFunc", ::RooHistFunc::Class_Version(), "RooHistFunc.h", 29,
                  typeid(::RooHistFunc), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooHistFunc::Dictionary, isa_proxy, 17,
                  sizeof(::RooHistFunc) );
      instance.SetNew(&new_RooHistFunc);
      instance.SetNewArray(&newArray_RooHistFunc);
      instance.SetDelete(&delete_RooHistFunc);
      instance.SetDeleteArray(&deleteArray_RooHistFunc);
      instance.SetDestructor(&destruct_RooHistFunc);
      instance.SetStreamerFunc(&streamer_RooHistFunc);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooHistFunc*)
   {
      return GenerateInitInstanceLocal((::RooHistFunc*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooHistFunc*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooAbsCachedReal(void *p);
   static void deleteArray_RooAbsCachedReal(void *p);
   static void destruct_RooAbsCachedReal(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooAbsCachedReal*)
   {
      ::RooAbsCachedReal *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooAbsCachedReal >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooAbsCachedReal", ::RooAbsCachedReal::Class_Version(), "RooAbsCachedReal.h", 24,
                  typeid(::RooAbsCachedReal), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooAbsCachedReal::Dictionary, isa_proxy, 4,
                  sizeof(::RooAbsCachedReal) );
      instance.SetDelete(&delete_RooAbsCachedReal);
      instance.SetDeleteArray(&deleteArray_RooAbsCachedReal);
      instance.SetDestructor(&destruct_RooAbsCachedReal);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooAbsCachedReal*)
   {
      return GenerateInitInstanceLocal((::RooAbsCachedReal*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooAbsCachedReal*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooAbsSelfCachedReal(void *p);
   static void deleteArray_RooAbsSelfCachedReal(void *p);
   static void destruct_RooAbsSelfCachedReal(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooAbsSelfCachedReal*)
   {
      ::RooAbsSelfCachedReal *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooAbsSelfCachedReal >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooAbsSelfCachedReal", ::RooAbsSelfCachedReal::Class_Version(), "RooAbsSelfCachedReal.h", 21,
                  typeid(::RooAbsSelfCachedReal), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooAbsSelfCachedReal::Dictionary, isa_proxy, 4,
                  sizeof(::RooAbsSelfCachedReal) );
      instance.SetDelete(&delete_RooAbsSelfCachedReal);
      instance.SetDeleteArray(&deleteArray_RooAbsSelfCachedReal);
      instance.SetDestructor(&destruct_RooAbsSelfCachedReal);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooAbsSelfCachedReal*)
   {
      return GenerateInitInstanceLocal((::RooAbsSelfCachedReal*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooAbsSelfCachedReal*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooCachedReal(void *p = 0);
   static void *newArray_RooCachedReal(Long_t size, void *p);
   static void delete_RooCachedReal(void *p);
   static void deleteArray_RooCachedReal(void *p);
   static void destruct_RooCachedReal(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooCachedReal*)
   {
      ::RooCachedReal *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooCachedReal >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooCachedReal", ::RooCachedReal::Class_Version(), "RooCachedReal.h", 20,
                  typeid(::RooCachedReal), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooCachedReal::Dictionary, isa_proxy, 4,
                  sizeof(::RooCachedReal) );
      instance.SetNew(&new_RooCachedReal);
      instance.SetNewArray(&newArray_RooCachedReal);
      instance.SetDelete(&delete_RooCachedReal);
      instance.SetDeleteArray(&deleteArray_RooCachedReal);
      instance.SetDestructor(&destruct_RooCachedReal);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooCachedReal*)
   {
      return GenerateInitInstanceLocal((::RooCachedReal*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooCachedReal*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooNumRunningInt(void *p);
   static void deleteArray_RooNumRunningInt(void *p);
   static void destruct_RooNumRunningInt(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooNumRunningInt*)
   {
      ::RooNumRunningInt *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooNumRunningInt >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooNumRunningInt", ::RooNumRunningInt::Class_Version(), "RooNumRunningInt.h", 20,
                  typeid(::RooNumRunningInt), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooNumRunningInt::Dictionary, isa_proxy, 4,
                  sizeof(::RooNumRunningInt) );
      instance.SetDelete(&delete_RooNumRunningInt);
      instance.SetDeleteArray(&deleteArray_RooNumRunningInt);
      instance.SetDestructor(&destruct_RooNumRunningInt);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooNumRunningInt*)
   {
      return GenerateInitInstanceLocal((::RooNumRunningInt*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooNumRunningInt*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooNumCdf(void *p);
   static void deleteArray_RooNumCdf(void *p);
   static void destruct_RooNumCdf(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooNumCdf*)
   {
      ::RooNumCdf *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooNumCdf >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooNumCdf", ::RooNumCdf::Class_Version(), "RooNumCdf.h", 17,
                  typeid(::RooNumCdf), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooNumCdf::Dictionary, isa_proxy, 4,
                  sizeof(::RooNumCdf) );
      instance.SetDelete(&delete_RooNumCdf);
      instance.SetDeleteArray(&deleteArray_RooNumCdf);
      instance.SetDestructor(&destruct_RooNumCdf);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooNumCdf*)
   {
      return GenerateInitInstanceLocal((::RooNumCdf*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooNumCdf*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooChangeTracker(void *p = 0);
   static void *newArray_RooChangeTracker(Long_t size, void *p);
   static void delete_RooChangeTracker(void *p);
   static void deleteArray_RooChangeTracker(void *p);
   static void destruct_RooChangeTracker(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooChangeTracker*)
   {
      ::RooChangeTracker *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooChangeTracker >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooChangeTracker", ::RooChangeTracker::Class_Version(), "RooChangeTracker.h", 26,
                  typeid(::RooChangeTracker), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooChangeTracker::Dictionary, isa_proxy, 4,
                  sizeof(::RooChangeTracker) );
      instance.SetNew(&new_RooChangeTracker);
      instance.SetNewArray(&newArray_RooChangeTracker);
      instance.SetDelete(&delete_RooChangeTracker);
      instance.SetDeleteArray(&deleteArray_RooChangeTracker);
      instance.SetDestructor(&destruct_RooChangeTracker);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooChangeTracker*)
   {
      return GenerateInitInstanceLocal((::RooChangeTracker*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooChangeTracker*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooBinningCategory(void *p = 0);
   static void *newArray_RooBinningCategory(Long_t size, void *p);
   static void delete_RooBinningCategory(void *p);
   static void deleteArray_RooBinningCategory(void *p);
   static void destruct_RooBinningCategory(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooBinningCategory*)
   {
      ::RooBinningCategory *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooBinningCategory >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooBinningCategory", ::RooBinningCategory::Class_Version(), "RooBinningCategory.h", 24,
                  typeid(::RooBinningCategory), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooBinningCategory::Dictionary, isa_proxy, 4,
                  sizeof(::RooBinningCategory) );
      instance.SetNew(&new_RooBinningCategory);
      instance.SetNewArray(&newArray_RooBinningCategory);
      instance.SetDelete(&delete_RooBinningCategory);
      instance.SetDeleteArray(&deleteArray_RooBinningCategory);
      instance.SetDestructor(&destruct_RooBinningCategory);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooBinningCategory*)
   {
      return GenerateInitInstanceLocal((::RooBinningCategory*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooBinningCategory*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooTFoamBinding(void *p);
   static void deleteArray_RooTFoamBinding(void *p);
   static void destruct_RooTFoamBinding(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooTFoamBinding*)
   {
      ::RooTFoamBinding *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooTFoamBinding >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooTFoamBinding", ::RooTFoamBinding::Class_Version(), "RooTFoamBinding.h", 24,
                  typeid(::RooTFoamBinding), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooTFoamBinding::Dictionary, isa_proxy, 4,
                  sizeof(::RooTFoamBinding) );
      instance.SetDelete(&delete_RooTFoamBinding);
      instance.SetDeleteArray(&deleteArray_RooTFoamBinding);
      instance.SetDestructor(&destruct_RooTFoamBinding);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooTFoamBinding*)
   {
      return GenerateInitInstanceLocal((::RooTFoamBinding*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooTFoamBinding*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooFunctor(void *p);
   static void deleteArray_RooFunctor(void *p);
   static void destruct_RooFunctor(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooFunctor*)
   {
      ::RooFunctor *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooFunctor >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooFunctor", ::RooFunctor::Class_Version(), "RooFunctor.h", 25,
                  typeid(::RooFunctor), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooFunctor::Dictionary, isa_proxy, 4,
                  sizeof(::RooFunctor) );
      instance.SetDelete(&delete_RooFunctor);
      instance.SetDeleteArray(&deleteArray_RooFunctor);
      instance.SetDestructor(&destruct_RooFunctor);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooFunctor*)
   {
      return GenerateInitInstanceLocal((::RooFunctor*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooFunctor*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooDerivative(void *p = 0);
   static void *newArray_RooDerivative(Long_t size, void *p);
   static void delete_RooDerivative(void *p);
   static void deleteArray_RooDerivative(void *p);
   static void destruct_RooDerivative(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooDerivative*)
   {
      ::RooDerivative *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooDerivative >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooDerivative", ::RooDerivative::Class_Version(), "RooDerivative.h", 31,
                  typeid(::RooDerivative), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooDerivative::Dictionary, isa_proxy, 4,
                  sizeof(::RooDerivative) );
      instance.SetNew(&new_RooDerivative);
      instance.SetNewArray(&newArray_RooDerivative);
      instance.SetDelete(&delete_RooDerivative);
      instance.SetDeleteArray(&deleteArray_RooDerivative);
      instance.SetDestructor(&destruct_RooDerivative);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooDerivative*)
   {
      return GenerateInitInstanceLocal((::RooDerivative*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooDerivative*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooGenFunction(void *p);
   static void deleteArray_RooGenFunction(void *p);
   static void destruct_RooGenFunction(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooGenFunction*)
   {
      ::RooGenFunction *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooGenFunction >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooGenFunction", ::RooGenFunction::Class_Version(), "RooGenFunction.h", 22,
                  typeid(::RooGenFunction), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooGenFunction::Dictionary, isa_proxy, 4,
                  sizeof(::RooGenFunction) );
      instance.SetDelete(&delete_RooGenFunction);
      instance.SetDeleteArray(&deleteArray_RooGenFunction);
      instance.SetDestructor(&destruct_RooGenFunction);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooGenFunction*)
   {
      return GenerateInitInstanceLocal((::RooGenFunction*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooGenFunction*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooMultiGenFunction(void *p);
   static void deleteArray_RooMultiGenFunction(void *p);
   static void destruct_RooMultiGenFunction(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooMultiGenFunction*)
   {
      ::RooMultiGenFunction *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooMultiGenFunction >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooMultiGenFunction", ::RooMultiGenFunction::Class_Version(), "RooMultiGenFunction.h", 27,
                  typeid(::RooMultiGenFunction), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooMultiGenFunction::Dictionary, isa_proxy, 4,
                  sizeof(::RooMultiGenFunction) );
      instance.SetDelete(&delete_RooMultiGenFunction);
      instance.SetDeleteArray(&deleteArray_RooMultiGenFunction);
      instance.SetDestructor(&destruct_RooMultiGenFunction);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooMultiGenFunction*)
   {
      return GenerateInitInstanceLocal((::RooMultiGenFunction*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooMultiGenFunction*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooAdaptiveIntegratorND(void *p = 0);
   static void *newArray_RooAdaptiveIntegratorND(Long_t size, void *p);
   static void delete_RooAdaptiveIntegratorND(void *p);
   static void deleteArray_RooAdaptiveIntegratorND(void *p);
   static void destruct_RooAdaptiveIntegratorND(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooAdaptiveIntegratorND*)
   {
      ::RooAdaptiveIntegratorND *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooAdaptiveIntegratorND >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooAdaptiveIntegratorND", ::RooAdaptiveIntegratorND::Class_Version(), "RooAdaptiveIntegratorND.h", 26,
                  typeid(::RooAdaptiveIntegratorND), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooAdaptiveIntegratorND::Dictionary, isa_proxy, 4,
                  sizeof(::RooAdaptiveIntegratorND) );
      instance.SetNew(&new_RooAdaptiveIntegratorND);
      instance.SetNewArray(&newArray_RooAdaptiveIntegratorND);
      instance.SetDelete(&delete_RooAdaptiveIntegratorND);
      instance.SetDeleteArray(&deleteArray_RooAdaptiveIntegratorND);
      instance.SetDestructor(&destruct_RooAdaptiveIntegratorND);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooAdaptiveIntegratorND*)
   {
      return GenerateInitInstanceLocal((::RooAdaptiveIntegratorND*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooAdaptiveIntegratorND*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooFoamGenerator(void *p = 0);
   static void *newArray_RooFoamGenerator(Long_t size, void *p);
   static void delete_RooFoamGenerator(void *p);
   static void deleteArray_RooFoamGenerator(void *p);
   static void destruct_RooFoamGenerator(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooFoamGenerator*)
   {
      ::RooFoamGenerator *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooFoamGenerator >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooFoamGenerator", ::RooFoamGenerator::Class_Version(), "RooFoamGenerator.h", 31,
                  typeid(::RooFoamGenerator), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooFoamGenerator::Dictionary, isa_proxy, 4,
                  sizeof(::RooFoamGenerator) );
      instance.SetNew(&new_RooFoamGenerator);
      instance.SetNewArray(&newArray_RooFoamGenerator);
      instance.SetDelete(&delete_RooFoamGenerator);
      instance.SetDeleteArray(&deleteArray_RooFoamGenerator);
      instance.SetDestructor(&destruct_RooFoamGenerator);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooFoamGenerator*)
   {
      return GenerateInitInstanceLocal((::RooFoamGenerator*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooFoamGenerator*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooNumGenConfig(void *p = 0);
   static void *newArray_RooNumGenConfig(Long_t size, void *p);
   static void delete_RooNumGenConfig(void *p);
   static void deleteArray_RooNumGenConfig(void *p);
   static void destruct_RooNumGenConfig(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooNumGenConfig*)
   {
      ::RooNumGenConfig *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooNumGenConfig >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooNumGenConfig", ::RooNumGenConfig::Class_Version(), "RooNumGenConfig.h", 25,
                  typeid(::RooNumGenConfig), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooNumGenConfig::Dictionary, isa_proxy, 4,
                  sizeof(::RooNumGenConfig) );
      instance.SetNew(&new_RooNumGenConfig);
      instance.SetNewArray(&newArray_RooNumGenConfig);
      instance.SetDelete(&delete_RooNumGenConfig);
      instance.SetDeleteArray(&deleteArray_RooNumGenConfig);
      instance.SetDestructor(&destruct_RooNumGenConfig);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooNumGenConfig*)
   {
      return GenerateInitInstanceLocal((::RooNumGenConfig*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooNumGenConfig*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooNumGenFactory(void *p);
   static void deleteArray_RooNumGenFactory(void *p);
   static void destruct_RooNumGenFactory(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooNumGenFactory*)
   {
      ::RooNumGenFactory *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooNumGenFactory >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooNumGenFactory", ::RooNumGenFactory::Class_Version(), "RooNumGenFactory.h", 30,
                  typeid(::RooNumGenFactory), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooNumGenFactory::Dictionary, isa_proxy, 4,
                  sizeof(::RooNumGenFactory) );
      instance.SetDelete(&delete_RooNumGenFactory);
      instance.SetDeleteArray(&deleteArray_RooNumGenFactory);
      instance.SetDestructor(&destruct_RooNumGenFactory);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooNumGenFactory*)
   {
      return GenerateInitInstanceLocal((::RooNumGenFactory*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooNumGenFactory*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooMultiVarGaussian(void *p = 0);
   static void *newArray_RooMultiVarGaussian(Long_t size, void *p);
   static void delete_RooMultiVarGaussian(void *p);
   static void deleteArray_RooMultiVarGaussian(void *p);
   static void destruct_RooMultiVarGaussian(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooMultiVarGaussian*)
   {
      ::RooMultiVarGaussian *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooMultiVarGaussian >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooMultiVarGaussian", ::RooMultiVarGaussian::Class_Version(), "RooMultiVarGaussian.h", 31,
                  typeid(::RooMultiVarGaussian), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooMultiVarGaussian::Dictionary, isa_proxy, 4,
                  sizeof(::RooMultiVarGaussian) );
      instance.SetNew(&new_RooMultiVarGaussian);
      instance.SetNewArray(&newArray_RooMultiVarGaussian);
      instance.SetDelete(&delete_RooMultiVarGaussian);
      instance.SetDeleteArray(&deleteArray_RooMultiVarGaussian);
      instance.SetDestructor(&destruct_RooMultiVarGaussian);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooMultiVarGaussian*)
   {
      return GenerateInitInstanceLocal((::RooMultiVarGaussian*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooMultiVarGaussian*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static TClass *RooMultiVarGaussiancLcLAnaIntData_Dictionary();
   static void RooMultiVarGaussiancLcLAnaIntData_TClassManip(TClass*);
   static void *new_RooMultiVarGaussiancLcLAnaIntData(void *p = 0);
   static void *newArray_RooMultiVarGaussiancLcLAnaIntData(Long_t size, void *p);
   static void delete_RooMultiVarGaussiancLcLAnaIntData(void *p);
   static void deleteArray_RooMultiVarGaussiancLcLAnaIntData(void *p);
   static void destruct_RooMultiVarGaussiancLcLAnaIntData(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooMultiVarGaussian::AnaIntData*)
   {
      ::RooMultiVarGaussian::AnaIntData *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::RooMultiVarGaussian::AnaIntData));
      static ::ROOT::TGenericClassInfo 
         instance("RooMultiVarGaussian::AnaIntData", "RooMultiVarGaussian.h", 54,
                  typeid(::RooMultiVarGaussian::AnaIntData), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &RooMultiVarGaussiancLcLAnaIntData_Dictionary, isa_proxy, 4,
                  sizeof(::RooMultiVarGaussian::AnaIntData) );
      instance.SetNew(&new_RooMultiVarGaussiancLcLAnaIntData);
      instance.SetNewArray(&newArray_RooMultiVarGaussiancLcLAnaIntData);
      instance.SetDelete(&delete_RooMultiVarGaussiancLcLAnaIntData);
      instance.SetDeleteArray(&deleteArray_RooMultiVarGaussiancLcLAnaIntData);
      instance.SetDestructor(&destruct_RooMultiVarGaussiancLcLAnaIntData);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooMultiVarGaussian::AnaIntData*)
   {
      return GenerateInitInstanceLocal((::RooMultiVarGaussian::AnaIntData*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooMultiVarGaussian::AnaIntData*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *RooMultiVarGaussiancLcLAnaIntData_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::RooMultiVarGaussian::AnaIntData*)0x0)->GetClass();
      RooMultiVarGaussiancLcLAnaIntData_TClassManip(theClass);
   return theClass;
   }

   static void RooMultiVarGaussiancLcLAnaIntData_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *RooMultiVarGaussiancLcLGenData_Dictionary();
   static void RooMultiVarGaussiancLcLGenData_TClassManip(TClass*);
   static void *new_RooMultiVarGaussiancLcLGenData(void *p = 0);
   static void *newArray_RooMultiVarGaussiancLcLGenData(Long_t size, void *p);
   static void delete_RooMultiVarGaussiancLcLGenData(void *p);
   static void deleteArray_RooMultiVarGaussiancLcLGenData(void *p);
   static void destruct_RooMultiVarGaussiancLcLGenData(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooMultiVarGaussian::GenData*)
   {
      ::RooMultiVarGaussian::GenData *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::RooMultiVarGaussian::GenData));
      static ::ROOT::TGenericClassInfo 
         instance("RooMultiVarGaussian::GenData", "RooMultiVarGaussian.h", 62,
                  typeid(::RooMultiVarGaussian::GenData), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &RooMultiVarGaussiancLcLGenData_Dictionary, isa_proxy, 4,
                  sizeof(::RooMultiVarGaussian::GenData) );
      instance.SetNew(&new_RooMultiVarGaussiancLcLGenData);
      instance.SetNewArray(&newArray_RooMultiVarGaussiancLcLGenData);
      instance.SetDelete(&delete_RooMultiVarGaussiancLcLGenData);
      instance.SetDeleteArray(&deleteArray_RooMultiVarGaussiancLcLGenData);
      instance.SetDestructor(&destruct_RooMultiVarGaussiancLcLGenData);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooMultiVarGaussian::GenData*)
   {
      return GenerateInitInstanceLocal((::RooMultiVarGaussian::GenData*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooMultiVarGaussian::GenData*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *RooMultiVarGaussiancLcLGenData_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::RooMultiVarGaussian::GenData*)0x0)->GetClass();
      RooMultiVarGaussiancLcLGenData_TClassManip(theClass);
   return theClass;
   }

   static void RooMultiVarGaussiancLcLGenData_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static void *new_RooXYChi2Var(void *p = 0);
   static void *newArray_RooXYChi2Var(Long_t size, void *p);
   static void delete_RooXYChi2Var(void *p);
   static void deleteArray_RooXYChi2Var(void *p);
   static void destruct_RooXYChi2Var(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooXYChi2Var*)
   {
      ::RooXYChi2Var *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooXYChi2Var >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooXYChi2Var", ::RooXYChi2Var::Class_Version(), "RooXYChi2Var.h", 29,
                  typeid(::RooXYChi2Var), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooXYChi2Var::Dictionary, isa_proxy, 4,
                  sizeof(::RooXYChi2Var) );
      instance.SetNew(&new_RooXYChi2Var);
      instance.SetNewArray(&newArray_RooXYChi2Var);
      instance.SetDelete(&delete_RooXYChi2Var);
      instance.SetDeleteArray(&deleteArray_RooXYChi2Var);
      instance.SetDestructor(&destruct_RooXYChi2Var);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooXYChi2Var*)
   {
      return GenerateInitInstanceLocal((::RooXYChi2Var*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooXYChi2Var*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooAbsDataStore(void *p);
   static void deleteArray_RooAbsDataStore(void *p);
   static void destruct_RooAbsDataStore(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooAbsDataStore*)
   {
      ::RooAbsDataStore *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooAbsDataStore >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooAbsDataStore", ::RooAbsDataStore::Class_Version(), "RooAbsDataStore.h", 31,
                  typeid(::RooAbsDataStore), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooAbsDataStore::Dictionary, isa_proxy, 4,
                  sizeof(::RooAbsDataStore) );
      instance.SetDelete(&delete_RooAbsDataStore);
      instance.SetDeleteArray(&deleteArray_RooAbsDataStore);
      instance.SetDestructor(&destruct_RooAbsDataStore);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooAbsDataStore*)
   {
      return GenerateInitInstanceLocal((::RooAbsDataStore*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooAbsDataStore*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooTreeDataStore(void *p = 0);
   static void *newArray_RooTreeDataStore(Long_t size, void *p);
   static void delete_RooTreeDataStore(void *p);
   static void deleteArray_RooTreeDataStore(void *p);
   static void destruct_RooTreeDataStore(void *p);
   static void streamer_RooTreeDataStore(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooTreeDataStore*)
   {
      ::RooTreeDataStore *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooTreeDataStore >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooTreeDataStore", ::RooTreeDataStore::Class_Version(), "RooTreeDataStore.h", 29,
                  typeid(::RooTreeDataStore), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooTreeDataStore::Dictionary, isa_proxy, 17,
                  sizeof(::RooTreeDataStore) );
      instance.SetNew(&new_RooTreeDataStore);
      instance.SetNewArray(&newArray_RooTreeDataStore);
      instance.SetDelete(&delete_RooTreeDataStore);
      instance.SetDeleteArray(&deleteArray_RooTreeDataStore);
      instance.SetDestructor(&destruct_RooTreeDataStore);
      instance.SetStreamerFunc(&streamer_RooTreeDataStore);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooTreeDataStore*)
   {
      return GenerateInitInstanceLocal((::RooTreeDataStore*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooTreeDataStore*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooTreeData(void *p);
   static void deleteArray_RooTreeData(void *p);
   static void destruct_RooTreeData(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooTreeData*)
   {
      ::RooTreeData *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooTreeData >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooTreeData", ::RooTreeData::Class_Version(), "RooTreeData.h", 25,
                  typeid(::RooTreeData), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooTreeData::Dictionary, isa_proxy, 4,
                  sizeof(::RooTreeData) );
      instance.SetDelete(&delete_RooTreeData);
      instance.SetDeleteArray(&deleteArray_RooTreeData);
      instance.SetDestructor(&destruct_RooTreeData);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooTreeData*)
   {
      return GenerateInitInstanceLocal((::RooTreeData*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooTreeData*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static TClass *RooMinimizerFcn_Dictionary();
   static void RooMinimizerFcn_TClassManip(TClass*);
   static void delete_RooMinimizerFcn(void *p);
   static void deleteArray_RooMinimizerFcn(void *p);
   static void destruct_RooMinimizerFcn(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooMinimizerFcn*)
   {
      ::RooMinimizerFcn *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::RooMinimizerFcn));
      static ::ROOT::TGenericClassInfo 
         instance("RooMinimizerFcn", "RooMinimizerFcn.h", 33,
                  typeid(::RooMinimizerFcn), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &RooMinimizerFcn_Dictionary, isa_proxy, 4,
                  sizeof(::RooMinimizerFcn) );
      instance.SetDelete(&delete_RooMinimizerFcn);
      instance.SetDeleteArray(&deleteArray_RooMinimizerFcn);
      instance.SetDestructor(&destruct_RooMinimizerFcn);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooMinimizerFcn*)
   {
      return GenerateInitInstanceLocal((::RooMinimizerFcn*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooMinimizerFcn*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *RooMinimizerFcn_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::RooMinimizerFcn*)0x0)->GetClass();
      RooMinimizerFcn_TClassManip(theClass);
   return theClass;
   }

   static void RooMinimizerFcn_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static void delete_RooMinimizer(void *p);
   static void deleteArray_RooMinimizer(void *p);
   static void destruct_RooMinimizer(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooMinimizer*)
   {
      ::RooMinimizer *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooMinimizer >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooMinimizer", ::RooMinimizer::Class_Version(), "RooMinimizer.h", 38,
                  typeid(::RooMinimizer), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooMinimizer::Dictionary, isa_proxy, 4,
                  sizeof(::RooMinimizer) );
      instance.SetDelete(&delete_RooMinimizer);
      instance.SetDeleteArray(&deleteArray_RooMinimizer);
      instance.SetDestructor(&destruct_RooMinimizer);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooMinimizer*)
   {
      return GenerateInitInstanceLocal((::RooMinimizer*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooMinimizer*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooAbsMoment(void *p);
   static void deleteArray_RooAbsMoment(void *p);
   static void destruct_RooAbsMoment(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooAbsMoment*)
   {
      ::RooAbsMoment *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooAbsMoment >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooAbsMoment", ::RooAbsMoment::Class_Version(), "RooAbsMoment.h", 27,
                  typeid(::RooAbsMoment), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooAbsMoment::Dictionary, isa_proxy, 4,
                  sizeof(::RooAbsMoment) );
      instance.SetDelete(&delete_RooAbsMoment);
      instance.SetDeleteArray(&deleteArray_RooAbsMoment);
      instance.SetDestructor(&destruct_RooAbsMoment);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooAbsMoment*)
   {
      return GenerateInitInstanceLocal((::RooAbsMoment*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooAbsMoment*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooMoment(void *p = 0);
   static void *newArray_RooMoment(Long_t size, void *p);
   static void delete_RooMoment(void *p);
   static void deleteArray_RooMoment(void *p);
   static void destruct_RooMoment(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooMoment*)
   {
      ::RooMoment *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooMoment >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooMoment", ::RooMoment::Class_Version(), "RooMoment.h", 27,
                  typeid(::RooMoment), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooMoment::Dictionary, isa_proxy, 4,
                  sizeof(::RooMoment) );
      instance.SetNew(&new_RooMoment);
      instance.SetNewArray(&newArray_RooMoment);
      instance.SetDelete(&delete_RooMoment);
      instance.SetDeleteArray(&deleteArray_RooMoment);
      instance.SetDestructor(&destruct_RooMoment);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooMoment*)
   {
      return GenerateInitInstanceLocal((::RooMoment*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooMoment*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooStudyPackage(void *p = 0);
   static void *newArray_RooStudyPackage(Long_t size, void *p);
   static void delete_RooStudyPackage(void *p);
   static void deleteArray_RooStudyPackage(void *p);
   static void destruct_RooStudyPackage(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooStudyPackage*)
   {
      ::RooStudyPackage *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooStudyPackage >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooStudyPackage", ::RooStudyPackage::Class_Version(), "RooStudyPackage.h", 31,
                  typeid(::RooStudyPackage), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooStudyPackage::Dictionary, isa_proxy, 4,
                  sizeof(::RooStudyPackage) );
      instance.SetNew(&new_RooStudyPackage);
      instance.SetNewArray(&newArray_RooStudyPackage);
      instance.SetDelete(&delete_RooStudyPackage);
      instance.SetDeleteArray(&deleteArray_RooStudyPackage);
      instance.SetDestructor(&destruct_RooStudyPackage);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooStudyPackage*)
   {
      return GenerateInitInstanceLocal((::RooStudyPackage*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooStudyPackage*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooStudyManager(void *p);
   static void deleteArray_RooStudyManager(void *p);
   static void destruct_RooStudyManager(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooStudyManager*)
   {
      ::RooStudyManager *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooStudyManager >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooStudyManager", ::RooStudyManager::Class_Version(), "RooStudyManager.h", 33,
                  typeid(::RooStudyManager), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooStudyManager::Dictionary, isa_proxy, 4,
                  sizeof(::RooStudyManager) );
      instance.SetDelete(&delete_RooStudyManager);
      instance.SetDeleteArray(&deleteArray_RooStudyManager);
      instance.SetDestructor(&destruct_RooStudyManager);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooStudyManager*)
   {
      return GenerateInitInstanceLocal((::RooStudyManager*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooStudyManager*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooAbsStudy(void *p);
   static void deleteArray_RooAbsStudy(void *p);
   static void destruct_RooAbsStudy(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooAbsStudy*)
   {
      ::RooAbsStudy *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooAbsStudy >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooAbsStudy", ::RooAbsStudy::Class_Version(), "RooAbsStudy.h", 33,
                  typeid(::RooAbsStudy), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooAbsStudy::Dictionary, isa_proxy, 4,
                  sizeof(::RooAbsStudy) );
      instance.SetDelete(&delete_RooAbsStudy);
      instance.SetDeleteArray(&deleteArray_RooAbsStudy);
      instance.SetDestructor(&destruct_RooAbsStudy);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooAbsStudy*)
   {
      return GenerateInitInstanceLocal((::RooAbsStudy*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooAbsStudy*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooGenFitStudy(void *p = 0);
   static void *newArray_RooGenFitStudy(Long_t size, void *p);
   static void delete_RooGenFitStudy(void *p);
   static void deleteArray_RooGenFitStudy(void *p);
   static void destruct_RooGenFitStudy(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooGenFitStudy*)
   {
      ::RooGenFitStudy *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooGenFitStudy >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooGenFitStudy", ::RooGenFitStudy::Class_Version(), "RooGenFitStudy.h", 35,
                  typeid(::RooGenFitStudy), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooGenFitStudy::Dictionary, isa_proxy, 4,
                  sizeof(::RooGenFitStudy) );
      instance.SetNew(&new_RooGenFitStudy);
      instance.SetNewArray(&newArray_RooGenFitStudy);
      instance.SetDelete(&delete_RooGenFitStudy);
      instance.SetDeleteArray(&deleteArray_RooGenFitStudy);
      instance.SetDestructor(&destruct_RooGenFitStudy);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooGenFitStudy*)
   {
      return GenerateInitInstanceLocal((::RooGenFitStudy*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooGenFitStudy*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooProofDriverSelector(void *p = 0);
   static void *newArray_RooProofDriverSelector(Long_t size, void *p);
   static void delete_RooProofDriverSelector(void *p);
   static void deleteArray_RooProofDriverSelector(void *p);
   static void destruct_RooProofDriverSelector(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooProofDriverSelector*)
   {
      ::RooProofDriverSelector *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooProofDriverSelector >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooProofDriverSelector", ::RooProofDriverSelector::Class_Version(), "RooProofDriverSelector.h", 18,
                  typeid(::RooProofDriverSelector), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooProofDriverSelector::Dictionary, isa_proxy, 4,
                  sizeof(::RooProofDriverSelector) );
      instance.SetNew(&new_RooProofDriverSelector);
      instance.SetNewArray(&newArray_RooProofDriverSelector);
      instance.SetDelete(&delete_RooProofDriverSelector);
      instance.SetDeleteArray(&deleteArray_RooProofDriverSelector);
      instance.SetDestructor(&destruct_RooProofDriverSelector);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooProofDriverSelector*)
   {
      return GenerateInitInstanceLocal((::RooProofDriverSelector*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooProofDriverSelector*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooCompositeDataStore(void *p = 0);
   static void *newArray_RooCompositeDataStore(Long_t size, void *p);
   static void delete_RooCompositeDataStore(void *p);
   static void deleteArray_RooCompositeDataStore(void *p);
   static void destruct_RooCompositeDataStore(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooCompositeDataStore*)
   {
      ::RooCompositeDataStore *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooCompositeDataStore >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooCompositeDataStore", ::RooCompositeDataStore::Class_Version(), "RooCompositeDataStore.h", 31,
                  typeid(::RooCompositeDataStore), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooCompositeDataStore::Dictionary, isa_proxy, 4,
                  sizeof(::RooCompositeDataStore) );
      instance.SetNew(&new_RooCompositeDataStore);
      instance.SetNewArray(&newArray_RooCompositeDataStore);
      instance.SetDelete(&delete_RooCompositeDataStore);
      instance.SetDeleteArray(&deleteArray_RooCompositeDataStore);
      instance.SetDestructor(&destruct_RooCompositeDataStore);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooCompositeDataStore*)
   {
      return GenerateInitInstanceLocal((::RooCompositeDataStore*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooCompositeDataStore*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooRangeBoolean(void *p = 0);
   static void *newArray_RooRangeBoolean(Long_t size, void *p);
   static void delete_RooRangeBoolean(void *p);
   static void deleteArray_RooRangeBoolean(void *p);
   static void destruct_RooRangeBoolean(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooRangeBoolean*)
   {
      ::RooRangeBoolean *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooRangeBoolean >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooRangeBoolean", ::RooRangeBoolean::Class_Version(), "RooRangeBoolean.h", 27,
                  typeid(::RooRangeBoolean), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooRangeBoolean::Dictionary, isa_proxy, 4,
                  sizeof(::RooRangeBoolean) );
      instance.SetNew(&new_RooRangeBoolean);
      instance.SetNewArray(&newArray_RooRangeBoolean);
      instance.SetDelete(&delete_RooRangeBoolean);
      instance.SetDeleteArray(&deleteArray_RooRangeBoolean);
      instance.SetDestructor(&destruct_RooRangeBoolean);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooRangeBoolean*)
   {
      return GenerateInitInstanceLocal((::RooRangeBoolean*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooRangeBoolean*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooVectorDataStore(void *p = 0);
   static void *newArray_RooVectorDataStore(Long_t size, void *p);
   static void delete_RooVectorDataStore(void *p);
   static void deleteArray_RooVectorDataStore(void *p);
   static void destruct_RooVectorDataStore(void *p);
   static void streamer_RooVectorDataStore(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooVectorDataStore*)
   {
      ::RooVectorDataStore *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooVectorDataStore >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooVectorDataStore", ::RooVectorDataStore::Class_Version(), "RooVectorDataStore.h", 38,
                  typeid(::RooVectorDataStore), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooVectorDataStore::Dictionary, isa_proxy, 17,
                  sizeof(::RooVectorDataStore) );
      instance.SetNew(&new_RooVectorDataStore);
      instance.SetNewArray(&newArray_RooVectorDataStore);
      instance.SetDelete(&delete_RooVectorDataStore);
      instance.SetDeleteArray(&deleteArray_RooVectorDataStore);
      instance.SetDestructor(&destruct_RooVectorDataStore);
      instance.SetStreamerFunc(&streamer_RooVectorDataStore);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooVectorDataStore*)
   {
      return GenerateInitInstanceLocal((::RooVectorDataStore*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooVectorDataStore*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooVectorDataStorecLcLRealVector(void *p = 0);
   static void *newArray_RooVectorDataStorecLcLRealVector(Long_t size, void *p);
   static void delete_RooVectorDataStorecLcLRealVector(void *p);
   static void deleteArray_RooVectorDataStorecLcLRealVector(void *p);
   static void destruct_RooVectorDataStorecLcLRealVector(void *p);
   static void streamer_RooVectorDataStorecLcLRealVector(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooVectorDataStore::RealVector*)
   {
      ::RooVectorDataStore::RealVector *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooVectorDataStore::RealVector >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooVectorDataStore::RealVector", ::RooVectorDataStore::RealVector::Class_Version(), "RooVectorDataStore.h", 135,
                  typeid(::RooVectorDataStore::RealVector), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooVectorDataStore::RealVector::Dictionary, isa_proxy, 17,
                  sizeof(::RooVectorDataStore::RealVector) );
      instance.SetNew(&new_RooVectorDataStorecLcLRealVector);
      instance.SetNewArray(&newArray_RooVectorDataStorecLcLRealVector);
      instance.SetDelete(&delete_RooVectorDataStorecLcLRealVector);
      instance.SetDeleteArray(&deleteArray_RooVectorDataStorecLcLRealVector);
      instance.SetDestructor(&destruct_RooVectorDataStorecLcLRealVector);
      instance.SetStreamerFunc(&streamer_RooVectorDataStorecLcLRealVector);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooVectorDataStore::RealVector*)
   {
      return GenerateInitInstanceLocal((::RooVectorDataStore::RealVector*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooVectorDataStore::RealVector*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooVectorDataStorecLcLRealFullVector(void *p = 0);
   static void *newArray_RooVectorDataStorecLcLRealFullVector(Long_t size, void *p);
   static void delete_RooVectorDataStorecLcLRealFullVector(void *p);
   static void deleteArray_RooVectorDataStorecLcLRealFullVector(void *p);
   static void destruct_RooVectorDataStorecLcLRealFullVector(void *p);
   static void streamer_RooVectorDataStorecLcLRealFullVector(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooVectorDataStore::RealFullVector*)
   {
      ::RooVectorDataStore::RealFullVector *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooVectorDataStore::RealFullVector >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooVectorDataStore::RealFullVector", ::RooVectorDataStore::RealFullVector::Class_Version(), "RooVectorDataStore.h", 278,
                  typeid(::RooVectorDataStore::RealFullVector), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooVectorDataStore::RealFullVector::Dictionary, isa_proxy, 17,
                  sizeof(::RooVectorDataStore::RealFullVector) );
      instance.SetNew(&new_RooVectorDataStorecLcLRealFullVector);
      instance.SetNewArray(&newArray_RooVectorDataStorecLcLRealFullVector);
      instance.SetDelete(&delete_RooVectorDataStorecLcLRealFullVector);
      instance.SetDeleteArray(&deleteArray_RooVectorDataStorecLcLRealFullVector);
      instance.SetDestructor(&destruct_RooVectorDataStorecLcLRealFullVector);
      instance.SetStreamerFunc(&streamer_RooVectorDataStorecLcLRealFullVector);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooVectorDataStore::RealFullVector*)
   {
      return GenerateInitInstanceLocal((::RooVectorDataStore::RealFullVector*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooVectorDataStore::RealFullVector*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooVectorDataStorecLcLCatVector(void *p = 0);
   static void *newArray_RooVectorDataStorecLcLCatVector(Long_t size, void *p);
   static void delete_RooVectorDataStorecLcLCatVector(void *p);
   static void deleteArray_RooVectorDataStorecLcLCatVector(void *p);
   static void destruct_RooVectorDataStorecLcLCatVector(void *p);
   static void streamer_RooVectorDataStorecLcLCatVector(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooVectorDataStore::CatVector*)
   {
      ::RooVectorDataStore::CatVector *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooVectorDataStore::CatVector >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooVectorDataStore::CatVector", ::RooVectorDataStore::CatVector::Class_Version(), "RooVectorDataStore.h", 461,
                  typeid(::RooVectorDataStore::CatVector), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooVectorDataStore::CatVector::Dictionary, isa_proxy, 17,
                  sizeof(::RooVectorDataStore::CatVector) );
      instance.SetNew(&new_RooVectorDataStorecLcLCatVector);
      instance.SetNewArray(&newArray_RooVectorDataStorecLcLCatVector);
      instance.SetDelete(&delete_RooVectorDataStorecLcLCatVector);
      instance.SetDeleteArray(&deleteArray_RooVectorDataStorecLcLCatVector);
      instance.SetDestructor(&destruct_RooVectorDataStorecLcLCatVector);
      instance.SetStreamerFunc(&streamer_RooVectorDataStorecLcLCatVector);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooVectorDataStore::CatVector*)
   {
      return GenerateInitInstanceLocal((::RooVectorDataStore::CatVector*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooVectorDataStore::CatVector*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooUnitTest(void *p);
   static void deleteArray_RooUnitTest(void *p);
   static void destruct_RooUnitTest(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooUnitTest*)
   {
      ::RooUnitTest *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooUnitTest >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooUnitTest", ::RooUnitTest::Class_Version(), "RooUnitTest.h", 36,
                  typeid(::RooUnitTest), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooUnitTest::Dictionary, isa_proxy, 4,
                  sizeof(::RooUnitTest) );
      instance.SetDelete(&delete_RooUnitTest);
      instance.SetDeleteArray(&deleteArray_RooUnitTest);
      instance.SetDestructor(&destruct_RooUnitTest);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooUnitTest*)
   {
      return GenerateInitInstanceLocal((::RooUnitTest*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooUnitTest*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooExtendedBinding(void *p = 0);
   static void *newArray_RooExtendedBinding(Long_t size, void *p);
   static void delete_RooExtendedBinding(void *p);
   static void deleteArray_RooExtendedBinding(void *p);
   static void destruct_RooExtendedBinding(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooExtendedBinding*)
   {
      ::RooExtendedBinding *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooExtendedBinding >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooExtendedBinding", ::RooExtendedBinding::Class_Version(), "RooExtendedBinding.h", 16,
                  typeid(::RooExtendedBinding), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooExtendedBinding::Dictionary, isa_proxy, 4,
                  sizeof(::RooExtendedBinding) );
      instance.SetNew(&new_RooExtendedBinding);
      instance.SetNewArray(&newArray_RooExtendedBinding);
      instance.SetDelete(&delete_RooExtendedBinding);
      instance.SetDeleteArray(&deleteArray_RooExtendedBinding);
      instance.SetDestructor(&destruct_RooExtendedBinding);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooExtendedBinding*)
   {
      return GenerateInitInstanceLocal((::RooExtendedBinding*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooExtendedBinding*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooFirstMoment(void *p = 0);
   static void *newArray_RooFirstMoment(Long_t size, void *p);
   static void delete_RooFirstMoment(void *p);
   static void deleteArray_RooFirstMoment(void *p);
   static void destruct_RooFirstMoment(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooFirstMoment*)
   {
      ::RooFirstMoment *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooFirstMoment >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooFirstMoment", ::RooFirstMoment::Class_Version(), "RooFirstMoment.h", 27,
                  typeid(::RooFirstMoment), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooFirstMoment::Dictionary, isa_proxy, 4,
                  sizeof(::RooFirstMoment) );
      instance.SetNew(&new_RooFirstMoment);
      instance.SetNewArray(&newArray_RooFirstMoment);
      instance.SetDelete(&delete_RooFirstMoment);
      instance.SetDeleteArray(&deleteArray_RooFirstMoment);
      instance.SetDestructor(&destruct_RooFirstMoment);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooFirstMoment*)
   {
      return GenerateInitInstanceLocal((::RooFirstMoment*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooFirstMoment*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooSecondMoment(void *p = 0);
   static void *newArray_RooSecondMoment(Long_t size, void *p);
   static void delete_RooSecondMoment(void *p);
   static void deleteArray_RooSecondMoment(void *p);
   static void destruct_RooSecondMoment(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooSecondMoment*)
   {
      ::RooSecondMoment *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooSecondMoment >(0);
      static ::ROOT::TGenericClassInfo 
         instance("RooSecondMoment", ::RooSecondMoment::Class_Version(), "RooSecondMoment.h", 27,
                  typeid(::RooSecondMoment), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooSecondMoment::Dictionary, isa_proxy, 4,
                  sizeof(::RooSecondMoment) );
      instance.SetNew(&new_RooSecondMoment);
      instance.SetNewArray(&newArray_RooSecondMoment);
      instance.SetDelete(&delete_RooSecondMoment);
      instance.SetDeleteArray(&deleteArray_RooSecondMoment);
      instance.SetDestructor(&destruct_RooSecondMoment);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooSecondMoment*)
   {
      return GenerateInitInstanceLocal((::RooSecondMoment*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooSecondMoment*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

//______________________________________________________________________________
atomic_TClass_ptr RooPrintable::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooPrintable::Class_Name()
{
   return "RooPrintable";
}

//______________________________________________________________________________
const char *RooPrintable::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooPrintable*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooPrintable::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooPrintable*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooPrintable::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooPrintable*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooPrintable::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooPrintable*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooLinkedListElem::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooLinkedListElem::Class_Name()
{
   return "RooLinkedListElem";
}

//______________________________________________________________________________
const char *RooLinkedListElem::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooLinkedListElem*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooLinkedListElem::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooLinkedListElem*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooLinkedListElem::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooLinkedListElem*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooLinkedListElem::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooLinkedListElem*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooHashTable::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooHashTable::Class_Name()
{
   return "RooHashTable";
}

//______________________________________________________________________________
const char *RooHashTable::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooHashTable*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooHashTable::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooHashTable*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooHashTable::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooHashTable*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooHashTable::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooHashTable*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooLinkedList::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooLinkedList::Class_Name()
{
   return "RooLinkedList";
}

//______________________________________________________________________________
const char *RooLinkedList::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooLinkedList*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooLinkedList::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooLinkedList*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooLinkedList::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooLinkedList*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooLinkedList::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooLinkedList*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooRefCountList::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooRefCountList::Class_Name()
{
   return "RooRefCountList";
}

//______________________________________________________________________________
const char *RooRefCountList::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooRefCountList*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooRefCountList::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooRefCountList*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooRefCountList::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooRefCountList*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooRefCountList::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooRefCountList*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooAbsCache::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooAbsCache::Class_Name()
{
   return "RooAbsCache";
}

//______________________________________________________________________________
const char *RooAbsCache::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsCache*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooAbsCache::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsCache*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooAbsCache::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsCache*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooAbsCache::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsCache*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooLinkedListIter::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooLinkedListIter::Class_Name()
{
   return "RooLinkedListIter";
}

//______________________________________________________________________________
const char *RooLinkedListIter::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooLinkedListIter*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooLinkedListIter::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooLinkedListIter*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooLinkedListIter::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooLinkedListIter*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooLinkedListIter::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooLinkedListIter*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooNameReg::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooNameReg::Class_Name()
{
   return "RooNameReg";
}

//______________________________________________________________________________
const char *RooNameReg::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooNameReg*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooNameReg::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooNameReg*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooNameReg::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooNameReg*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooNameReg::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooNameReg*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooRefArray::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooRefArray::Class_Name()
{
   return "RooRefArray";
}

//______________________________________________________________________________
const char *RooRefArray::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooRefArray*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooRefArray::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooRefArray*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooRefArray::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooRefArray*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooRefArray::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooRefArray*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooAbsArg::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooAbsArg::Class_Name()
{
   return "RooAbsArg";
}

//______________________________________________________________________________
const char *RooAbsArg::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsArg*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooAbsArg::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsArg*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooAbsArg::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsArg*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooAbsArg::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsArg*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooCatType::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooCatType::Class_Name()
{
   return "RooCatType";
}

//______________________________________________________________________________
const char *RooCatType::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooCatType*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooCatType::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooCatType*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooCatType::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooCatType*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooCatType::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooCatType*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooAbsCategory::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooAbsCategory::Class_Name()
{
   return "RooAbsCategory";
}

//______________________________________________________________________________
const char *RooAbsCategory::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsCategory*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooAbsCategory::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsCategory*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooAbsCategory::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsCategory*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooAbsCategory::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsCategory*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooTable::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooTable::Class_Name()
{
   return "RooTable";
}

//______________________________________________________________________________
const char *RooTable::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooTable*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooTable::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooTable*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooTable::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooTable*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooTable::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooTable*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr Roo1DTable::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *Roo1DTable::Class_Name()
{
   return "Roo1DTable";
}

//______________________________________________________________________________
const char *Roo1DTable::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::Roo1DTable*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int Roo1DTable::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::Roo1DTable*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *Roo1DTable::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::Roo1DTable*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *Roo1DTable::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::Roo1DTable*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooAbsBinning::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooAbsBinning::Class_Name()
{
   return "RooAbsBinning";
}

//______________________________________________________________________________
const char *RooAbsBinning::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsBinning*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooAbsBinning::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsBinning*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooAbsBinning::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsBinning*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooAbsBinning::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsBinning*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooAbsLValue::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooAbsLValue::Class_Name()
{
   return "RooAbsLValue";
}

//______________________________________________________________________________
const char *RooAbsLValue::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsLValue*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooAbsLValue::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsLValue*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooAbsLValue::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsLValue*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooAbsLValue::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsLValue*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooAbsCategoryLValue::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooAbsCategoryLValue::Class_Name()
{
   return "RooAbsCategoryLValue";
}

//______________________________________________________________________________
const char *RooAbsCategoryLValue::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsCategoryLValue*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooAbsCategoryLValue::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsCategoryLValue*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooAbsCategoryLValue::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsCategoryLValue*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooAbsCategoryLValue::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsCategoryLValue*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooCmdArg::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooCmdArg::Class_Name()
{
   return "RooCmdArg";
}

//______________________________________________________________________________
const char *RooCmdArg::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooCmdArg*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooCmdArg::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooCmdArg*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooCmdArg::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooCmdArg*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooCmdArg::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooCmdArg*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooAbsCollection::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooAbsCollection::Class_Name()
{
   return "RooAbsCollection";
}

//______________________________________________________________________________
const char *RooAbsCollection::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsCollection*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooAbsCollection::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsCollection*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooAbsCollection::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsCollection*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooAbsCollection::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsCollection*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooArgSet::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooArgSet::Class_Name()
{
   return "RooArgSet";
}

//______________________________________________________________________________
const char *RooArgSet::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooArgSet*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooArgSet::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooArgSet*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooArgSet::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooArgSet*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooArgSet::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooArgSet*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooPlotable::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooPlotable::Class_Name()
{
   return "RooPlotable";
}

//______________________________________________________________________________
const char *RooPlotable::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooPlotable*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooPlotable::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooPlotable*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooPlotable::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooPlotable*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooPlotable::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooPlotable*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooCurve::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooCurve::Class_Name()
{
   return "RooCurve";
}

//______________________________________________________________________________
const char *RooCurve::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooCurve*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooCurve::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooCurve*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooCurve::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooCurve*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooCurve::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooCurve*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooArgList::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooArgList::Class_Name()
{
   return "RooArgList";
}

//______________________________________________________________________________
const char *RooArgList::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooArgList*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooArgList::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooArgList*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooArgList::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooArgList*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooArgList::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooArgList*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooAbsReal::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooAbsReal::Class_Name()
{
   return "RooAbsReal";
}

//______________________________________________________________________________
const char *RooAbsReal::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsReal*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooAbsReal::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsReal*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooAbsReal::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsReal*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooAbsReal::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsReal*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooFormula::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooFormula::Class_Name()
{
   return "RooFormula";
}

//______________________________________________________________________________
const char *RooFormula::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooFormula*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooFormula::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooFormula*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooFormula::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooFormula*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooFormula::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooFormula*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooAbsProxy::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooAbsProxy::Class_Name()
{
   return "RooAbsProxy";
}

//______________________________________________________________________________
const char *RooAbsProxy::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsProxy*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooAbsProxy::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsProxy*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooAbsProxy::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsProxy*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooAbsProxy::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsProxy*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooListProxy::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooListProxy::Class_Name()
{
   return "RooListProxy";
}

//______________________________________________________________________________
const char *RooListProxy::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooListProxy*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooListProxy::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooListProxy*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooListProxy::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooListProxy*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooListProxy::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooListProxy*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooTrace::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooTrace::Class_Name()
{
   return "RooTrace";
}

//______________________________________________________________________________
const char *RooTrace::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooTrace*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooTrace::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooTrace*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooTrace::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooTrace*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooTrace::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooTrace*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooFormulaVar::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooFormulaVar::Class_Name()
{
   return "RooFormulaVar";
}

//______________________________________________________________________________
const char *RooFormulaVar::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooFormulaVar*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooFormulaVar::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooFormulaVar*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooFormulaVar::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooFormulaVar*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooFormulaVar::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooFormulaVar*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooAbsData::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooAbsData::Class_Name()
{
   return "RooAbsData";
}

//______________________________________________________________________________
const char *RooAbsData::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsData*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooAbsData::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsData*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooAbsData::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsData*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooAbsData::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsData*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooAbsFunc::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooAbsFunc::Class_Name()
{
   return "RooAbsFunc";
}

//______________________________________________________________________________
const char *RooAbsFunc::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsFunc*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooAbsFunc::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsFunc*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooAbsFunc::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsFunc*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooAbsFunc::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsFunc*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooNameSet::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooNameSet::Class_Name()
{
   return "RooNameSet";
}

//______________________________________________________________________________
const char *RooNameSet::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooNameSet*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooNameSet::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooNameSet*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooNameSet::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooNameSet*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooNameSet::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooNameSet*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooNormSetCache::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooNormSetCache::Class_Name()
{
   return "RooNormSetCache";
}

//______________________________________________________________________________
const char *RooNormSetCache::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooNormSetCache*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooNormSetCache::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooNormSetCache*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooNormSetCache::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooNormSetCache*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooNormSetCache::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooNormSetCache*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooAbsCacheElement::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooAbsCacheElement::Class_Name()
{
   return "RooAbsCacheElement";
}

//______________________________________________________________________________
const char *RooAbsCacheElement::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsCacheElement*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooAbsCacheElement::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsCacheElement*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooAbsCacheElement::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsCacheElement*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooAbsCacheElement::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsCacheElement*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooMsgService::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooMsgService::Class_Name()
{
   return "RooMsgService";
}

//______________________________________________________________________________
const char *RooMsgService::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooMsgService*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooMsgService::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooMsgService*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooMsgService::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooMsgService*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooMsgService::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooMsgService*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
template <> atomic_TClass_ptr RooCacheManager<RooAbsCacheElement>::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
template <> const char *RooCacheManager<RooAbsCacheElement>::Class_Name()
{
   return "RooCacheManager<RooAbsCacheElement>";
}

//______________________________________________________________________________
template <> const char *RooCacheManager<RooAbsCacheElement>::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooCacheManager<RooAbsCacheElement>*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
template <> int RooCacheManager<RooAbsCacheElement>::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooCacheManager<RooAbsCacheElement>*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
template <> TClass *RooCacheManager<RooAbsCacheElement>::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooCacheManager<RooAbsCacheElement>*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
template <> TClass *RooCacheManager<RooAbsCacheElement>::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooCacheManager<RooAbsCacheElement>*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
template <> atomic_TClass_ptr RooCacheManager<vector<double> >::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
template <> const char *RooCacheManager<vector<double> >::Class_Name()
{
   return "RooCacheManager<vector<double> >";
}

//______________________________________________________________________________
template <> const char *RooCacheManager<vector<double> >::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooCacheManager<vector<double> >*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
template <> int RooCacheManager<vector<double> >::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooCacheManager<vector<double> >*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
template <> TClass *RooCacheManager<vector<double> >::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooCacheManager<vector<double> >*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
template <> TClass *RooCacheManager<vector<double> >::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooCacheManager<vector<double> >*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooObjCacheManager::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooObjCacheManager::Class_Name()
{
   return "RooObjCacheManager";
}

//______________________________________________________________________________
const char *RooObjCacheManager::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooObjCacheManager*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooObjCacheManager::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooObjCacheManager*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooObjCacheManager::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooObjCacheManager*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooObjCacheManager::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooObjCacheManager*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooAbsPdf::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooAbsPdf::Class_Name()
{
   return "RooAbsPdf";
}

//______________________________________________________________________________
const char *RooAbsPdf::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsPdf*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooAbsPdf::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsPdf*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooAbsPdf::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsPdf*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooAbsPdf::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsPdf*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooAbsPdf::GenSpec::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooAbsPdf::GenSpec::Class_Name()
{
   return "RooAbsPdf::GenSpec";
}

//______________________________________________________________________________
const char *RooAbsPdf::GenSpec::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsPdf::GenSpec*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooAbsPdf::GenSpec::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsPdf::GenSpec*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooAbsPdf::GenSpec::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsPdf::GenSpec*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooAbsPdf::GenSpec::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsPdf::GenSpec*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooAbsGenContext::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooAbsGenContext::Class_Name()
{
   return "RooAbsGenContext";
}

//______________________________________________________________________________
const char *RooAbsGenContext::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsGenContext*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooAbsGenContext::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsGenContext*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooAbsGenContext::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsGenContext*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooAbsGenContext::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsGenContext*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooSetProxy::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooSetProxy::Class_Name()
{
   return "RooSetProxy";
}

//______________________________________________________________________________
const char *RooSetProxy::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooSetProxy*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooSetProxy::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooSetProxy*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooSetProxy::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooSetProxy*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooSetProxy::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooSetProxy*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooArgProxy::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooArgProxy::Class_Name()
{
   return "RooArgProxy";
}

//______________________________________________________________________________
const char *RooArgProxy::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooArgProxy*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooArgProxy::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooArgProxy*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooArgProxy::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooArgProxy*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooArgProxy::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooArgProxy*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooNumber::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooNumber::Class_Name()
{
   return "RooNumber";
}

//______________________________________________________________________________
const char *RooNumber::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooNumber*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooNumber::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooNumber*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooNumber::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooNumber*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooNumber::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooNumber*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooAbsRealLValue::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooAbsRealLValue::Class_Name()
{
   return "RooAbsRealLValue";
}

//______________________________________________________________________________
const char *RooAbsRealLValue::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsRealLValue*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooAbsRealLValue::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsRealLValue*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooAbsRealLValue::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsRealLValue*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooAbsRealLValue::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsRealLValue*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooRealProxy::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooRealProxy::Class_Name()
{
   return "RooRealProxy";
}

//______________________________________________________________________________
const char *RooRealProxy::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooRealProxy*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooRealProxy::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooRealProxy*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooRealProxy::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooRealProxy*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooRealProxy::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooRealProxy*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooAbsTestStatistic::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooAbsTestStatistic::Class_Name()
{
   return "RooAbsTestStatistic";
}

//______________________________________________________________________________
const char *RooAbsTestStatistic::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsTestStatistic*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooAbsTestStatistic::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsTestStatistic*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooAbsTestStatistic::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsTestStatistic*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooAbsTestStatistic::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsTestStatistic*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooCategoryProxy::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooCategoryProxy::Class_Name()
{
   return "RooCategoryProxy";
}

//______________________________________________________________________________
const char *RooCategoryProxy::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooCategoryProxy*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooCategoryProxy::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooCategoryProxy*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooCategoryProxy::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooCategoryProxy*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooCategoryProxy::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooCategoryProxy*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooAbsHiddenReal::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooAbsHiddenReal::Class_Name()
{
   return "RooAbsHiddenReal";
}

//______________________________________________________________________________
const char *RooAbsHiddenReal::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsHiddenReal*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooAbsHiddenReal::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsHiddenReal*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooAbsHiddenReal::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsHiddenReal*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooAbsHiddenReal::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsHiddenReal*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooSharedProperties::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooSharedProperties::Class_Name()
{
   return "RooSharedProperties";
}

//______________________________________________________________________________
const char *RooSharedProperties::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooSharedProperties*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooSharedProperties::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooSharedProperties*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooSharedProperties::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooSharedProperties*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooSharedProperties::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooSharedProperties*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooSharedPropertiesList::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooSharedPropertiesList::Class_Name()
{
   return "RooSharedPropertiesList";
}

//______________________________________________________________________________
const char *RooSharedPropertiesList::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooSharedPropertiesList*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooSharedPropertiesList::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooSharedPropertiesList*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooSharedPropertiesList::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooSharedPropertiesList*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooSharedPropertiesList::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooSharedPropertiesList*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooCategorySharedProperties::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooCategorySharedProperties::Class_Name()
{
   return "RooCategorySharedProperties";
}

//______________________________________________________________________________
const char *RooCategorySharedProperties::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooCategorySharedProperties*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooCategorySharedProperties::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooCategorySharedProperties*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooCategorySharedProperties::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooCategorySharedProperties*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooCategorySharedProperties::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooCategorySharedProperties*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooCategory::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooCategory::Class_Name()
{
   return "RooCategory";
}

//______________________________________________________________________________
const char *RooCategory::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooCategory*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooCategory::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooCategory*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooCategory::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooCategory*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooCategory::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooCategory*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooNumIntConfig::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooNumIntConfig::Class_Name()
{
   return "RooNumIntConfig";
}

//______________________________________________________________________________
const char *RooNumIntConfig::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooNumIntConfig*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooNumIntConfig::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooNumIntConfig*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooNumIntConfig::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooNumIntConfig*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooNumIntConfig::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooNumIntConfig*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooAbsIntegrator::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooAbsIntegrator::Class_Name()
{
   return "RooAbsIntegrator";
}

//______________________________________________________________________________
const char *RooAbsIntegrator::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsIntegrator*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooAbsIntegrator::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsIntegrator*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooAbsIntegrator::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsIntegrator*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooAbsIntegrator::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsIntegrator*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooMCStudy::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooMCStudy::Class_Name()
{
   return "RooMCStudy";
}

//______________________________________________________________________________
const char *RooMCStudy::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooMCStudy*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooMCStudy::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooMCStudy*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooMCStudy::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooMCStudy*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooMCStudy::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooMCStudy*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooAbsMCStudyModule::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooAbsMCStudyModule::Class_Name()
{
   return "RooAbsMCStudyModule";
}

//______________________________________________________________________________
const char *RooAbsMCStudyModule::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsMCStudyModule*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooAbsMCStudyModule::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsMCStudyModule*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooAbsMCStudyModule::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsMCStudyModule*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooAbsMCStudyModule::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsMCStudyModule*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooAbsOptTestStatistic::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooAbsOptTestStatistic::Class_Name()
{
   return "RooAbsOptTestStatistic";
}

//______________________________________________________________________________
const char *RooAbsOptTestStatistic::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsOptTestStatistic*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooAbsOptTestStatistic::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsOptTestStatistic*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooAbsOptTestStatistic::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsOptTestStatistic*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooAbsOptTestStatistic::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsOptTestStatistic*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooAbsRootFinder::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooAbsRootFinder::Class_Name()
{
   return "RooAbsRootFinder";
}

//______________________________________________________________________________
const char *RooAbsRootFinder::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsRootFinder*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooAbsRootFinder::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsRootFinder*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooAbsRootFinder::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsRootFinder*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooAbsRootFinder::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsRootFinder*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooAbsString::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooAbsString::Class_Name()
{
   return "RooAbsString";
}

//______________________________________________________________________________
const char *RooAbsString::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsString*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooAbsString::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsString*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooAbsString::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsString*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooAbsString::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsString*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooAbsNumGenerator::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooAbsNumGenerator::Class_Name()
{
   return "RooAbsNumGenerator";
}

//______________________________________________________________________________
const char *RooAbsNumGenerator::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsNumGenerator*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooAbsNumGenerator::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsNumGenerator*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooAbsNumGenerator::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsNumGenerator*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooAbsNumGenerator::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsNumGenerator*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooAcceptReject::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooAcceptReject::Class_Name()
{
   return "RooAcceptReject";
}

//______________________________________________________________________________
const char *RooAcceptReject::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAcceptReject*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooAcceptReject::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAcceptReject*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooAcceptReject::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAcceptReject*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooAcceptReject::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAcceptReject*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooAdaptiveGaussKronrodIntegrator1D::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooAdaptiveGaussKronrodIntegrator1D::Class_Name()
{
   return "RooAdaptiveGaussKronrodIntegrator1D";
}

//______________________________________________________________________________
const char *RooAdaptiveGaussKronrodIntegrator1D::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAdaptiveGaussKronrodIntegrator1D*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooAdaptiveGaussKronrodIntegrator1D::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAdaptiveGaussKronrodIntegrator1D*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooAdaptiveGaussKronrodIntegrator1D::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAdaptiveGaussKronrodIntegrator1D*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooAdaptiveGaussKronrodIntegrator1D::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAdaptiveGaussKronrodIntegrator1D*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooAICRegistry::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooAICRegistry::Class_Name()
{
   return "RooAICRegistry";
}

//______________________________________________________________________________
const char *RooAICRegistry::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAICRegistry*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooAICRegistry::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAICRegistry*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooAICRegistry::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAICRegistry*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooAICRegistry::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAICRegistry*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooAddPdf::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooAddPdf::Class_Name()
{
   return "RooAddPdf";
}

//______________________________________________________________________________
const char *RooAddPdf::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAddPdf*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooAddPdf::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAddPdf*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooAddPdf::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAddPdf*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooAddPdf::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAddPdf*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooUniformBinning::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooUniformBinning::Class_Name()
{
   return "RooUniformBinning";
}

//______________________________________________________________________________
const char *RooUniformBinning::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooUniformBinning*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooUniformBinning::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooUniformBinning*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooUniformBinning::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooUniformBinning*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooUniformBinning::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooUniformBinning*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooRealVarSharedProperties::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooRealVarSharedProperties::Class_Name()
{
   return "RooRealVarSharedProperties";
}

//______________________________________________________________________________
const char *RooRealVarSharedProperties::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooRealVarSharedProperties*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooRealVarSharedProperties::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooRealVarSharedProperties*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooRealVarSharedProperties::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooRealVarSharedProperties*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooRealVarSharedProperties::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooRealVarSharedProperties*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooRealVar::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooRealVar::Class_Name()
{
   return "RooRealVar";
}

//______________________________________________________________________________
const char *RooRealVar::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooRealVar*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooRealVar::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooRealVar*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooRealVar::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooRealVar*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooRealVar::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooRealVar*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooResolutionModel::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooResolutionModel::Class_Name()
{
   return "RooResolutionModel";
}

//______________________________________________________________________________
const char *RooResolutionModel::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooResolutionModel*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooResolutionModel::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooResolutionModel*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooResolutionModel::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooResolutionModel*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooResolutionModel::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooResolutionModel*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooAddModel::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooAddModel::Class_Name()
{
   return "RooAddModel";
}

//______________________________________________________________________________
const char *RooAddModel::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAddModel*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooAddModel::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAddModel*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooAddModel::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAddModel*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooAddModel::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAddModel*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooAddGenContext::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooAddGenContext::Class_Name()
{
   return "RooAddGenContext";
}

//______________________________________________________________________________
const char *RooAddGenContext::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAddGenContext*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooAddGenContext::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAddGenContext*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooAddGenContext::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAddGenContext*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooAddGenContext::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAddGenContext*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooAddition::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooAddition::Class_Name()
{
   return "RooAddition";
}

//______________________________________________________________________________
const char *RooAddition::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAddition*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooAddition::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAddition*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooAddition::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAddition*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooAddition::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAddition*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooDouble::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooDouble::Class_Name()
{
   return "RooDouble";
}

//______________________________________________________________________________
const char *RooDouble::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooDouble*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooDouble::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooDouble*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooDouble::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooDouble*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooDouble::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooDouble*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooBinning::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooBinning::Class_Name()
{
   return "RooBinning";
}

//______________________________________________________________________________
const char *RooBinning::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooBinning*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooBinning::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooBinning*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooBinning::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooBinning*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooBinning::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooBinning*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooBinnedGenContext::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooBinnedGenContext::Class_Name()
{
   return "RooBinnedGenContext";
}

//______________________________________________________________________________
const char *RooBinnedGenContext::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooBinnedGenContext*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooBinnedGenContext::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooBinnedGenContext*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooBinnedGenContext::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooBinnedGenContext*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooBinnedGenContext::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooBinnedGenContext*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooBrentRootFinder::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooBrentRootFinder::Class_Name()
{
   return "RooBrentRootFinder";
}

//______________________________________________________________________________
const char *RooBrentRootFinder::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooBrentRootFinder*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooBrentRootFinder::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooBrentRootFinder*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooBrentRootFinder::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooBrentRootFinder*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooBrentRootFinder::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooBrentRootFinder*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooDirItem::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooDirItem::Class_Name()
{
   return "RooDirItem";
}

//______________________________________________________________________________
const char *RooDirItem::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooDirItem*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooDirItem::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooDirItem*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooDirItem::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooDirItem*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooDirItem::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooDirItem*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooDataHist::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooDataHist::Class_Name()
{
   return "RooDataHist";
}

//______________________________________________________________________________
const char *RooDataHist::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooDataHist*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooDataHist::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooDataHist*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooDataHist::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooDataHist*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooDataHist::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooDataHist*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooChi2Var::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooChi2Var::Class_Name()
{
   return "RooChi2Var";
}

//______________________________________________________________________________
const char *RooChi2Var::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooChi2Var*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooChi2Var::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooChi2Var*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooChi2Var::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooChi2Var*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooChi2Var::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooChi2Var*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooFactoryWSTool::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooFactoryWSTool::Class_Name()
{
   return "RooFactoryWSTool";
}

//______________________________________________________________________________
const char *RooFactoryWSTool::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooFactoryWSTool*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooFactoryWSTool::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooFactoryWSTool*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooFactoryWSTool::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooFactoryWSTool*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooFactoryWSTool::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooFactoryWSTool*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooClassFactory::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooClassFactory::Class_Name()
{
   return "RooClassFactory";
}

//______________________________________________________________________________
const char *RooClassFactory::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooClassFactory*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooClassFactory::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooClassFactory*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooClassFactory::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooClassFactory*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooClassFactory::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooClassFactory*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooCmdConfig::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooCmdConfig::Class_Name()
{
   return "RooCmdConfig";
}

//______________________________________________________________________________
const char *RooCmdConfig::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooCmdConfig*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooCmdConfig::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooCmdConfig*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooCmdConfig::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooCmdConfig*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooCmdConfig::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooCmdConfig*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooConstVar::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooConstVar::Class_Name()
{
   return "RooConstVar";
}

//______________________________________________________________________________
const char *RooConstVar::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooConstVar*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooConstVar::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooConstVar*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooConstVar::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooConstVar*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooConstVar::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooConstVar*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooConvCoefVar::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooConvCoefVar::Class_Name()
{
   return "RooConvCoefVar";
}

//______________________________________________________________________________
const char *RooConvCoefVar::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooConvCoefVar*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooConvCoefVar::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooConvCoefVar*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooConvCoefVar::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooConvCoefVar*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooConvCoefVar::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooConvCoefVar*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooConvGenContext::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooConvGenContext::Class_Name()
{
   return "RooConvGenContext";
}

//______________________________________________________________________________
const char *RooConvGenContext::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooConvGenContext*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooConvGenContext::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooConvGenContext*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooConvGenContext::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooConvGenContext*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooConvGenContext::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooConvGenContext*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooConvIntegrandBinding::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooConvIntegrandBinding::Class_Name()
{
   return "RooConvIntegrandBinding";
}

//______________________________________________________________________________
const char *RooConvIntegrandBinding::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooConvIntegrandBinding*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooConvIntegrandBinding::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooConvIntegrandBinding*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooConvIntegrandBinding::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooConvIntegrandBinding*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooConvIntegrandBinding::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooConvIntegrandBinding*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooCustomizer::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooCustomizer::Class_Name()
{
   return "RooCustomizer";
}

//______________________________________________________________________________
const char *RooCustomizer::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooCustomizer*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooCustomizer::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooCustomizer*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooCustomizer::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooCustomizer*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooCustomizer::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooCustomizer*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooRealBinding::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooRealBinding::Class_Name()
{
   return "RooRealBinding";
}

//______________________________________________________________________________
const char *RooRealBinding::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooRealBinding*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooRealBinding::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooRealBinding*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooRealBinding::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooRealBinding*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooRealBinding::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooRealBinding*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooDataProjBinding::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooDataProjBinding::Class_Name()
{
   return "RooDataProjBinding";
}

//______________________________________________________________________________
const char *RooDataProjBinding::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooDataProjBinding*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooDataProjBinding::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooDataProjBinding*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooDataProjBinding::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooDataProjBinding*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooDataProjBinding::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooDataProjBinding*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooDataSet::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooDataSet::Class_Name()
{
   return "RooDataSet";
}

//______________________________________________________________________________
const char *RooDataSet::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooDataSet*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooDataSet::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooDataSet*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooDataSet::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooDataSet*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooDataSet::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooDataSet*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooDLLSignificanceMCSModule::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooDLLSignificanceMCSModule::Class_Name()
{
   return "RooDLLSignificanceMCSModule";
}

//______________________________________________________________________________
const char *RooDLLSignificanceMCSModule::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooDLLSignificanceMCSModule*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooDLLSignificanceMCSModule::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooDLLSignificanceMCSModule*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooDLLSignificanceMCSModule::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooDLLSignificanceMCSModule*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooDLLSignificanceMCSModule::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooDLLSignificanceMCSModule*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooAbsAnaConvPdf::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooAbsAnaConvPdf::Class_Name()
{
   return "RooAbsAnaConvPdf";
}

//______________________________________________________________________________
const char *RooAbsAnaConvPdf::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsAnaConvPdf*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooAbsAnaConvPdf::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsAnaConvPdf*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooAbsAnaConvPdf::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsAnaConvPdf*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooAbsAnaConvPdf::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsAnaConvPdf*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooEfficiency::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooEfficiency::Class_Name()
{
   return "RooEfficiency";
}

//______________________________________________________________________________
const char *RooEfficiency::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooEfficiency*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooEfficiency::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooEfficiency*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooEfficiency::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooEfficiency*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooEfficiency::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooEfficiency*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooEffProd::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooEffProd::Class_Name()
{
   return "RooEffProd";
}

//______________________________________________________________________________
const char *RooEffProd::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooEffProd*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooEffProd::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooEffProd*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooEffProd::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooEffProd*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooEffProd::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooEffProd*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooExtendPdf::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooExtendPdf::Class_Name()
{
   return "RooExtendPdf";
}

//______________________________________________________________________________
const char *RooExtendPdf::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooExtendPdf*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooExtendPdf::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooExtendPdf*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooExtendPdf::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooExtendPdf*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooExtendPdf::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooExtendPdf*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooEffGenContext::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooEffGenContext::Class_Name()
{
   return "RooEffGenContext";
}

//______________________________________________________________________________
const char *RooEffGenContext::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooEffGenContext*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooEffGenContext::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooEffGenContext*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooEffGenContext::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooEffGenContext*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooEffGenContext::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooEffGenContext*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooEllipse::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooEllipse::Class_Name()
{
   return "RooEllipse";
}

//______________________________________________________________________________
const char *RooEllipse::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooEllipse*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooEllipse::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooEllipse*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooEllipse::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooEllipse*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooEllipse::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooEllipse*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooErrorVar::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooErrorVar::Class_Name()
{
   return "RooErrorVar";
}

//______________________________________________________________________________
const char *RooErrorVar::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooErrorVar*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooErrorVar::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooErrorVar*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooErrorVar::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooErrorVar*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooErrorVar::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooErrorVar*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooFitResult::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooFitResult::Class_Name()
{
   return "RooFitResult";
}

//______________________________________________________________________________
const char *RooFitResult::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooFitResult*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooFitResult::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooFitResult*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooFitResult::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooFitResult*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooFitResult::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooFitResult*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooGaussKronrodIntegrator1D::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooGaussKronrodIntegrator1D::Class_Name()
{
   return "RooGaussKronrodIntegrator1D";
}

//______________________________________________________________________________
const char *RooGaussKronrodIntegrator1D::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooGaussKronrodIntegrator1D*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooGaussKronrodIntegrator1D::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooGaussKronrodIntegrator1D*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooGaussKronrodIntegrator1D::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooGaussKronrodIntegrator1D*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooGaussKronrodIntegrator1D::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooGaussKronrodIntegrator1D*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooGenContext::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooGenContext::Class_Name()
{
   return "RooGenContext";
}

//______________________________________________________________________________
const char *RooGenContext::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooGenContext*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooGenContext::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooGenContext*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooGenContext::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooGenContext*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooGenContext::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooGenContext*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooGenericPdf::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooGenericPdf::Class_Name()
{
   return "RooGenericPdf";
}

//______________________________________________________________________________
const char *RooGenericPdf::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooGenericPdf*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooGenericPdf::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooGenericPdf*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooGenericPdf::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooGenericPdf*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooGenericPdf::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooGenericPdf*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooGenProdProj::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooGenProdProj::Class_Name()
{
   return "RooGenProdProj";
}

//______________________________________________________________________________
const char *RooGenProdProj::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooGenProdProj*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooGenProdProj::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooGenProdProj*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooGenProdProj::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooGenProdProj*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooGenProdProj::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooGenProdProj*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooGrid::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooGrid::Class_Name()
{
   return "RooGrid";
}

//______________________________________________________________________________
const char *RooGrid::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooGrid*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooGrid::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooGrid*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooGrid::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooGrid*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooGrid::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooGrid*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooHistError::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooHistError::Class_Name()
{
   return "RooHistError";
}

//______________________________________________________________________________
const char *RooHistError::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooHistError*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooHistError::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooHistError*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooHistError::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooHistError*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooHistError::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooHistError*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooHist::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooHist::Class_Name()
{
   return "RooHist";
}

//______________________________________________________________________________
const char *RooHist::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooHist*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooHist::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooHist*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooHist::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooHist*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooHist::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooHist*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooImproperIntegrator1D::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooImproperIntegrator1D::Class_Name()
{
   return "RooImproperIntegrator1D";
}

//______________________________________________________________________________
const char *RooImproperIntegrator1D::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooImproperIntegrator1D*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooImproperIntegrator1D::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooImproperIntegrator1D*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooImproperIntegrator1D::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooImproperIntegrator1D*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooImproperIntegrator1D::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooImproperIntegrator1D*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooBinIntegrator::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooBinIntegrator::Class_Name()
{
   return "RooBinIntegrator";
}

//______________________________________________________________________________
const char *RooBinIntegrator::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooBinIntegrator*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooBinIntegrator::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooBinIntegrator*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooBinIntegrator::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooBinIntegrator*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooBinIntegrator::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooBinIntegrator*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooIntegrator1D::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooIntegrator1D::Class_Name()
{
   return "RooIntegrator1D";
}

//______________________________________________________________________________
const char *RooIntegrator1D::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooIntegrator1D*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooIntegrator1D::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooIntegrator1D*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooIntegrator1D::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooIntegrator1D*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooIntegrator1D::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooIntegrator1D*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooIntegrator2D::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooIntegrator2D::Class_Name()
{
   return "RooIntegrator2D";
}

//______________________________________________________________________________
const char *RooIntegrator2D::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooIntegrator2D*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooIntegrator2D::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooIntegrator2D*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooIntegrator2D::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooIntegrator2D*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooIntegrator2D::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooIntegrator2D*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooIntegratorBinding::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooIntegratorBinding::Class_Name()
{
   return "RooIntegratorBinding";
}

//______________________________________________________________________________
const char *RooIntegratorBinding::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooIntegratorBinding*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooIntegratorBinding::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooIntegratorBinding*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooIntegratorBinding::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooIntegratorBinding*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooIntegratorBinding::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooIntegratorBinding*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooInt::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooInt::Class_Name()
{
   return "RooInt";
}

//______________________________________________________________________________
const char *RooInt::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooInt*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooInt::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooInt*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooInt::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooInt*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooInt::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooInt*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooInvTransform::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooInvTransform::Class_Name()
{
   return "RooInvTransform";
}

//______________________________________________________________________________
const char *RooInvTransform::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooInvTransform*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooInvTransform::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooInvTransform*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooInvTransform::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooInvTransform*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooInvTransform::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooInvTransform*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooLinTransBinning::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooLinTransBinning::Class_Name()
{
   return "RooLinTransBinning";
}

//______________________________________________________________________________
const char *RooLinTransBinning::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooLinTransBinning*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooLinTransBinning::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooLinTransBinning*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooLinTransBinning::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooLinTransBinning*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooLinTransBinning::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooLinTransBinning*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooLinearVar::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooLinearVar::Class_Name()
{
   return "RooLinearVar";
}

//______________________________________________________________________________
const char *RooLinearVar::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooLinearVar*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooLinearVar::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooLinearVar*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooLinearVar::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooLinearVar*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooLinearVar::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooLinearVar*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooList::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooList::Class_Name()
{
   return "RooList";
}

//______________________________________________________________________________
const char *RooList::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooList*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooList::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooList*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooList::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooList*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooList::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooList*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooMapCatEntry::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooMapCatEntry::Class_Name()
{
   return "RooMapCatEntry";
}

//______________________________________________________________________________
const char *RooMapCatEntry::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooMapCatEntry*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooMapCatEntry::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooMapCatEntry*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooMapCatEntry::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooMapCatEntry*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooMapCatEntry::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooMapCatEntry*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooMappedCategory::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooMappedCategory::Class_Name()
{
   return "RooMappedCategory";
}

//______________________________________________________________________________
const char *RooMappedCategory::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooMappedCategory*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooMappedCategory::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooMappedCategory*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooMappedCategory::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooMappedCategory*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooMappedCategory::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooMappedCategory*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooMappedCategory::Entry::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooMappedCategory::Entry::Class_Name()
{
   return "RooMappedCategory::Entry";
}

//______________________________________________________________________________
const char *RooMappedCategory::Entry::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooMappedCategory::Entry*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooMappedCategory::Entry::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooMappedCategory::Entry*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooMappedCategory::Entry::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooMappedCategory::Entry*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooMappedCategory::Entry::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooMappedCategory::Entry*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooMCIntegrator::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooMCIntegrator::Class_Name()
{
   return "RooMCIntegrator";
}

//______________________________________________________________________________
const char *RooMCIntegrator::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooMCIntegrator*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooMCIntegrator::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooMCIntegrator*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooMCIntegrator::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooMCIntegrator*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooMCIntegrator::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooMCIntegrator*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooMinuit::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooMinuit::Class_Name()
{
   return "RooMinuit";
}

//______________________________________________________________________________
const char *RooMinuit::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooMinuit*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooMinuit::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooMinuit*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooMinuit::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooMinuit*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooMinuit::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooMinuit*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooMPSentinel::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooMPSentinel::Class_Name()
{
   return "RooMPSentinel";
}

//______________________________________________________________________________
const char *RooMPSentinel::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooMPSentinel*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooMPSentinel::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooMPSentinel*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooMPSentinel::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooMPSentinel*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooMPSentinel::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooMPSentinel*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooMultiCategory::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooMultiCategory::Class_Name()
{
   return "RooMultiCategory";
}

//______________________________________________________________________________
const char *RooMultiCategory::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooMultiCategory*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooMultiCategory::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooMultiCategory*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooMultiCategory::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooMultiCategory*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooMultiCategory::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooMultiCategory*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooMultiCatIter::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooMultiCatIter::Class_Name()
{
   return "RooMultiCatIter";
}

//______________________________________________________________________________
const char *RooMultiCatIter::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooMultiCatIter*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooMultiCatIter::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooMultiCatIter*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooMultiCatIter::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooMultiCatIter*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooMultiCatIter::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooMultiCatIter*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooNLLVar::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooNLLVar::Class_Name()
{
   return "RooNLLVar";
}

//______________________________________________________________________________
const char *RooNLLVar::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooNLLVar*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooNLLVar::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooNLLVar*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooNLLVar::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooNLLVar*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooNLLVar::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooNLLVar*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooNumConvolution::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooNumConvolution::Class_Name()
{
   return "RooNumConvolution";
}

//______________________________________________________________________________
const char *RooNumConvolution::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooNumConvolution*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooNumConvolution::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooNumConvolution*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooNumConvolution::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooNumConvolution*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooNumConvolution::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooNumConvolution*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooNumConvPdf::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooNumConvPdf::Class_Name()
{
   return "RooNumConvPdf";
}

//______________________________________________________________________________
const char *RooNumConvPdf::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooNumConvPdf*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooNumConvPdf::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooNumConvPdf*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooNumConvPdf::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooNumConvPdf*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooNumConvPdf::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooNumConvPdf*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooNumIntFactory::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooNumIntFactory::Class_Name()
{
   return "RooNumIntFactory";
}

//______________________________________________________________________________
const char *RooNumIntFactory::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooNumIntFactory*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooNumIntFactory::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooNumIntFactory*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooNumIntFactory::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooNumIntFactory*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooNumIntFactory::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooNumIntFactory*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooPlot::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooPlot::Class_Name()
{
   return "RooPlot";
}

//______________________________________________________________________________
const char *RooPlot::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooPlot*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooPlot::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooPlot*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooPlot::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooPlot*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooPlot::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooPlot*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooPolyVar::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooPolyVar::Class_Name()
{
   return "RooPolyVar";
}

//______________________________________________________________________________
const char *RooPolyVar::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooPolyVar*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooPolyVar::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooPolyVar*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooPolyVar::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooPolyVar*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooPolyVar::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooPolyVar*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooProdGenContext::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooProdGenContext::Class_Name()
{
   return "RooProdGenContext";
}

//______________________________________________________________________________
const char *RooProdGenContext::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooProdGenContext*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooProdGenContext::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooProdGenContext*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooProdGenContext::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooProdGenContext*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooProdGenContext::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooProdGenContext*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooProduct::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooProduct::Class_Name()
{
   return "RooProduct";
}

//______________________________________________________________________________
const char *RooProduct::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooProduct*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooProduct::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooProduct*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooProduct::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooProduct*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooProduct::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooProduct*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooPullVar::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooPullVar::Class_Name()
{
   return "RooPullVar";
}

//______________________________________________________________________________
const char *RooPullVar::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooPullVar*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooPullVar::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooPullVar*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooPullVar::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooPullVar*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooPullVar::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooPullVar*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooQuasiRandomGenerator::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooQuasiRandomGenerator::Class_Name()
{
   return "RooQuasiRandomGenerator";
}

//______________________________________________________________________________
const char *RooQuasiRandomGenerator::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooQuasiRandomGenerator*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooQuasiRandomGenerator::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooQuasiRandomGenerator*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooQuasiRandomGenerator::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooQuasiRandomGenerator*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooQuasiRandomGenerator::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooQuasiRandomGenerator*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooRandom::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooRandom::Class_Name()
{
   return "RooRandom";
}

//______________________________________________________________________________
const char *RooRandom::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooRandom*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooRandom::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooRandom*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooRandom::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooRandom*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooRandom::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooRandom*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooRandomizeParamMCSModule::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooRandomizeParamMCSModule::Class_Name()
{
   return "RooRandomizeParamMCSModule";
}

//______________________________________________________________________________
const char *RooRandomizeParamMCSModule::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooRandomizeParamMCSModule*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooRandomizeParamMCSModule::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooRandomizeParamMCSModule*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooRandomizeParamMCSModule::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooRandomizeParamMCSModule*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooRandomizeParamMCSModule::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooRandomizeParamMCSModule*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooRangeBinning::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooRangeBinning::Class_Name()
{
   return "RooRangeBinning";
}

//______________________________________________________________________________
const char *RooRangeBinning::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooRangeBinning*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooRangeBinning::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooRangeBinning*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooRangeBinning::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooRangeBinning*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooRangeBinning::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooRangeBinning*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooRealAnalytic::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooRealAnalytic::Class_Name()
{
   return "RooRealAnalytic";
}

//______________________________________________________________________________
const char *RooRealAnalytic::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooRealAnalytic*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooRealAnalytic::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooRealAnalytic*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooRealAnalytic::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooRealAnalytic*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooRealAnalytic::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooRealAnalytic*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooRealConstant::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooRealConstant::Class_Name()
{
   return "RooRealConstant";
}

//______________________________________________________________________________
const char *RooRealConstant::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooRealConstant*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooRealConstant::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooRealConstant*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooRealConstant::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooRealConstant*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooRealConstant::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooRealConstant*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooRealIntegral::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooRealIntegral::Class_Name()
{
   return "RooRealIntegral";
}

//______________________________________________________________________________
const char *RooRealIntegral::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooRealIntegral*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooRealIntegral::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooRealIntegral*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooRealIntegral::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooRealIntegral*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooRealIntegral::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooRealIntegral*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooRealMPFE::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooRealMPFE::Class_Name()
{
   return "RooRealMPFE";
}

//______________________________________________________________________________
const char *RooRealMPFE::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooRealMPFE*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooRealMPFE::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooRealMPFE*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooRealMPFE::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooRealMPFE*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooRealMPFE::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooRealMPFE*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooScaledFunc::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooScaledFunc::Class_Name()
{
   return "RooScaledFunc";
}

//______________________________________________________________________________
const char *RooScaledFunc::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooScaledFunc*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooScaledFunc::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooScaledFunc*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooScaledFunc::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooScaledFunc*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooScaledFunc::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooScaledFunc*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooSegmentedIntegrator1D::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooSegmentedIntegrator1D::Class_Name()
{
   return "RooSegmentedIntegrator1D";
}

//______________________________________________________________________________
const char *RooSegmentedIntegrator1D::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooSegmentedIntegrator1D*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooSegmentedIntegrator1D::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooSegmentedIntegrator1D*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooSegmentedIntegrator1D::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooSegmentedIntegrator1D*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooSegmentedIntegrator1D::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooSegmentedIntegrator1D*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooSegmentedIntegrator2D::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooSegmentedIntegrator2D::Class_Name()
{
   return "RooSegmentedIntegrator2D";
}

//______________________________________________________________________________
const char *RooSegmentedIntegrator2D::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooSegmentedIntegrator2D*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooSegmentedIntegrator2D::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooSegmentedIntegrator2D*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooSegmentedIntegrator2D::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooSegmentedIntegrator2D*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooSegmentedIntegrator2D::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooSegmentedIntegrator2D*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooSetPair::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooSetPair::Class_Name()
{
   return "RooSetPair";
}

//______________________________________________________________________________
const char *RooSetPair::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooSetPair*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooSetPair::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooSetPair*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooSetPair::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooSetPair*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooSetPair::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooSetPair*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooSimGenContext::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooSimGenContext::Class_Name()
{
   return "RooSimGenContext";
}

//______________________________________________________________________________
const char *RooSimGenContext::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooSimGenContext*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooSimGenContext::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooSimGenContext*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooSimGenContext::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooSimGenContext*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooSimGenContext::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooSimGenContext*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooSimSplitGenContext::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooSimSplitGenContext::Class_Name()
{
   return "RooSimSplitGenContext";
}

//______________________________________________________________________________
const char *RooSimSplitGenContext::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooSimSplitGenContext*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooSimSplitGenContext::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooSimSplitGenContext*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooSimSplitGenContext::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooSimSplitGenContext*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooSimSplitGenContext::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooSimSplitGenContext*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooStreamParser::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooStreamParser::Class_Name()
{
   return "RooStreamParser";
}

//______________________________________________________________________________
const char *RooStreamParser::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooStreamParser*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooStreamParser::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooStreamParser*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooStreamParser::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooStreamParser*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooStreamParser::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooStreamParser*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooStringVar::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooStringVar::Class_Name()
{
   return "RooStringVar";
}

//______________________________________________________________________________
const char *RooStringVar::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooStringVar*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooStringVar::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooStringVar*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooStringVar::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooStringVar*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooStringVar::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooStringVar*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooSuperCategory::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooSuperCategory::Class_Name()
{
   return "RooSuperCategory";
}

//______________________________________________________________________________
const char *RooSuperCategory::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooSuperCategory*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooSuperCategory::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooSuperCategory*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooSuperCategory::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooSuperCategory*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooSuperCategory::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooSuperCategory*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooThreshEntry::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooThreshEntry::Class_Name()
{
   return "RooThreshEntry";
}

//______________________________________________________________________________
const char *RooThreshEntry::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooThreshEntry*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooThreshEntry::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooThreshEntry*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooThreshEntry::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooThreshEntry*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooThreshEntry::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooThreshEntry*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooThresholdCategory::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooThresholdCategory::Class_Name()
{
   return "RooThresholdCategory";
}

//______________________________________________________________________________
const char *RooThresholdCategory::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooThresholdCategory*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooThresholdCategory::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooThresholdCategory*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooThresholdCategory::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooThresholdCategory*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooThresholdCategory::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooThresholdCategory*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooTObjWrap::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooTObjWrap::Class_Name()
{
   return "RooTObjWrap";
}

//______________________________________________________________________________
const char *RooTObjWrap::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooTObjWrap*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooTObjWrap::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooTObjWrap*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooTObjWrap::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooTObjWrap*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooTObjWrap::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooTObjWrap*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooSimultaneous::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooSimultaneous::Class_Name()
{
   return "RooSimultaneous";
}

//______________________________________________________________________________
const char *RooSimultaneous::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooSimultaneous*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooSimultaneous::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooSimultaneous*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooSimultaneous::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooSimultaneous*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooSimultaneous::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooSimultaneous*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooRealSumPdf::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooRealSumPdf::Class_Name()
{
   return "RooRealSumPdf";
}

//______________________________________________________________________________
const char *RooRealSumPdf::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooRealSumPdf*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooRealSumPdf::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooRealSumPdf*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooRealSumPdf::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooRealSumPdf*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooRealSumPdf::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooRealSumPdf*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooProdPdf::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooProdPdf::Class_Name()
{
   return "RooProdPdf";
}

//______________________________________________________________________________
const char *RooProdPdf::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooProdPdf*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooProdPdf::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooProdPdf*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooProdPdf::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooProdPdf*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooProdPdf::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooProdPdf*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooSimPdfBuilder::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooSimPdfBuilder::Class_Name()
{
   return "RooSimPdfBuilder";
}

//______________________________________________________________________________
const char *RooSimPdfBuilder::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooSimPdfBuilder*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooSimPdfBuilder::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooSimPdfBuilder*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooSimPdfBuilder::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooSimPdfBuilder*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooSimPdfBuilder::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooSimPdfBuilder*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooTruthModel::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooTruthModel::Class_Name()
{
   return "RooTruthModel";
}

//______________________________________________________________________________
const char *RooTruthModel::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooTruthModel*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooTruthModel::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooTruthModel*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooTruthModel::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooTruthModel*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooTruthModel::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooTruthModel*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooProjectedPdf::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooProjectedPdf::Class_Name()
{
   return "RooProjectedPdf";
}

//______________________________________________________________________________
const char *RooProjectedPdf::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooProjectedPdf*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooProjectedPdf::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooProjectedPdf*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooProjectedPdf::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooProjectedPdf*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooProjectedPdf::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooProjectedPdf*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooExpensiveObjectCache::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooExpensiveObjectCache::Class_Name()
{
   return "RooExpensiveObjectCache";
}

//______________________________________________________________________________
const char *RooExpensiveObjectCache::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooExpensiveObjectCache*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooExpensiveObjectCache::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooExpensiveObjectCache*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooExpensiveObjectCache::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooExpensiveObjectCache*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooExpensiveObjectCache::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooExpensiveObjectCache*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooExpensiveObjectCache::ExpensiveObject::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooExpensiveObjectCache::ExpensiveObject::Class_Name()
{
   return "RooExpensiveObjectCache::ExpensiveObject";
}

//______________________________________________________________________________
const char *RooExpensiveObjectCache::ExpensiveObject::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooExpensiveObjectCache::ExpensiveObject*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooExpensiveObjectCache::ExpensiveObject::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooExpensiveObjectCache::ExpensiveObject*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooExpensiveObjectCache::ExpensiveObject::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooExpensiveObjectCache::ExpensiveObject*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooExpensiveObjectCache::ExpensiveObject::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooExpensiveObjectCache::ExpensiveObject*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooWorkspace::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooWorkspace::Class_Name()
{
   return "RooWorkspace";
}

//______________________________________________________________________________
const char *RooWorkspace::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooWorkspace*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooWorkspace::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooWorkspace*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooWorkspace::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooWorkspace*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooWorkspace::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooWorkspace*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooWorkspace::CodeRepo::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooWorkspace::CodeRepo::Class_Name()
{
   return "RooWorkspace::CodeRepo";
}

//______________________________________________________________________________
const char *RooWorkspace::CodeRepo::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooWorkspace::CodeRepo*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooWorkspace::CodeRepo::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooWorkspace::CodeRepo*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooWorkspace::CodeRepo::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooWorkspace::CodeRepo*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooWorkspace::CodeRepo::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooWorkspace::CodeRepo*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooWorkspace::WSDir::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooWorkspace::WSDir::Class_Name()
{
   return "RooWorkspace::WSDir";
}

//______________________________________________________________________________
const char *RooWorkspace::WSDir::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooWorkspace::WSDir*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooWorkspace::WSDir::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooWorkspace::WSDir*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooWorkspace::WSDir::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooWorkspace::WSDir*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooWorkspace::WSDir::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooWorkspace::WSDir*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooProfileLL::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooProfileLL::Class_Name()
{
   return "RooProfileLL";
}

//______________________________________________________________________________
const char *RooProfileLL::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooProfileLL*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooProfileLL::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooProfileLL*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooProfileLL::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooProfileLL*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooProfileLL::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooProfileLL*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooHistPdf::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooHistPdf::Class_Name()
{
   return "RooHistPdf";
}

//______________________________________________________________________________
const char *RooHistPdf::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooHistPdf*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooHistPdf::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooHistPdf*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooHistPdf::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooHistPdf*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooHistPdf::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooHistPdf*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooAbsCachedPdf::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooAbsCachedPdf::Class_Name()
{
   return "RooAbsCachedPdf";
}

//______________________________________________________________________________
const char *RooAbsCachedPdf::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsCachedPdf*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooAbsCachedPdf::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsCachedPdf*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooAbsCachedPdf::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsCachedPdf*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooAbsCachedPdf::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsCachedPdf*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooAbsSelfCachedPdf::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooAbsSelfCachedPdf::Class_Name()
{
   return "RooAbsSelfCachedPdf";
}

//______________________________________________________________________________
const char *RooAbsSelfCachedPdf::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsSelfCachedPdf*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooAbsSelfCachedPdf::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsSelfCachedPdf*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooAbsSelfCachedPdf::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsSelfCachedPdf*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooAbsSelfCachedPdf::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsSelfCachedPdf*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooCachedPdf::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooCachedPdf::Class_Name()
{
   return "RooCachedPdf";
}

//______________________________________________________________________________
const char *RooCachedPdf::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooCachedPdf*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooCachedPdf::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooCachedPdf*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooCachedPdf::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooCachedPdf*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooCachedPdf::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooCachedPdf*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooFFTConvPdf::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooFFTConvPdf::Class_Name()
{
   return "RooFFTConvPdf";
}

//______________________________________________________________________________
const char *RooFFTConvPdf::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooFFTConvPdf*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooFFTConvPdf::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooFFTConvPdf*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooFFTConvPdf::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooFFTConvPdf*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooFFTConvPdf::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooFFTConvPdf*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooDataHistSliceIter::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooDataHistSliceIter::Class_Name()
{
   return "RooDataHistSliceIter";
}

//______________________________________________________________________________
const char *RooDataHistSliceIter::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooDataHistSliceIter*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooDataHistSliceIter::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooDataHistSliceIter*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooDataHistSliceIter::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooDataHistSliceIter*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooDataHistSliceIter::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooDataHistSliceIter*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooExtendedTerm::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooExtendedTerm::Class_Name()
{
   return "RooExtendedTerm";
}

//______________________________________________________________________________
const char *RooExtendedTerm::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooExtendedTerm*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooExtendedTerm::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooExtendedTerm*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooExtendedTerm::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooExtendedTerm*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooExtendedTerm::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooExtendedTerm*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooParamBinning::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooParamBinning::Class_Name()
{
   return "RooParamBinning";
}

//______________________________________________________________________________
const char *RooParamBinning::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooParamBinning*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooParamBinning::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooParamBinning*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooParamBinning::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooParamBinning*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooParamBinning::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooParamBinning*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooConstraintSum::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooConstraintSum::Class_Name()
{
   return "RooConstraintSum";
}

//______________________________________________________________________________
const char *RooConstraintSum::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooConstraintSum*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooConstraintSum::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooConstraintSum*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooConstraintSum::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooConstraintSum*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooConstraintSum::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooConstraintSum*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooRecursiveFraction::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooRecursiveFraction::Class_Name()
{
   return "RooRecursiveFraction";
}

//______________________________________________________________________________
const char *RooRecursiveFraction::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooRecursiveFraction*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooRecursiveFraction::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooRecursiveFraction*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooRecursiveFraction::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooRecursiveFraction*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooRecursiveFraction::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooRecursiveFraction*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooDataWeightedAverage::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooDataWeightedAverage::Class_Name()
{
   return "RooDataWeightedAverage";
}

//______________________________________________________________________________
const char *RooDataWeightedAverage::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooDataWeightedAverage*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooDataWeightedAverage::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooDataWeightedAverage*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooDataWeightedAverage::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooDataWeightedAverage*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooDataWeightedAverage::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooDataWeightedAverage*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooSimWSTool::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooSimWSTool::Class_Name()
{
   return "RooSimWSTool";
}

//______________________________________________________________________________
const char *RooSimWSTool::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooSimWSTool*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooSimWSTool::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooSimWSTool*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooSimWSTool::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooSimWSTool*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooSimWSTool::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooSimWSTool*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooSimWSTool::SplitRule::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooSimWSTool::SplitRule::Class_Name()
{
   return "RooSimWSTool::SplitRule";
}

//______________________________________________________________________________
const char *RooSimWSTool::SplitRule::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooSimWSTool::SplitRule*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooSimWSTool::SplitRule::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooSimWSTool::SplitRule*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooSimWSTool::SplitRule::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooSimWSTool::SplitRule*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooSimWSTool::SplitRule::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooSimWSTool::SplitRule*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooSimWSTool::BuildConfig::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooSimWSTool::BuildConfig::Class_Name()
{
   return "RooSimWSTool::BuildConfig";
}

//______________________________________________________________________________
const char *RooSimWSTool::BuildConfig::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooSimWSTool::BuildConfig*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooSimWSTool::BuildConfig::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooSimWSTool::BuildConfig*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooSimWSTool::BuildConfig::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooSimWSTool::BuildConfig*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooSimWSTool::BuildConfig::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooSimWSTool::BuildConfig*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooSimWSTool::MultiBuildConfig::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooSimWSTool::MultiBuildConfig::Class_Name()
{
   return "RooSimWSTool::MultiBuildConfig";
}

//______________________________________________________________________________
const char *RooSimWSTool::MultiBuildConfig::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooSimWSTool::MultiBuildConfig*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooSimWSTool::MultiBuildConfig::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooSimWSTool::MultiBuildConfig*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooSimWSTool::MultiBuildConfig::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooSimWSTool::MultiBuildConfig*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooSimWSTool::MultiBuildConfig::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooSimWSTool::MultiBuildConfig*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooSimWSTool::ObjSplitRule::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooSimWSTool::ObjSplitRule::Class_Name()
{
   return "RooSimWSTool::ObjSplitRule";
}

//______________________________________________________________________________
const char *RooSimWSTool::ObjSplitRule::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooSimWSTool::ObjSplitRule*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooSimWSTool::ObjSplitRule::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooSimWSTool::ObjSplitRule*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooSimWSTool::ObjSplitRule::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooSimWSTool::ObjSplitRule*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooSimWSTool::ObjSplitRule::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooSimWSTool::ObjSplitRule*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooSimWSTool::ObjBuildConfig::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooSimWSTool::ObjBuildConfig::Class_Name()
{
   return "RooSimWSTool::ObjBuildConfig";
}

//______________________________________________________________________________
const char *RooSimWSTool::ObjBuildConfig::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooSimWSTool::ObjBuildConfig*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooSimWSTool::ObjBuildConfig::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooSimWSTool::ObjBuildConfig*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooSimWSTool::ObjBuildConfig::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooSimWSTool::ObjBuildConfig*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooSimWSTool::ObjBuildConfig::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooSimWSTool::ObjBuildConfig*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooFracRemainder::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooFracRemainder::Class_Name()
{
   return "RooFracRemainder";
}

//______________________________________________________________________________
const char *RooFracRemainder::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooFracRemainder*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooFracRemainder::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooFracRemainder*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooFracRemainder::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooFracRemainder*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooFracRemainder::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooFracRemainder*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooHistFunc::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooHistFunc::Class_Name()
{
   return "RooHistFunc";
}

//______________________________________________________________________________
const char *RooHistFunc::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooHistFunc*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooHistFunc::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooHistFunc*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooHistFunc::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooHistFunc*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooHistFunc::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooHistFunc*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooAbsCachedReal::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooAbsCachedReal::Class_Name()
{
   return "RooAbsCachedReal";
}

//______________________________________________________________________________
const char *RooAbsCachedReal::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsCachedReal*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooAbsCachedReal::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsCachedReal*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooAbsCachedReal::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsCachedReal*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooAbsCachedReal::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsCachedReal*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooAbsSelfCachedReal::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooAbsSelfCachedReal::Class_Name()
{
   return "RooAbsSelfCachedReal";
}

//______________________________________________________________________________
const char *RooAbsSelfCachedReal::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsSelfCachedReal*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooAbsSelfCachedReal::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsSelfCachedReal*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooAbsSelfCachedReal::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsSelfCachedReal*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooAbsSelfCachedReal::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsSelfCachedReal*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooCachedReal::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooCachedReal::Class_Name()
{
   return "RooCachedReal";
}

//______________________________________________________________________________
const char *RooCachedReal::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooCachedReal*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooCachedReal::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooCachedReal*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooCachedReal::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooCachedReal*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooCachedReal::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooCachedReal*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooNumRunningInt::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooNumRunningInt::Class_Name()
{
   return "RooNumRunningInt";
}

//______________________________________________________________________________
const char *RooNumRunningInt::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooNumRunningInt*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooNumRunningInt::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooNumRunningInt*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooNumRunningInt::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooNumRunningInt*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooNumRunningInt::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooNumRunningInt*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooNumCdf::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooNumCdf::Class_Name()
{
   return "RooNumCdf";
}

//______________________________________________________________________________
const char *RooNumCdf::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooNumCdf*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooNumCdf::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooNumCdf*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooNumCdf::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooNumCdf*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooNumCdf::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooNumCdf*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooChangeTracker::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooChangeTracker::Class_Name()
{
   return "RooChangeTracker";
}

//______________________________________________________________________________
const char *RooChangeTracker::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooChangeTracker*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooChangeTracker::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooChangeTracker*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooChangeTracker::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooChangeTracker*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooChangeTracker::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooChangeTracker*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooBinningCategory::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooBinningCategory::Class_Name()
{
   return "RooBinningCategory";
}

//______________________________________________________________________________
const char *RooBinningCategory::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooBinningCategory*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooBinningCategory::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooBinningCategory*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooBinningCategory::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooBinningCategory*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooBinningCategory::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooBinningCategory*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooTFoamBinding::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooTFoamBinding::Class_Name()
{
   return "RooTFoamBinding";
}

//______________________________________________________________________________
const char *RooTFoamBinding::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooTFoamBinding*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooTFoamBinding::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooTFoamBinding*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooTFoamBinding::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooTFoamBinding*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooTFoamBinding::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooTFoamBinding*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooFunctor::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooFunctor::Class_Name()
{
   return "RooFunctor";
}

//______________________________________________________________________________
const char *RooFunctor::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooFunctor*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooFunctor::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooFunctor*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooFunctor::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooFunctor*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooFunctor::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooFunctor*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooDerivative::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooDerivative::Class_Name()
{
   return "RooDerivative";
}

//______________________________________________________________________________
const char *RooDerivative::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooDerivative*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooDerivative::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooDerivative*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooDerivative::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooDerivative*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooDerivative::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooDerivative*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooGenFunction::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooGenFunction::Class_Name()
{
   return "RooGenFunction";
}

//______________________________________________________________________________
const char *RooGenFunction::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooGenFunction*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooGenFunction::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooGenFunction*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooGenFunction::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooGenFunction*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooGenFunction::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooGenFunction*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooMultiGenFunction::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooMultiGenFunction::Class_Name()
{
   return "RooMultiGenFunction";
}

//______________________________________________________________________________
const char *RooMultiGenFunction::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooMultiGenFunction*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooMultiGenFunction::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooMultiGenFunction*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooMultiGenFunction::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooMultiGenFunction*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooMultiGenFunction::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooMultiGenFunction*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooAdaptiveIntegratorND::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooAdaptiveIntegratorND::Class_Name()
{
   return "RooAdaptiveIntegratorND";
}

//______________________________________________________________________________
const char *RooAdaptiveIntegratorND::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAdaptiveIntegratorND*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooAdaptiveIntegratorND::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAdaptiveIntegratorND*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooAdaptiveIntegratorND::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAdaptiveIntegratorND*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooAdaptiveIntegratorND::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAdaptiveIntegratorND*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooFoamGenerator::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooFoamGenerator::Class_Name()
{
   return "RooFoamGenerator";
}

//______________________________________________________________________________
const char *RooFoamGenerator::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooFoamGenerator*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooFoamGenerator::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooFoamGenerator*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooFoamGenerator::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooFoamGenerator*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooFoamGenerator::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooFoamGenerator*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooNumGenConfig::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooNumGenConfig::Class_Name()
{
   return "RooNumGenConfig";
}

//______________________________________________________________________________
const char *RooNumGenConfig::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooNumGenConfig*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooNumGenConfig::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooNumGenConfig*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooNumGenConfig::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooNumGenConfig*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooNumGenConfig::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooNumGenConfig*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooNumGenFactory::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooNumGenFactory::Class_Name()
{
   return "RooNumGenFactory";
}

//______________________________________________________________________________
const char *RooNumGenFactory::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooNumGenFactory*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooNumGenFactory::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooNumGenFactory*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooNumGenFactory::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooNumGenFactory*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooNumGenFactory::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooNumGenFactory*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooMultiVarGaussian::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooMultiVarGaussian::Class_Name()
{
   return "RooMultiVarGaussian";
}

//______________________________________________________________________________
const char *RooMultiVarGaussian::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooMultiVarGaussian*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooMultiVarGaussian::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooMultiVarGaussian*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooMultiVarGaussian::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooMultiVarGaussian*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooMultiVarGaussian::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooMultiVarGaussian*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooXYChi2Var::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooXYChi2Var::Class_Name()
{
   return "RooXYChi2Var";
}

//______________________________________________________________________________
const char *RooXYChi2Var::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooXYChi2Var*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooXYChi2Var::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooXYChi2Var*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooXYChi2Var::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooXYChi2Var*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooXYChi2Var::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooXYChi2Var*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooAbsDataStore::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooAbsDataStore::Class_Name()
{
   return "RooAbsDataStore";
}

//______________________________________________________________________________
const char *RooAbsDataStore::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsDataStore*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooAbsDataStore::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsDataStore*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooAbsDataStore::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsDataStore*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooAbsDataStore::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsDataStore*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooTreeDataStore::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooTreeDataStore::Class_Name()
{
   return "RooTreeDataStore";
}

//______________________________________________________________________________
const char *RooTreeDataStore::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooTreeDataStore*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooTreeDataStore::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooTreeDataStore*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooTreeDataStore::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooTreeDataStore*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooTreeDataStore::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooTreeDataStore*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooTreeData::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooTreeData::Class_Name()
{
   return "RooTreeData";
}

//______________________________________________________________________________
const char *RooTreeData::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooTreeData*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooTreeData::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooTreeData*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooTreeData::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooTreeData*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooTreeData::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooTreeData*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooMinimizer::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooMinimizer::Class_Name()
{
   return "RooMinimizer";
}

//______________________________________________________________________________
const char *RooMinimizer::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooMinimizer*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooMinimizer::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooMinimizer*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooMinimizer::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooMinimizer*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooMinimizer::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooMinimizer*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooAbsMoment::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooAbsMoment::Class_Name()
{
   return "RooAbsMoment";
}

//______________________________________________________________________________
const char *RooAbsMoment::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsMoment*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooAbsMoment::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsMoment*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooAbsMoment::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsMoment*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooAbsMoment::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsMoment*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooMoment::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooMoment::Class_Name()
{
   return "RooMoment";
}

//______________________________________________________________________________
const char *RooMoment::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooMoment*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooMoment::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooMoment*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooMoment::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooMoment*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooMoment::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooMoment*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooStudyPackage::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooStudyPackage::Class_Name()
{
   return "RooStudyPackage";
}

//______________________________________________________________________________
const char *RooStudyPackage::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooStudyPackage*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooStudyPackage::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooStudyPackage*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooStudyPackage::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooStudyPackage*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooStudyPackage::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooStudyPackage*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooStudyManager::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooStudyManager::Class_Name()
{
   return "RooStudyManager";
}

//______________________________________________________________________________
const char *RooStudyManager::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooStudyManager*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooStudyManager::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooStudyManager*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooStudyManager::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooStudyManager*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooStudyManager::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooStudyManager*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooAbsStudy::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooAbsStudy::Class_Name()
{
   return "RooAbsStudy";
}

//______________________________________________________________________________
const char *RooAbsStudy::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsStudy*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooAbsStudy::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsStudy*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooAbsStudy::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsStudy*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooAbsStudy::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsStudy*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooGenFitStudy::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooGenFitStudy::Class_Name()
{
   return "RooGenFitStudy";
}

//______________________________________________________________________________
const char *RooGenFitStudy::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooGenFitStudy*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooGenFitStudy::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooGenFitStudy*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooGenFitStudy::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooGenFitStudy*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooGenFitStudy::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooGenFitStudy*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooProofDriverSelector::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooProofDriverSelector::Class_Name()
{
   return "RooProofDriverSelector";
}

//______________________________________________________________________________
const char *RooProofDriverSelector::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooProofDriverSelector*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooProofDriverSelector::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooProofDriverSelector*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooProofDriverSelector::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooProofDriverSelector*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooProofDriverSelector::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooProofDriverSelector*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooCompositeDataStore::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooCompositeDataStore::Class_Name()
{
   return "RooCompositeDataStore";
}

//______________________________________________________________________________
const char *RooCompositeDataStore::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooCompositeDataStore*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooCompositeDataStore::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooCompositeDataStore*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooCompositeDataStore::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooCompositeDataStore*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooCompositeDataStore::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooCompositeDataStore*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooRangeBoolean::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooRangeBoolean::Class_Name()
{
   return "RooRangeBoolean";
}

//______________________________________________________________________________
const char *RooRangeBoolean::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooRangeBoolean*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooRangeBoolean::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooRangeBoolean*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooRangeBoolean::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooRangeBoolean*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooRangeBoolean::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooRangeBoolean*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooVectorDataStore::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooVectorDataStore::Class_Name()
{
   return "RooVectorDataStore";
}

//______________________________________________________________________________
const char *RooVectorDataStore::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooVectorDataStore*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooVectorDataStore::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooVectorDataStore*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooVectorDataStore::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooVectorDataStore*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooVectorDataStore::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooVectorDataStore*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooVectorDataStore::RealVector::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooVectorDataStore::RealVector::Class_Name()
{
   return "RooVectorDataStore::RealVector";
}

//______________________________________________________________________________
const char *RooVectorDataStore::RealVector::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooVectorDataStore::RealVector*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooVectorDataStore::RealVector::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooVectorDataStore::RealVector*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooVectorDataStore::RealVector::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooVectorDataStore::RealVector*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooVectorDataStore::RealVector::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooVectorDataStore::RealVector*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooVectorDataStore::RealFullVector::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooVectorDataStore::RealFullVector::Class_Name()
{
   return "RooVectorDataStore::RealFullVector";
}

//______________________________________________________________________________
const char *RooVectorDataStore::RealFullVector::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooVectorDataStore::RealFullVector*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooVectorDataStore::RealFullVector::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooVectorDataStore::RealFullVector*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooVectorDataStore::RealFullVector::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooVectorDataStore::RealFullVector*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooVectorDataStore::RealFullVector::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooVectorDataStore::RealFullVector*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooVectorDataStore::CatVector::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooVectorDataStore::CatVector::Class_Name()
{
   return "RooVectorDataStore::CatVector";
}

//______________________________________________________________________________
const char *RooVectorDataStore::CatVector::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooVectorDataStore::CatVector*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooVectorDataStore::CatVector::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooVectorDataStore::CatVector*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooVectorDataStore::CatVector::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooVectorDataStore::CatVector*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooVectorDataStore::CatVector::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooVectorDataStore::CatVector*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooUnitTest::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooUnitTest::Class_Name()
{
   return "RooUnitTest";
}

//______________________________________________________________________________
const char *RooUnitTest::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooUnitTest*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooUnitTest::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooUnitTest*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooUnitTest::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooUnitTest*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooUnitTest::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooUnitTest*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooExtendedBinding::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooExtendedBinding::Class_Name()
{
   return "RooExtendedBinding";
}

//______________________________________________________________________________
const char *RooExtendedBinding::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooExtendedBinding*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooExtendedBinding::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooExtendedBinding*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooExtendedBinding::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooExtendedBinding*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooExtendedBinding::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooExtendedBinding*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooFirstMoment::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooFirstMoment::Class_Name()
{
   return "RooFirstMoment";
}

//______________________________________________________________________________
const char *RooFirstMoment::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooFirstMoment*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooFirstMoment::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooFirstMoment*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooFirstMoment::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooFirstMoment*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooFirstMoment::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooFirstMoment*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooSecondMoment::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *RooSecondMoment::Class_Name()
{
   return "RooSecondMoment";
}

//______________________________________________________________________________
const char *RooSecondMoment::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooSecondMoment*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int RooSecondMoment::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooSecondMoment*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooSecondMoment::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooSecondMoment*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooSecondMoment::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooSecondMoment*)0x0)->GetClass(); }
   return fgIsA;
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEintcORooLinkedListElemmUgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<int,RooLinkedListElem*> : new pair<int,RooLinkedListElem*>;
   }
   static void *newArray_pairlEintcORooLinkedListElemmUgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<int,RooLinkedListElem*>[nElements] : new pair<int,RooLinkedListElem*>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEintcORooLinkedListElemmUgR(void *p) {
      delete ((pair<int,RooLinkedListElem*>*)p);
   }
   static void deleteArray_pairlEintcORooLinkedListElemmUgR(void *p) {
      delete [] ((pair<int,RooLinkedListElem*>*)p);
   }
   static void destruct_pairlEintcORooLinkedListElemmUgR(void *p) {
      typedef pair<int,RooLinkedListElem*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<int,RooLinkedListElem*>

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEstringcORooAbsDatamUgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<string,RooAbsData*> : new pair<string,RooAbsData*>;
   }
   static void *newArray_pairlEstringcORooAbsDatamUgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<string,RooAbsData*>[nElements] : new pair<string,RooAbsData*>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEstringcORooAbsDatamUgR(void *p) {
      delete ((pair<string,RooAbsData*>*)p);
   }
   static void deleteArray_pairlEstringcORooAbsDatamUgR(void *p) {
      delete [] ((pair<string,RooAbsData*>*)p);
   }
   static void destruct_pairlEstringcORooAbsDatamUgR(void *p) {
      typedef pair<string,RooAbsData*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<string,RooAbsData*>

//______________________________________________________________________________
void RooPrintable::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooPrintable.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooPrintable::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooPrintable::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooPrintable(void *p) {
      return  p ? new(p) ::RooPrintable : new ::RooPrintable;
   }
   static void *newArray_RooPrintable(Long_t nElements, void *p) {
      return p ? new(p) ::RooPrintable[nElements] : new ::RooPrintable[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooPrintable(void *p) {
      delete ((::RooPrintable*)p);
   }
   static void deleteArray_RooPrintable(void *p) {
      delete [] ((::RooPrintable*)p);
   }
   static void destruct_RooPrintable(void *p) {
      typedef ::RooPrintable current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooPrintable

//______________________________________________________________________________
void RooLinkedListElem::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooLinkedListElem.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooLinkedListElem::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooLinkedListElem::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooLinkedListElem(void *p) {
      return  p ? new(p) ::RooLinkedListElem : new ::RooLinkedListElem;
   }
   static void *newArray_RooLinkedListElem(Long_t nElements, void *p) {
      return p ? new(p) ::RooLinkedListElem[nElements] : new ::RooLinkedListElem[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooLinkedListElem(void *p) {
      delete ((::RooLinkedListElem*)p);
   }
   static void deleteArray_RooLinkedListElem(void *p) {
      delete [] ((::RooLinkedListElem*)p);
   }
   static void destruct_RooLinkedListElem(void *p) {
      typedef ::RooLinkedListElem current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooLinkedListElem

//______________________________________________________________________________
void RooHashTable::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooHashTable.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooHashTable::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooHashTable::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooHashTable(void *p) {
      return  p ? new(p) ::RooHashTable : new ::RooHashTable;
   }
   static void *newArray_RooHashTable(Long_t nElements, void *p) {
      return p ? new(p) ::RooHashTable[nElements] : new ::RooHashTable[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooHashTable(void *p) {
      delete ((::RooHashTable*)p);
   }
   static void deleteArray_RooHashTable(void *p) {
      delete [] ((::RooHashTable*)p);
   }
   static void destruct_RooHashTable(void *p) {
      typedef ::RooHashTable current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooHashTable

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooLinkedList(void *p) {
      return  p ? new(p) ::RooLinkedList : new ::RooLinkedList;
   }
   static void *newArray_RooLinkedList(Long_t nElements, void *p) {
      return p ? new(p) ::RooLinkedList[nElements] : new ::RooLinkedList[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooLinkedList(void *p) {
      delete ((::RooLinkedList*)p);
   }
   static void deleteArray_RooLinkedList(void *p) {
      delete [] ((::RooLinkedList*)p);
   }
   static void destruct_RooLinkedList(void *p) {
      typedef ::RooLinkedList current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_RooLinkedList(TBuffer &buf, void *obj) {
      ((::RooLinkedList*)obj)->::RooLinkedList::Streamer(buf);
   }
} // end of namespace ROOT for class ::RooLinkedList

//______________________________________________________________________________
void RooRefCountList::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooRefCountList.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooRefCountList::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooRefCountList::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooRefCountList(void *p) {
      return  p ? new(p) ::RooRefCountList : new ::RooRefCountList;
   }
   static void *newArray_RooRefCountList(Long_t nElements, void *p) {
      return p ? new(p) ::RooRefCountList[nElements] : new ::RooRefCountList[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooRefCountList(void *p) {
      delete ((::RooRefCountList*)p);
   }
   static void deleteArray_RooRefCountList(void *p) {
      delete [] ((::RooRefCountList*)p);
   }
   static void destruct_RooRefCountList(void *p) {
      typedef ::RooRefCountList current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooRefCountList

//______________________________________________________________________________
void RooAbsCache::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooAbsCache.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooAbsCache::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooAbsCache::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooAbsCache(void *p) {
      return  p ? new(p) ::RooAbsCache : new ::RooAbsCache;
   }
   static void *newArray_RooAbsCache(Long_t nElements, void *p) {
      return p ? new(p) ::RooAbsCache[nElements] : new ::RooAbsCache[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooAbsCache(void *p) {
      delete ((::RooAbsCache*)p);
   }
   static void deleteArray_RooAbsCache(void *p) {
      delete [] ((::RooAbsCache*)p);
   }
   static void destruct_RooAbsCache(void *p) {
      typedef ::RooAbsCache current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooAbsCache

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooFIter(void *p) {
      return  p ? new(p) ::RooFIter : new ::RooFIter;
   }
   static void *newArray_RooFIter(Long_t nElements, void *p) {
      return p ? new(p) ::RooFIter[nElements] : new ::RooFIter[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooFIter(void *p) {
      delete ((::RooFIter*)p);
   }
   static void deleteArray_RooFIter(void *p) {
      delete [] ((::RooFIter*)p);
   }
   static void destruct_RooFIter(void *p) {
      typedef ::RooFIter current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooFIter

//______________________________________________________________________________
void RooLinkedListIter::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooLinkedListIter.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooLinkedListIter::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooLinkedListIter::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooLinkedListIter(void *p) {
      return  p ? new(p) ::RooLinkedListIter : new ::RooLinkedListIter;
   }
   static void *newArray_RooLinkedListIter(Long_t nElements, void *p) {
      return p ? new(p) ::RooLinkedListIter[nElements] : new ::RooLinkedListIter[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooLinkedListIter(void *p) {
      delete ((::RooLinkedListIter*)p);
   }
   static void deleteArray_RooLinkedListIter(void *p) {
      delete [] ((::RooLinkedListIter*)p);
   }
   static void destruct_RooLinkedListIter(void *p) {
      typedef ::RooLinkedListIter current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooLinkedListIter

//______________________________________________________________________________
void RooNameReg::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooNameReg.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooNameReg::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooNameReg::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooNameReg(void *p) {
      delete ((::RooNameReg*)p);
   }
   static void deleteArray_RooNameReg(void *p) {
      delete [] ((::RooNameReg*)p);
   }
   static void destruct_RooNameReg(void *p) {
      typedef ::RooNameReg current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooNameReg

namespace ROOT {
   // Wrappers around operator new
   static void *new_stacklERooAbsArgmUcOdequelERooAbsArgmUgRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::stack<RooAbsArg*,deque<RooAbsArg*> > : new ::stack<RooAbsArg*,deque<RooAbsArg*> >;
   }
   static void *newArray_stacklERooAbsArgmUcOdequelERooAbsArgmUgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::stack<RooAbsArg*,deque<RooAbsArg*> >[nElements] : new ::stack<RooAbsArg*,deque<RooAbsArg*> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_stacklERooAbsArgmUcOdequelERooAbsArgmUgRsPgR(void *p) {
      delete ((::stack<RooAbsArg*,deque<RooAbsArg*> >*)p);
   }
   static void deleteArray_stacklERooAbsArgmUcOdequelERooAbsArgmUgRsPgR(void *p) {
      delete [] ((::stack<RooAbsArg*,deque<RooAbsArg*> >*)p);
   }
   static void destruct_stacklERooAbsArgmUcOdequelERooAbsArgmUgRsPgR(void *p) {
      typedef ::stack<RooAbsArg*,deque<RooAbsArg*> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::stack<RooAbsArg*,deque<RooAbsArg*> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooRefArray(void *p) {
      return  p ? new(p) ::RooRefArray : new ::RooRefArray;
   }
   static void *newArray_RooRefArray(Long_t nElements, void *p) {
      return p ? new(p) ::RooRefArray[nElements] : new ::RooRefArray[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooRefArray(void *p) {
      delete ((::RooRefArray*)p);
   }
   static void deleteArray_RooRefArray(void *p) {
      delete [] ((::RooRefArray*)p);
   }
   static void destruct_RooRefArray(void *p) {
      typedef ::RooRefArray current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_RooRefArray(TBuffer &buf, void *obj) {
      ((::RooRefArray*)obj)->::RooRefArray::Streamer(buf);
   }
   // Wrapper around the merge function.
   static Long64_t  merge_RooRefArray(void *obj,TCollection *coll,TFileMergeInfo *) {
      return ((::RooRefArray*)obj)->Merge(coll);
   }
} // end of namespace ROOT for class ::RooRefArray

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooAbsArg(void *p) {
      delete ((::RooAbsArg*)p);
   }
   static void deleteArray_RooAbsArg(void *p) {
      delete [] ((::RooAbsArg*)p);
   }
   static void destruct_RooAbsArg(void *p) {
      typedef ::RooAbsArg current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_RooAbsArg(TBuffer &buf, void *obj) {
      ((::RooAbsArg*)obj)->::RooAbsArg::Streamer(buf);
   }
} // end of namespace ROOT for class ::RooAbsArg

//______________________________________________________________________________
void RooCatType::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooCatType.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooCatType::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooCatType::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooCatType(void *p) {
      return  p ? new(p) ::RooCatType : new ::RooCatType;
   }
   static void *newArray_RooCatType(Long_t nElements, void *p) {
      return p ? new(p) ::RooCatType[nElements] : new ::RooCatType[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooCatType(void *p) {
      delete ((::RooCatType*)p);
   }
   static void deleteArray_RooCatType(void *p) {
      delete [] ((::RooCatType*)p);
   }
   static void destruct_RooCatType(void *p) {
      typedef ::RooCatType current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooCatType

//______________________________________________________________________________
void RooAbsCategory::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooAbsCategory.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooAbsCategory::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooAbsCategory::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooAbsCategory(void *p) {
      delete ((::RooAbsCategory*)p);
   }
   static void deleteArray_RooAbsCategory(void *p) {
      delete [] ((::RooAbsCategory*)p);
   }
   static void destruct_RooAbsCategory(void *p) {
      typedef ::RooAbsCategory current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooAbsCategory

//______________________________________________________________________________
void RooTable::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooTable.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooTable::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooTable::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooTable(void *p) {
      delete ((::RooTable*)p);
   }
   static void deleteArray_RooTable(void *p) {
      delete [] ((::RooTable*)p);
   }
   static void destruct_RooTable(void *p) {
      typedef ::RooTable current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooTable

//______________________________________________________________________________
void Roo1DTable::Streamer(TBuffer &R__b)
{
   // Stream an object of class Roo1DTable.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(Roo1DTable::Class(),this);
   } else {
      R__b.WriteClassBuffer(Roo1DTable::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_Roo1DTable(void *p) {
      return  p ? new(p) ::Roo1DTable : new ::Roo1DTable;
   }
   static void *newArray_Roo1DTable(Long_t nElements, void *p) {
      return p ? new(p) ::Roo1DTable[nElements] : new ::Roo1DTable[nElements];
   }
   // Wrapper around operator delete
   static void delete_Roo1DTable(void *p) {
      delete ((::Roo1DTable*)p);
   }
   static void deleteArray_Roo1DTable(void *p) {
      delete [] ((::Roo1DTable*)p);
   }
   static void destruct_Roo1DTable(void *p) {
      typedef ::Roo1DTable current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::Roo1DTable

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooAbsBinning(void *p) {
      delete ((::RooAbsBinning*)p);
   }
   static void deleteArray_RooAbsBinning(void *p) {
      delete [] ((::RooAbsBinning*)p);
   }
   static void destruct_RooAbsBinning(void *p) {
      typedef ::RooAbsBinning current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_RooAbsBinning(TBuffer &buf, void *obj) {
      ((::RooAbsBinning*)obj)->::RooAbsBinning::Streamer(buf);
   }
} // end of namespace ROOT for class ::RooAbsBinning

//______________________________________________________________________________
void RooAbsLValue::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooAbsLValue.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooAbsLValue::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooAbsLValue::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooAbsLValue(void *p) {
      delete ((::RooAbsLValue*)p);
   }
   static void deleteArray_RooAbsLValue(void *p) {
      delete [] ((::RooAbsLValue*)p);
   }
   static void destruct_RooAbsLValue(void *p) {
      typedef ::RooAbsLValue current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooAbsLValue

//______________________________________________________________________________
void RooAbsCategoryLValue::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooAbsCategoryLValue.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooAbsCategoryLValue::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooAbsCategoryLValue::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooAbsCategoryLValue(void *p) {
      delete ((::RooAbsCategoryLValue*)p);
   }
   static void deleteArray_RooAbsCategoryLValue(void *p) {
      delete [] ((::RooAbsCategoryLValue*)p);
   }
   static void destruct_RooAbsCategoryLValue(void *p) {
      typedef ::RooAbsCategoryLValue current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooAbsCategoryLValue

//______________________________________________________________________________
void RooCmdArg::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooCmdArg.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooCmdArg::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooCmdArg::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooCmdArg(void *p) {
      return  p ? new(p) ::RooCmdArg : new ::RooCmdArg;
   }
   static void *newArray_RooCmdArg(Long_t nElements, void *p) {
      return p ? new(p) ::RooCmdArg[nElements] : new ::RooCmdArg[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooCmdArg(void *p) {
      delete ((::RooCmdArg*)p);
   }
   static void deleteArray_RooCmdArg(void *p) {
      delete [] ((::RooCmdArg*)p);
   }
   static void destruct_RooCmdArg(void *p) {
      typedef ::RooCmdArg current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooCmdArg

//______________________________________________________________________________
void RooAbsCollection::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooAbsCollection.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooAbsCollection::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooAbsCollection::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooAbsCollection(void *p) {
      delete ((::RooAbsCollection*)p);
   }
   static void deleteArray_RooAbsCollection(void *p) {
      delete [] ((::RooAbsCollection*)p);
   }
   static void destruct_RooAbsCollection(void *p) {
      typedef ::RooAbsCollection current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooAbsCollection

//______________________________________________________________________________
void RooArgSet::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooArgSet.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooArgSet::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooArgSet::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooArgSet(void *p) {
      return  p ? new(p) ::RooArgSet : new ::RooArgSet;
   }
   static void *newArray_RooArgSet(Long_t nElements, void *p) {
      return p ? new(p) ::RooArgSet[nElements] : new ::RooArgSet[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooArgSet(void *p) {
      delete ((::RooArgSet*)p);
   }
   static void deleteArray_RooArgSet(void *p) {
      delete [] ((::RooArgSet*)p);
   }
   static void destruct_RooArgSet(void *p) {
      typedef ::RooArgSet current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooArgSet

//______________________________________________________________________________
void RooPlotable::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooPlotable.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooPlotable::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooPlotable::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooPlotable(void *p) {
      delete ((::RooPlotable*)p);
   }
   static void deleteArray_RooPlotable(void *p) {
      delete [] ((::RooPlotable*)p);
   }
   static void destruct_RooPlotable(void *p) {
      typedef ::RooPlotable current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooPlotable

//______________________________________________________________________________
void RooCurve::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooCurve.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooCurve::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooCurve::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooCurve(void *p) {
      return  p ? new(p) ::RooCurve : new ::RooCurve;
   }
   static void *newArray_RooCurve(Long_t nElements, void *p) {
      return p ? new(p) ::RooCurve[nElements] : new ::RooCurve[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooCurve(void *p) {
      delete ((::RooCurve*)p);
   }
   static void deleteArray_RooCurve(void *p) {
      delete [] ((::RooCurve*)p);
   }
   static void destruct_RooCurve(void *p) {
      typedef ::RooCurve current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around the merge function.
   static Long64_t  merge_RooCurve(void *obj,TCollection *coll,TFileMergeInfo *) {
      return ((::RooCurve*)obj)->Merge(coll);
   }
} // end of namespace ROOT for class ::RooCurve

//______________________________________________________________________________
void RooArgList::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooArgList.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooArgList::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooArgList::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooArgList(void *p) {
      return  p ? new(p) ::RooArgList : new ::RooArgList;
   }
   static void *newArray_RooArgList(Long_t nElements, void *p) {
      return p ? new(p) ::RooArgList[nElements] : new ::RooArgList[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooArgList(void *p) {
      delete ((::RooArgList*)p);
   }
   static void deleteArray_RooArgList(void *p) {
      delete [] ((::RooArgList*)p);
   }
   static void destruct_RooArgList(void *p) {
      typedef ::RooArgList current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooArgList

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooGlobalFunc(void *p) {
      return  p ? new(p) ::RooGlobalFunc : new ::RooGlobalFunc;
   }
   static void *newArray_RooGlobalFunc(Long_t nElements, void *p) {
      return p ? new(p) ::RooGlobalFunc[nElements] : new ::RooGlobalFunc[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooGlobalFunc(void *p) {
      delete ((::RooGlobalFunc*)p);
   }
   static void deleteArray_RooGlobalFunc(void *p) {
      delete [] ((::RooGlobalFunc*)p);
   }
   static void destruct_RooGlobalFunc(void *p) {
      typedef ::RooGlobalFunc current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooGlobalFunc

//______________________________________________________________________________
void RooAbsReal::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooAbsReal.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooAbsReal::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooAbsReal::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooAbsReal(void *p) {
      delete ((::RooAbsReal*)p);
   }
   static void deleteArray_RooAbsReal(void *p) {
      delete [] ((::RooAbsReal*)p);
   }
   static void destruct_RooAbsReal(void *p) {
      typedef ::RooAbsReal current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooAbsReal

//______________________________________________________________________________
void RooFormula::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooFormula.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooFormula::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooFormula::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooFormula(void *p) {
      return  p ? new(p) ::RooFormula : new ::RooFormula;
   }
   static void *newArray_RooFormula(Long_t nElements, void *p) {
      return p ? new(p) ::RooFormula[nElements] : new ::RooFormula[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooFormula(void *p) {
      delete ((::RooFormula*)p);
   }
   static void deleteArray_RooFormula(void *p) {
      delete [] ((::RooFormula*)p);
   }
   static void destruct_RooFormula(void *p) {
      typedef ::RooFormula current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooFormula

//______________________________________________________________________________
void RooAbsProxy::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooAbsProxy.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooAbsProxy::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooAbsProxy::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooAbsProxy(void *p) {
      delete ((::RooAbsProxy*)p);
   }
   static void deleteArray_RooAbsProxy(void *p) {
      delete [] ((::RooAbsProxy*)p);
   }
   static void destruct_RooAbsProxy(void *p) {
      typedef ::RooAbsProxy current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooAbsProxy

//______________________________________________________________________________
void RooListProxy::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooListProxy.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooListProxy::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooListProxy::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooListProxy(void *p) {
      return  p ? new(p) ::RooListProxy : new ::RooListProxy;
   }
   static void *newArray_RooListProxy(Long_t nElements, void *p) {
      return p ? new(p) ::RooListProxy[nElements] : new ::RooListProxy[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooListProxy(void *p) {
      delete ((::RooListProxy*)p);
   }
   static void deleteArray_RooListProxy(void *p) {
      delete [] ((::RooListProxy*)p);
   }
   static void destruct_RooListProxy(void *p) {
      typedef ::RooListProxy current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooListProxy

//______________________________________________________________________________
void RooTrace::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooTrace.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooTrace::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooTrace::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooTrace(void *p) {
      return  p ? new(p) ::RooTrace : new ::RooTrace;
   }
   static void *newArray_RooTrace(Long_t nElements, void *p) {
      return p ? new(p) ::RooTrace[nElements] : new ::RooTrace[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooTrace(void *p) {
      delete ((::RooTrace*)p);
   }
   static void deleteArray_RooTrace(void *p) {
      delete [] ((::RooTrace*)p);
   }
   static void destruct_RooTrace(void *p) {
      typedef ::RooTrace current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooTrace

//______________________________________________________________________________
void RooFormulaVar::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooFormulaVar.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooFormulaVar::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooFormulaVar::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooFormulaVar(void *p) {
      return  p ? new(p) ::RooFormulaVar : new ::RooFormulaVar;
   }
   static void *newArray_RooFormulaVar(Long_t nElements, void *p) {
      return p ? new(p) ::RooFormulaVar[nElements] : new ::RooFormulaVar[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooFormulaVar(void *p) {
      delete ((::RooFormulaVar*)p);
   }
   static void deleteArray_RooFormulaVar(void *p) {
      delete [] ((::RooFormulaVar*)p);
   }
   static void destruct_RooFormulaVar(void *p) {
      typedef ::RooFormulaVar current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooFormulaVar

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooAbsData(void *p) {
      delete ((::RooAbsData*)p);
   }
   static void deleteArray_RooAbsData(void *p) {
      delete [] ((::RooAbsData*)p);
   }
   static void destruct_RooAbsData(void *p) {
      typedef ::RooAbsData current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_RooAbsData(TBuffer &buf, void *obj) {
      ((::RooAbsData*)obj)->::RooAbsData::Streamer(buf);
   }
} // end of namespace ROOT for class ::RooAbsData

//______________________________________________________________________________
void RooAbsFunc::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooAbsFunc.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooAbsFunc::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooAbsFunc::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooAbsFunc(void *p) {
      delete ((::RooAbsFunc*)p);
   }
   static void deleteArray_RooAbsFunc(void *p) {
      delete [] ((::RooAbsFunc*)p);
   }
   static void destruct_RooAbsFunc(void *p) {
      typedef ::RooAbsFunc current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooAbsFunc

//______________________________________________________________________________
void RooNameSet::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooNameSet.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooNameSet::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooNameSet::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooNameSet(void *p) {
      return  p ? new(p) ::RooNameSet : new ::RooNameSet;
   }
   static void *newArray_RooNameSet(Long_t nElements, void *p) {
      return p ? new(p) ::RooNameSet[nElements] : new ::RooNameSet[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooNameSet(void *p) {
      delete ((::RooNameSet*)p);
   }
   static void deleteArray_RooNameSet(void *p) {
      delete [] ((::RooNameSet*)p);
   }
   static void destruct_RooNameSet(void *p) {
      typedef ::RooNameSet current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooNameSet

//______________________________________________________________________________
void RooNormSetCache::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooNormSetCache.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooNormSetCache::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooNormSetCache::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooNormSetCache(void *p) {
      return  p ? new(p) ::RooNormSetCache : new ::RooNormSetCache;
   }
   static void *newArray_RooNormSetCache(Long_t nElements, void *p) {
      return p ? new(p) ::RooNormSetCache[nElements] : new ::RooNormSetCache[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooNormSetCache(void *p) {
      delete ((::RooNormSetCache*)p);
   }
   static void deleteArray_RooNormSetCache(void *p) {
      delete [] ((::RooNormSetCache*)p);
   }
   static void destruct_RooNormSetCache(void *p) {
      typedef ::RooNormSetCache current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooNormSetCache

//______________________________________________________________________________
void RooAbsCacheElement::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooAbsCacheElement.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooAbsCacheElement::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooAbsCacheElement::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooAbsCacheElement(void *p) {
      delete ((::RooAbsCacheElement*)p);
   }
   static void deleteArray_RooAbsCacheElement(void *p) {
      delete [] ((::RooAbsCacheElement*)p);
   }
   static void destruct_RooAbsCacheElement(void *p) {
      typedef ::RooAbsCacheElement current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooAbsCacheElement

//______________________________________________________________________________
void RooMsgService::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooMsgService.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooMsgService::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooMsgService::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooMsgService(void *p) {
      delete ((::RooMsgService*)p);
   }
   static void deleteArray_RooMsgService(void *p) {
      delete [] ((::RooMsgService*)p);
   }
   static void destruct_RooMsgService(void *p) {
      typedef ::RooMsgService current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooMsgService

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooMsgServicecLcLStreamConfig(void *p) {
      return  p ? new(p) ::RooMsgService::StreamConfig : new ::RooMsgService::StreamConfig;
   }
   static void *newArray_RooMsgServicecLcLStreamConfig(Long_t nElements, void *p) {
      return p ? new(p) ::RooMsgService::StreamConfig[nElements] : new ::RooMsgService::StreamConfig[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooMsgServicecLcLStreamConfig(void *p) {
      delete ((::RooMsgService::StreamConfig*)p);
   }
   static void deleteArray_RooMsgServicecLcLStreamConfig(void *p) {
      delete [] ((::RooMsgService::StreamConfig*)p);
   }
   static void destruct_RooMsgServicecLcLStreamConfig(void *p) {
      typedef ::RooMsgService::StreamConfig current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooMsgService::StreamConfig

//______________________________________________________________________________
template <> void RooCacheManager<RooAbsCacheElement>::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooCacheManager<RooAbsCacheElement>.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooCacheManager<RooAbsCacheElement>::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooCacheManager<RooAbsCacheElement>::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooCacheManagerlERooAbsCacheElementgR(void *p) {
      return  p ? new(p) ::RooCacheManager<RooAbsCacheElement> : new ::RooCacheManager<RooAbsCacheElement>;
   }
   static void *newArray_RooCacheManagerlERooAbsCacheElementgR(Long_t nElements, void *p) {
      return p ? new(p) ::RooCacheManager<RooAbsCacheElement>[nElements] : new ::RooCacheManager<RooAbsCacheElement>[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooCacheManagerlERooAbsCacheElementgR(void *p) {
      delete ((::RooCacheManager<RooAbsCacheElement>*)p);
   }
   static void deleteArray_RooCacheManagerlERooAbsCacheElementgR(void *p) {
      delete [] ((::RooCacheManager<RooAbsCacheElement>*)p);
   }
   static void destruct_RooCacheManagerlERooAbsCacheElementgR(void *p) {
      typedef ::RooCacheManager<RooAbsCacheElement> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooCacheManager<RooAbsCacheElement>

//______________________________________________________________________________
template <> void RooCacheManager<vector<double> >::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooCacheManager<vector<double> >.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooCacheManager<vector<double> >::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooCacheManager<vector<double> >::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooCacheManagerlEvectorlEdoublegRsPgR(void *p) {
      return  p ? new(p) ::RooCacheManager<vector<double> > : new ::RooCacheManager<vector<double> >;
   }
   static void *newArray_RooCacheManagerlEvectorlEdoublegRsPgR(Long_t nElements, void *p) {
      return p ? new(p) ::RooCacheManager<vector<double> >[nElements] : new ::RooCacheManager<vector<double> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooCacheManagerlEvectorlEdoublegRsPgR(void *p) {
      delete ((::RooCacheManager<vector<double> >*)p);
   }
   static void deleteArray_RooCacheManagerlEvectorlEdoublegRsPgR(void *p) {
      delete [] ((::RooCacheManager<vector<double> >*)p);
   }
   static void destruct_RooCacheManagerlEvectorlEdoublegRsPgR(void *p) {
      typedef ::RooCacheManager<vector<double> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooCacheManager<vector<double> >

//______________________________________________________________________________
void RooObjCacheManager::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooObjCacheManager.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooObjCacheManager::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooObjCacheManager::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooObjCacheManager(void *p) {
      return  p ? new(p) ::RooObjCacheManager : new ::RooObjCacheManager;
   }
   static void *newArray_RooObjCacheManager(Long_t nElements, void *p) {
      return p ? new(p) ::RooObjCacheManager[nElements] : new ::RooObjCacheManager[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooObjCacheManager(void *p) {
      delete ((::RooObjCacheManager*)p);
   }
   static void deleteArray_RooObjCacheManager(void *p) {
      delete [] ((::RooObjCacheManager*)p);
   }
   static void destruct_RooObjCacheManager(void *p) {
      typedef ::RooObjCacheManager current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooObjCacheManager

//______________________________________________________________________________
void RooAbsPdf::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooAbsPdf.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooAbsPdf::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooAbsPdf::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooAbsPdf(void *p) {
      delete ((::RooAbsPdf*)p);
   }
   static void deleteArray_RooAbsPdf(void *p) {
      delete [] ((::RooAbsPdf*)p);
   }
   static void destruct_RooAbsPdf(void *p) {
      typedef ::RooAbsPdf current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooAbsPdf

//______________________________________________________________________________
void RooAbsPdf::GenSpec::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooAbsPdf::GenSpec.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooAbsPdf::GenSpec::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooAbsPdf::GenSpec::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooAbsPdfcLcLGenSpec(void *p) {
      return  p ? new(p) ::RooAbsPdf::GenSpec : new ::RooAbsPdf::GenSpec;
   }
   static void *newArray_RooAbsPdfcLcLGenSpec(Long_t nElements, void *p) {
      return p ? new(p) ::RooAbsPdf::GenSpec[nElements] : new ::RooAbsPdf::GenSpec[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooAbsPdfcLcLGenSpec(void *p) {
      delete ((::RooAbsPdf::GenSpec*)p);
   }
   static void deleteArray_RooAbsPdfcLcLGenSpec(void *p) {
      delete [] ((::RooAbsPdf::GenSpec*)p);
   }
   static void destruct_RooAbsPdfcLcLGenSpec(void *p) {
      typedef ::RooAbsPdf::GenSpec current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooAbsPdf::GenSpec

//______________________________________________________________________________
void RooAbsGenContext::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooAbsGenContext.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooAbsGenContext::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooAbsGenContext::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooAbsGenContext(void *p) {
      delete ((::RooAbsGenContext*)p);
   }
   static void deleteArray_RooAbsGenContext(void *p) {
      delete [] ((::RooAbsGenContext*)p);
   }
   static void destruct_RooAbsGenContext(void *p) {
      typedef ::RooAbsGenContext current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooAbsGenContext

//______________________________________________________________________________
void RooSetProxy::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooSetProxy.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooSetProxy::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooSetProxy::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooSetProxy(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::RooSetProxy : new ::RooSetProxy;
   }
   static void *newArray_RooSetProxy(Long_t nElements, void *p) {
      return p ? new(p) ::RooSetProxy[nElements] : new ::RooSetProxy[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooSetProxy(void *p) {
      delete ((::RooSetProxy*)p);
   }
   static void deleteArray_RooSetProxy(void *p) {
      delete [] ((::RooSetProxy*)p);
   }
   static void destruct_RooSetProxy(void *p) {
      typedef ::RooSetProxy current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooSetProxy

//______________________________________________________________________________
void RooArgProxy::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooArgProxy.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooArgProxy::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooArgProxy::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooArgProxy(void *p) {
      return  p ? new(p) ::RooArgProxy : new ::RooArgProxy;
   }
   static void *newArray_RooArgProxy(Long_t nElements, void *p) {
      return p ? new(p) ::RooArgProxy[nElements] : new ::RooArgProxy[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooArgProxy(void *p) {
      delete ((::RooArgProxy*)p);
   }
   static void deleteArray_RooArgProxy(void *p) {
      delete [] ((::RooArgProxy*)p);
   }
   static void destruct_RooArgProxy(void *p) {
      typedef ::RooArgProxy current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooArgProxy

//______________________________________________________________________________
void RooNumber::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooNumber.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooNumber::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooNumber::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooNumber(void *p) {
      return  p ? new(p) ::RooNumber : new ::RooNumber;
   }
   static void *newArray_RooNumber(Long_t nElements, void *p) {
      return p ? new(p) ::RooNumber[nElements] : new ::RooNumber[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooNumber(void *p) {
      delete ((::RooNumber*)p);
   }
   static void deleteArray_RooNumber(void *p) {
      delete [] ((::RooNumber*)p);
   }
   static void destruct_RooNumber(void *p) {
      typedef ::RooNumber current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooNumber

//______________________________________________________________________________
void RooAbsRealLValue::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooAbsRealLValue.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooAbsRealLValue::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooAbsRealLValue::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooAbsRealLValue(void *p) {
      delete ((::RooAbsRealLValue*)p);
   }
   static void deleteArray_RooAbsRealLValue(void *p) {
      delete [] ((::RooAbsRealLValue*)p);
   }
   static void destruct_RooAbsRealLValue(void *p) {
      typedef ::RooAbsRealLValue current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooAbsRealLValue

//______________________________________________________________________________
void RooRealProxy::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooRealProxy.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooRealProxy::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooRealProxy::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooRealProxy(void *p) {
      return  p ? new(p) ::RooRealProxy : new ::RooRealProxy;
   }
   static void *newArray_RooRealProxy(Long_t nElements, void *p) {
      return p ? new(p) ::RooRealProxy[nElements] : new ::RooRealProxy[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooRealProxy(void *p) {
      delete ((::RooRealProxy*)p);
   }
   static void deleteArray_RooRealProxy(void *p) {
      delete [] ((::RooRealProxy*)p);
   }
   static void destruct_RooRealProxy(void *p) {
      typedef ::RooRealProxy current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooRealProxy

//______________________________________________________________________________
void RooAbsTestStatistic::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooAbsTestStatistic.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooAbsTestStatistic::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooAbsTestStatistic::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooAbsTestStatistic(void *p) {
      delete ((::RooAbsTestStatistic*)p);
   }
   static void deleteArray_RooAbsTestStatistic(void *p) {
      delete [] ((::RooAbsTestStatistic*)p);
   }
   static void destruct_RooAbsTestStatistic(void *p) {
      typedef ::RooAbsTestStatistic current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooAbsTestStatistic

//______________________________________________________________________________
void RooCategoryProxy::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooCategoryProxy.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooCategoryProxy::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooCategoryProxy::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooCategoryProxy(void *p) {
      return  p ? new(p) ::RooCategoryProxy : new ::RooCategoryProxy;
   }
   static void *newArray_RooCategoryProxy(Long_t nElements, void *p) {
      return p ? new(p) ::RooCategoryProxy[nElements] : new ::RooCategoryProxy[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooCategoryProxy(void *p) {
      delete ((::RooCategoryProxy*)p);
   }
   static void deleteArray_RooCategoryProxy(void *p) {
      delete [] ((::RooCategoryProxy*)p);
   }
   static void destruct_RooCategoryProxy(void *p) {
      typedef ::RooCategoryProxy current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooCategoryProxy

//______________________________________________________________________________
void RooAbsHiddenReal::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooAbsHiddenReal.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooAbsHiddenReal::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooAbsHiddenReal::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooAbsHiddenReal(void *p) {
      delete ((::RooAbsHiddenReal*)p);
   }
   static void deleteArray_RooAbsHiddenReal(void *p) {
      delete [] ((::RooAbsHiddenReal*)p);
   }
   static void destruct_RooAbsHiddenReal(void *p) {
      typedef ::RooAbsHiddenReal current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooAbsHiddenReal

//______________________________________________________________________________
void RooSharedProperties::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooSharedProperties.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooSharedProperties::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooSharedProperties::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooSharedProperties(void *p) {
      delete ((::RooSharedProperties*)p);
   }
   static void deleteArray_RooSharedProperties(void *p) {
      delete [] ((::RooSharedProperties*)p);
   }
   static void destruct_RooSharedProperties(void *p) {
      typedef ::RooSharedProperties current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooSharedProperties

//______________________________________________________________________________
void RooSharedPropertiesList::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooSharedPropertiesList.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooSharedPropertiesList::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooSharedPropertiesList::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooSharedPropertiesList(void *p) {
      return  p ? new(p) ::RooSharedPropertiesList : new ::RooSharedPropertiesList;
   }
   static void *newArray_RooSharedPropertiesList(Long_t nElements, void *p) {
      return p ? new(p) ::RooSharedPropertiesList[nElements] : new ::RooSharedPropertiesList[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooSharedPropertiesList(void *p) {
      delete ((::RooSharedPropertiesList*)p);
   }
   static void deleteArray_RooSharedPropertiesList(void *p) {
      delete [] ((::RooSharedPropertiesList*)p);
   }
   static void destruct_RooSharedPropertiesList(void *p) {
      typedef ::RooSharedPropertiesList current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooSharedPropertiesList

//______________________________________________________________________________
void RooCategorySharedProperties::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooCategorySharedProperties.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooCategorySharedProperties::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooCategorySharedProperties::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooCategorySharedProperties(void *p) {
      return  p ? new(p) ::RooCategorySharedProperties : new ::RooCategorySharedProperties;
   }
   static void *newArray_RooCategorySharedProperties(Long_t nElements, void *p) {
      return p ? new(p) ::RooCategorySharedProperties[nElements] : new ::RooCategorySharedProperties[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooCategorySharedProperties(void *p) {
      delete ((::RooCategorySharedProperties*)p);
   }
   static void deleteArray_RooCategorySharedProperties(void *p) {
      delete [] ((::RooCategorySharedProperties*)p);
   }
   static void destruct_RooCategorySharedProperties(void *p) {
      typedef ::RooCategorySharedProperties current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooCategorySharedProperties

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooCategory(void *p) {
      return  p ? new(p) ::RooCategory : new ::RooCategory;
   }
   static void *newArray_RooCategory(Long_t nElements, void *p) {
      return p ? new(p) ::RooCategory[nElements] : new ::RooCategory[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooCategory(void *p) {
      delete ((::RooCategory*)p);
   }
   static void deleteArray_RooCategory(void *p) {
      delete [] ((::RooCategory*)p);
   }
   static void destruct_RooCategory(void *p) {
      typedef ::RooCategory current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_RooCategory(TBuffer &buf, void *obj) {
      ((::RooCategory*)obj)->::RooCategory::Streamer(buf);
   }
} // end of namespace ROOT for class ::RooCategory

//______________________________________________________________________________
void RooNumIntConfig::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooNumIntConfig.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooNumIntConfig::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooNumIntConfig::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooNumIntConfig(void *p) {
      return  p ? new(p) ::RooNumIntConfig : new ::RooNumIntConfig;
   }
   static void *newArray_RooNumIntConfig(Long_t nElements, void *p) {
      return p ? new(p) ::RooNumIntConfig[nElements] : new ::RooNumIntConfig[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooNumIntConfig(void *p) {
      delete ((::RooNumIntConfig*)p);
   }
   static void deleteArray_RooNumIntConfig(void *p) {
      delete [] ((::RooNumIntConfig*)p);
   }
   static void destruct_RooNumIntConfig(void *p) {
      typedef ::RooNumIntConfig current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooNumIntConfig

//______________________________________________________________________________
void RooAbsIntegrator::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooAbsIntegrator.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooAbsIntegrator::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooAbsIntegrator::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooAbsIntegrator(void *p) {
      delete ((::RooAbsIntegrator*)p);
   }
   static void deleteArray_RooAbsIntegrator(void *p) {
      delete [] ((::RooAbsIntegrator*)p);
   }
   static void destruct_RooAbsIntegrator(void *p) {
      typedef ::RooAbsIntegrator current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooAbsIntegrator

//______________________________________________________________________________
void RooMCStudy::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooMCStudy.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooMCStudy::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooMCStudy::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooMCStudy(void *p) {
      delete ((::RooMCStudy*)p);
   }
   static void deleteArray_RooMCStudy(void *p) {
      delete [] ((::RooMCStudy*)p);
   }
   static void destruct_RooMCStudy(void *p) {
      typedef ::RooMCStudy current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooMCStudy

//______________________________________________________________________________
void RooAbsMCStudyModule::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooAbsMCStudyModule.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooAbsMCStudyModule::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooAbsMCStudyModule::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooAbsMCStudyModule(void *p) {
      delete ((::RooAbsMCStudyModule*)p);
   }
   static void deleteArray_RooAbsMCStudyModule(void *p) {
      delete [] ((::RooAbsMCStudyModule*)p);
   }
   static void destruct_RooAbsMCStudyModule(void *p) {
      typedef ::RooAbsMCStudyModule current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooAbsMCStudyModule

//______________________________________________________________________________
void RooAbsOptTestStatistic::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooAbsOptTestStatistic.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooAbsOptTestStatistic::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooAbsOptTestStatistic::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooAbsOptTestStatistic(void *p) {
      delete ((::RooAbsOptTestStatistic*)p);
   }
   static void deleteArray_RooAbsOptTestStatistic(void *p) {
      delete [] ((::RooAbsOptTestStatistic*)p);
   }
   static void destruct_RooAbsOptTestStatistic(void *p) {
      typedef ::RooAbsOptTestStatistic current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooAbsOptTestStatistic

//______________________________________________________________________________
void RooAbsRootFinder::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooAbsRootFinder.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooAbsRootFinder::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooAbsRootFinder::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooAbsRootFinder(void *p) {
      delete ((::RooAbsRootFinder*)p);
   }
   static void deleteArray_RooAbsRootFinder(void *p) {
      delete [] ((::RooAbsRootFinder*)p);
   }
   static void destruct_RooAbsRootFinder(void *p) {
      typedef ::RooAbsRootFinder current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooAbsRootFinder

//______________________________________________________________________________
void RooAbsString::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooAbsString.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooAbsString::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooAbsString::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooAbsString(void *p) {
      delete ((::RooAbsString*)p);
   }
   static void deleteArray_RooAbsString(void *p) {
      delete [] ((::RooAbsString*)p);
   }
   static void destruct_RooAbsString(void *p) {
      typedef ::RooAbsString current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooAbsString

//______________________________________________________________________________
void RooAbsNumGenerator::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooAbsNumGenerator.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooAbsNumGenerator::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooAbsNumGenerator::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooAbsNumGenerator(void *p) {
      delete ((::RooAbsNumGenerator*)p);
   }
   static void deleteArray_RooAbsNumGenerator(void *p) {
      delete [] ((::RooAbsNumGenerator*)p);
   }
   static void destruct_RooAbsNumGenerator(void *p) {
      typedef ::RooAbsNumGenerator current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooAbsNumGenerator

//______________________________________________________________________________
void RooAcceptReject::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooAcceptReject.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooAcceptReject::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooAcceptReject::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooAcceptReject(void *p) {
      return  p ? new(p) ::RooAcceptReject : new ::RooAcceptReject;
   }
   static void *newArray_RooAcceptReject(Long_t nElements, void *p) {
      return p ? new(p) ::RooAcceptReject[nElements] : new ::RooAcceptReject[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooAcceptReject(void *p) {
      delete ((::RooAcceptReject*)p);
   }
   static void deleteArray_RooAcceptReject(void *p) {
      delete [] ((::RooAcceptReject*)p);
   }
   static void destruct_RooAcceptReject(void *p) {
      typedef ::RooAcceptReject current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooAcceptReject

//______________________________________________________________________________
void RooAdaptiveGaussKronrodIntegrator1D::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooAdaptiveGaussKronrodIntegrator1D.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooAdaptiveGaussKronrodIntegrator1D::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooAdaptiveGaussKronrodIntegrator1D::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooAdaptiveGaussKronrodIntegrator1D(void *p) {
      return  p ? new(p) ::RooAdaptiveGaussKronrodIntegrator1D : new ::RooAdaptiveGaussKronrodIntegrator1D;
   }
   static void *newArray_RooAdaptiveGaussKronrodIntegrator1D(Long_t nElements, void *p) {
      return p ? new(p) ::RooAdaptiveGaussKronrodIntegrator1D[nElements] : new ::RooAdaptiveGaussKronrodIntegrator1D[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooAdaptiveGaussKronrodIntegrator1D(void *p) {
      delete ((::RooAdaptiveGaussKronrodIntegrator1D*)p);
   }
   static void deleteArray_RooAdaptiveGaussKronrodIntegrator1D(void *p) {
      delete [] ((::RooAdaptiveGaussKronrodIntegrator1D*)p);
   }
   static void destruct_RooAdaptiveGaussKronrodIntegrator1D(void *p) {
      typedef ::RooAdaptiveGaussKronrodIntegrator1D current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooAdaptiveGaussKronrodIntegrator1D

//______________________________________________________________________________
void RooAICRegistry::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooAICRegistry.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooAICRegistry::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooAICRegistry::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooAICRegistry(void *p) {
      return  p ? new(p) ::RooAICRegistry : new ::RooAICRegistry;
   }
   static void *newArray_RooAICRegistry(Long_t nElements, void *p) {
      return p ? new(p) ::RooAICRegistry[nElements] : new ::RooAICRegistry[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooAICRegistry(void *p) {
      delete ((::RooAICRegistry*)p);
   }
   static void deleteArray_RooAICRegistry(void *p) {
      delete [] ((::RooAICRegistry*)p);
   }
   static void destruct_RooAICRegistry(void *p) {
      typedef ::RooAICRegistry current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooAICRegistry

//______________________________________________________________________________
void RooAddPdf::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooAddPdf.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooAddPdf::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooAddPdf::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooAddPdf(void *p) {
      return  p ? new(p) ::RooAddPdf : new ::RooAddPdf;
   }
   static void *newArray_RooAddPdf(Long_t nElements, void *p) {
      return p ? new(p) ::RooAddPdf[nElements] : new ::RooAddPdf[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooAddPdf(void *p) {
      delete ((::RooAddPdf*)p);
   }
   static void deleteArray_RooAddPdf(void *p) {
      delete [] ((::RooAddPdf*)p);
   }
   static void destruct_RooAddPdf(void *p) {
      typedef ::RooAddPdf current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooAddPdf

//______________________________________________________________________________
void RooUniformBinning::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooUniformBinning.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooUniformBinning::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooUniformBinning::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooUniformBinning(void *p) {
      return  p ? new(p) ::RooUniformBinning : new ::RooUniformBinning;
   }
   static void *newArray_RooUniformBinning(Long_t nElements, void *p) {
      return p ? new(p) ::RooUniformBinning[nElements] : new ::RooUniformBinning[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooUniformBinning(void *p) {
      delete ((::RooUniformBinning*)p);
   }
   static void deleteArray_RooUniformBinning(void *p) {
      delete [] ((::RooUniformBinning*)p);
   }
   static void destruct_RooUniformBinning(void *p) {
      typedef ::RooUniformBinning current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooUniformBinning

//______________________________________________________________________________
void RooRealVarSharedProperties::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooRealVarSharedProperties.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooRealVarSharedProperties::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooRealVarSharedProperties::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooRealVarSharedProperties(void *p) {
      return  p ? new(p) ::RooRealVarSharedProperties : new ::RooRealVarSharedProperties;
   }
   static void *newArray_RooRealVarSharedProperties(Long_t nElements, void *p) {
      return p ? new(p) ::RooRealVarSharedProperties[nElements] : new ::RooRealVarSharedProperties[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooRealVarSharedProperties(void *p) {
      delete ((::RooRealVarSharedProperties*)p);
   }
   static void deleteArray_RooRealVarSharedProperties(void *p) {
      delete [] ((::RooRealVarSharedProperties*)p);
   }
   static void destruct_RooRealVarSharedProperties(void *p) {
      typedef ::RooRealVarSharedProperties current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooRealVarSharedProperties

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooRealVar(void *p) {
      return  p ? new(p) ::RooRealVar : new ::RooRealVar;
   }
   static void *newArray_RooRealVar(Long_t nElements, void *p) {
      return p ? new(p) ::RooRealVar[nElements] : new ::RooRealVar[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooRealVar(void *p) {
      delete ((::RooRealVar*)p);
   }
   static void deleteArray_RooRealVar(void *p) {
      delete [] ((::RooRealVar*)p);
   }
   static void destruct_RooRealVar(void *p) {
      typedef ::RooRealVar current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_RooRealVar(TBuffer &buf, void *obj) {
      ((::RooRealVar*)obj)->::RooRealVar::Streamer(buf);
   }
} // end of namespace ROOT for class ::RooRealVar

//______________________________________________________________________________
void RooResolutionModel::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooResolutionModel.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooResolutionModel::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooResolutionModel::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooResolutionModel(void *p) {
      delete ((::RooResolutionModel*)p);
   }
   static void deleteArray_RooResolutionModel(void *p) {
      delete [] ((::RooResolutionModel*)p);
   }
   static void destruct_RooResolutionModel(void *p) {
      typedef ::RooResolutionModel current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooResolutionModel

//______________________________________________________________________________
void RooAddModel::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooAddModel.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooAddModel::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooAddModel::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooAddModel(void *p) {
      return  p ? new(p) ::RooAddModel : new ::RooAddModel;
   }
   static void *newArray_RooAddModel(Long_t nElements, void *p) {
      return p ? new(p) ::RooAddModel[nElements] : new ::RooAddModel[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooAddModel(void *p) {
      delete ((::RooAddModel*)p);
   }
   static void deleteArray_RooAddModel(void *p) {
      delete [] ((::RooAddModel*)p);
   }
   static void destruct_RooAddModel(void *p) {
      typedef ::RooAddModel current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooAddModel

//______________________________________________________________________________
void RooAddGenContext::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooAddGenContext.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooAddGenContext::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooAddGenContext::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooAddGenContext(void *p) {
      delete ((::RooAddGenContext*)p);
   }
   static void deleteArray_RooAddGenContext(void *p) {
      delete [] ((::RooAddGenContext*)p);
   }
   static void destruct_RooAddGenContext(void *p) {
      typedef ::RooAddGenContext current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooAddGenContext

//______________________________________________________________________________
void RooAddition::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooAddition.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooAddition::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooAddition::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooAddition(void *p) {
      return  p ? new(p) ::RooAddition : new ::RooAddition;
   }
   static void *newArray_RooAddition(Long_t nElements, void *p) {
      return p ? new(p) ::RooAddition[nElements] : new ::RooAddition[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooAddition(void *p) {
      delete ((::RooAddition*)p);
   }
   static void deleteArray_RooAddition(void *p) {
      delete [] ((::RooAddition*)p);
   }
   static void destruct_RooAddition(void *p) {
      typedef ::RooAddition current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooAddition

//______________________________________________________________________________
void RooDouble::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooDouble.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooDouble::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooDouble::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooDouble(void *p) {
      return  p ? new(p) ::RooDouble : new ::RooDouble;
   }
   static void *newArray_RooDouble(Long_t nElements, void *p) {
      return p ? new(p) ::RooDouble[nElements] : new ::RooDouble[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooDouble(void *p) {
      delete ((::RooDouble*)p);
   }
   static void deleteArray_RooDouble(void *p) {
      delete [] ((::RooDouble*)p);
   }
   static void destruct_RooDouble(void *p) {
      typedef ::RooDouble current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooDouble

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooBinning(void *p) {
      return  p ? new(p) ::RooBinning : new ::RooBinning;
   }
   static void *newArray_RooBinning(Long_t nElements, void *p) {
      return p ? new(p) ::RooBinning[nElements] : new ::RooBinning[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooBinning(void *p) {
      delete ((::RooBinning*)p);
   }
   static void deleteArray_RooBinning(void *p) {
      delete [] ((::RooBinning*)p);
   }
   static void destruct_RooBinning(void *p) {
      typedef ::RooBinning current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_RooBinning(TBuffer &buf, void *obj) {
      ((::RooBinning*)obj)->::RooBinning::Streamer(buf);
   }
} // end of namespace ROOT for class ::RooBinning

//______________________________________________________________________________
void RooBinnedGenContext::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooBinnedGenContext.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooBinnedGenContext::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooBinnedGenContext::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooBinnedGenContext(void *p) {
      delete ((::RooBinnedGenContext*)p);
   }
   static void deleteArray_RooBinnedGenContext(void *p) {
      delete [] ((::RooBinnedGenContext*)p);
   }
   static void destruct_RooBinnedGenContext(void *p) {
      typedef ::RooBinnedGenContext current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooBinnedGenContext

//______________________________________________________________________________
void RooBrentRootFinder::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooBrentRootFinder.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooBrentRootFinder::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooBrentRootFinder::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooBrentRootFinder(void *p) {
      delete ((::RooBrentRootFinder*)p);
   }
   static void deleteArray_RooBrentRootFinder(void *p) {
      delete [] ((::RooBrentRootFinder*)p);
   }
   static void destruct_RooBrentRootFinder(void *p) {
      typedef ::RooBrentRootFinder current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooBrentRootFinder

//______________________________________________________________________________
void RooDirItem::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooDirItem.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooDirItem::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooDirItem::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooDirItem(void *p) {
      return  p ? new(p) ::RooDirItem : new ::RooDirItem;
   }
   static void *newArray_RooDirItem(Long_t nElements, void *p) {
      return p ? new(p) ::RooDirItem[nElements] : new ::RooDirItem[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooDirItem(void *p) {
      delete ((::RooDirItem*)p);
   }
   static void deleteArray_RooDirItem(void *p) {
      delete [] ((::RooDirItem*)p);
   }
   static void destruct_RooDirItem(void *p) {
      typedef ::RooDirItem current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooDirItem

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooDataHist(void *p) {
      return  p ? new(p) ::RooDataHist : new ::RooDataHist;
   }
   static void *newArray_RooDataHist(Long_t nElements, void *p) {
      return p ? new(p) ::RooDataHist[nElements] : new ::RooDataHist[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooDataHist(void *p) {
      delete ((::RooDataHist*)p);
   }
   static void deleteArray_RooDataHist(void *p) {
      delete [] ((::RooDataHist*)p);
   }
   static void destruct_RooDataHist(void *p) {
      typedef ::RooDataHist current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_RooDataHist(TBuffer &buf, void *obj) {
      ((::RooDataHist*)obj)->::RooDataHist::Streamer(buf);
   }
} // end of namespace ROOT for class ::RooDataHist

//______________________________________________________________________________
void RooChi2Var::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooChi2Var.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooChi2Var::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooChi2Var::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooChi2Var(void *p) {
      delete ((::RooChi2Var*)p);
   }
   static void deleteArray_RooChi2Var(void *p) {
      delete [] ((::RooChi2Var*)p);
   }
   static void destruct_RooChi2Var(void *p) {
      typedef ::RooChi2Var current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooChi2Var

//______________________________________________________________________________
void RooFactoryWSTool::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooFactoryWSTool.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooFactoryWSTool::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooFactoryWSTool::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooFactoryWSTool(void *p) {
      delete ((::RooFactoryWSTool*)p);
   }
   static void deleteArray_RooFactoryWSTool(void *p) {
      delete [] ((::RooFactoryWSTool*)p);
   }
   static void destruct_RooFactoryWSTool(void *p) {
      typedef ::RooFactoryWSTool current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooFactoryWSTool

//______________________________________________________________________________
void RooClassFactory::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooClassFactory.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooClassFactory::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooClassFactory::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooClassFactory(void *p) {
      return  p ? new(p) ::RooClassFactory : new ::RooClassFactory;
   }
   static void *newArray_RooClassFactory(Long_t nElements, void *p) {
      return p ? new(p) ::RooClassFactory[nElements] : new ::RooClassFactory[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooClassFactory(void *p) {
      delete ((::RooClassFactory*)p);
   }
   static void deleteArray_RooClassFactory(void *p) {
      delete [] ((::RooClassFactory*)p);
   }
   static void destruct_RooClassFactory(void *p) {
      typedef ::RooClassFactory current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooClassFactory

//______________________________________________________________________________
void RooCmdConfig::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooCmdConfig.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooCmdConfig::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooCmdConfig::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooCmdConfig(void *p) {
      delete ((::RooCmdConfig*)p);
   }
   static void deleteArray_RooCmdConfig(void *p) {
      delete [] ((::RooCmdConfig*)p);
   }
   static void destruct_RooCmdConfig(void *p) {
      typedef ::RooCmdConfig current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooCmdConfig

//______________________________________________________________________________
void RooConstVar::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooConstVar.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooConstVar::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooConstVar::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooConstVar(void *p) {
      return  p ? new(p) ::RooConstVar : new ::RooConstVar;
   }
   static void *newArray_RooConstVar(Long_t nElements, void *p) {
      return p ? new(p) ::RooConstVar[nElements] : new ::RooConstVar[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooConstVar(void *p) {
      delete ((::RooConstVar*)p);
   }
   static void deleteArray_RooConstVar(void *p) {
      delete [] ((::RooConstVar*)p);
   }
   static void destruct_RooConstVar(void *p) {
      typedef ::RooConstVar current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooConstVar

//______________________________________________________________________________
void RooConvCoefVar::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooConvCoefVar.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooConvCoefVar::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooConvCoefVar::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooConvCoefVar(void *p) {
      return  p ? new(p) ::RooConvCoefVar : new ::RooConvCoefVar;
   }
   static void *newArray_RooConvCoefVar(Long_t nElements, void *p) {
      return p ? new(p) ::RooConvCoefVar[nElements] : new ::RooConvCoefVar[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooConvCoefVar(void *p) {
      delete ((::RooConvCoefVar*)p);
   }
   static void deleteArray_RooConvCoefVar(void *p) {
      delete [] ((::RooConvCoefVar*)p);
   }
   static void destruct_RooConvCoefVar(void *p) {
      typedef ::RooConvCoefVar current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooConvCoefVar

//______________________________________________________________________________
void RooConvGenContext::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooConvGenContext.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooConvGenContext::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooConvGenContext::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooConvGenContext(void *p) {
      delete ((::RooConvGenContext*)p);
   }
   static void deleteArray_RooConvGenContext(void *p) {
      delete [] ((::RooConvGenContext*)p);
   }
   static void destruct_RooConvGenContext(void *p) {
      typedef ::RooConvGenContext current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooConvGenContext

//______________________________________________________________________________
void RooConvIntegrandBinding::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooConvIntegrandBinding.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooConvIntegrandBinding::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooConvIntegrandBinding::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooConvIntegrandBinding(void *p) {
      delete ((::RooConvIntegrandBinding*)p);
   }
   static void deleteArray_RooConvIntegrandBinding(void *p) {
      delete [] ((::RooConvIntegrandBinding*)p);
   }
   static void destruct_RooConvIntegrandBinding(void *p) {
      typedef ::RooConvIntegrandBinding current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooConvIntegrandBinding

//______________________________________________________________________________
void RooCustomizer::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooCustomizer.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooCustomizer::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooCustomizer::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooCustomizer(void *p) {
      delete ((::RooCustomizer*)p);
   }
   static void deleteArray_RooCustomizer(void *p) {
      delete [] ((::RooCustomizer*)p);
   }
   static void destruct_RooCustomizer(void *p) {
      typedef ::RooCustomizer current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooCustomizer

//______________________________________________________________________________
void RooRealBinding::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooRealBinding.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooRealBinding::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooRealBinding::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooRealBinding(void *p) {
      delete ((::RooRealBinding*)p);
   }
   static void deleteArray_RooRealBinding(void *p) {
      delete [] ((::RooRealBinding*)p);
   }
   static void destruct_RooRealBinding(void *p) {
      typedef ::RooRealBinding current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooRealBinding

//______________________________________________________________________________
void RooDataProjBinding::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooDataProjBinding.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooDataProjBinding::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooDataProjBinding::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooDataProjBinding(void *p) {
      delete ((::RooDataProjBinding*)p);
   }
   static void deleteArray_RooDataProjBinding(void *p) {
      delete [] ((::RooDataProjBinding*)p);
   }
   static void destruct_RooDataProjBinding(void *p) {
      typedef ::RooDataProjBinding current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooDataProjBinding

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooDataSet(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::RooDataSet : new ::RooDataSet;
   }
   static void *newArray_RooDataSet(Long_t nElements, void *p) {
      return p ? new(p) ::RooDataSet[nElements] : new ::RooDataSet[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooDataSet(void *p) {
      delete ((::RooDataSet*)p);
   }
   static void deleteArray_RooDataSet(void *p) {
      delete [] ((::RooDataSet*)p);
   }
   static void destruct_RooDataSet(void *p) {
      typedef ::RooDataSet current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_RooDataSet(TBuffer &buf, void *obj) {
      ((::RooDataSet*)obj)->::RooDataSet::Streamer(buf);
   }
} // end of namespace ROOT for class ::RooDataSet

//______________________________________________________________________________
void RooDLLSignificanceMCSModule::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooDLLSignificanceMCSModule.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooDLLSignificanceMCSModule::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooDLLSignificanceMCSModule::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooDLLSignificanceMCSModule(void *p) {
      delete ((::RooDLLSignificanceMCSModule*)p);
   }
   static void deleteArray_RooDLLSignificanceMCSModule(void *p) {
      delete [] ((::RooDLLSignificanceMCSModule*)p);
   }
   static void destruct_RooDLLSignificanceMCSModule(void *p) {
      typedef ::RooDLLSignificanceMCSModule current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooDLLSignificanceMCSModule

//______________________________________________________________________________
void RooAbsAnaConvPdf::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooAbsAnaConvPdf.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooAbsAnaConvPdf::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooAbsAnaConvPdf::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooAbsAnaConvPdf(void *p) {
      delete ((::RooAbsAnaConvPdf*)p);
   }
   static void deleteArray_RooAbsAnaConvPdf(void *p) {
      delete [] ((::RooAbsAnaConvPdf*)p);
   }
   static void destruct_RooAbsAnaConvPdf(void *p) {
      typedef ::RooAbsAnaConvPdf current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooAbsAnaConvPdf

//______________________________________________________________________________
void RooEfficiency::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooEfficiency.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooEfficiency::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooEfficiency::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooEfficiency(void *p) {
      return  p ? new(p) ::RooEfficiency : new ::RooEfficiency;
   }
   static void *newArray_RooEfficiency(Long_t nElements, void *p) {
      return p ? new(p) ::RooEfficiency[nElements] : new ::RooEfficiency[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooEfficiency(void *p) {
      delete ((::RooEfficiency*)p);
   }
   static void deleteArray_RooEfficiency(void *p) {
      delete [] ((::RooEfficiency*)p);
   }
   static void destruct_RooEfficiency(void *p) {
      typedef ::RooEfficiency current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooEfficiency

//______________________________________________________________________________
void RooEffProd::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooEffProd.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooEffProd::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooEffProd::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooEffProd(void *p) {
      return  p ? new(p) ::RooEffProd : new ::RooEffProd;
   }
   static void *newArray_RooEffProd(Long_t nElements, void *p) {
      return p ? new(p) ::RooEffProd[nElements] : new ::RooEffProd[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooEffProd(void *p) {
      delete ((::RooEffProd*)p);
   }
   static void deleteArray_RooEffProd(void *p) {
      delete [] ((::RooEffProd*)p);
   }
   static void destruct_RooEffProd(void *p) {
      typedef ::RooEffProd current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooEffProd

//______________________________________________________________________________
void RooExtendPdf::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooExtendPdf.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooExtendPdf::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooExtendPdf::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooExtendPdf(void *p) {
      return  p ? new(p) ::RooExtendPdf : new ::RooExtendPdf;
   }
   static void *newArray_RooExtendPdf(Long_t nElements, void *p) {
      return p ? new(p) ::RooExtendPdf[nElements] : new ::RooExtendPdf[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooExtendPdf(void *p) {
      delete ((::RooExtendPdf*)p);
   }
   static void deleteArray_RooExtendPdf(void *p) {
      delete [] ((::RooExtendPdf*)p);
   }
   static void destruct_RooExtendPdf(void *p) {
      typedef ::RooExtendPdf current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooExtendPdf

//______________________________________________________________________________
void RooEffGenContext::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooEffGenContext.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooEffGenContext::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooEffGenContext::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooEffGenContext(void *p) {
      delete ((::RooEffGenContext*)p);
   }
   static void deleteArray_RooEffGenContext(void *p) {
      delete [] ((::RooEffGenContext*)p);
   }
   static void destruct_RooEffGenContext(void *p) {
      typedef ::RooEffGenContext current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooEffGenContext

//______________________________________________________________________________
void RooEllipse::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooEllipse.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooEllipse::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooEllipse::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooEllipse(void *p) {
      return  p ? new(p) ::RooEllipse : new ::RooEllipse;
   }
   static void *newArray_RooEllipse(Long_t nElements, void *p) {
      return p ? new(p) ::RooEllipse[nElements] : new ::RooEllipse[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooEllipse(void *p) {
      delete ((::RooEllipse*)p);
   }
   static void deleteArray_RooEllipse(void *p) {
      delete [] ((::RooEllipse*)p);
   }
   static void destruct_RooEllipse(void *p) {
      typedef ::RooEllipse current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around the merge function.
   static Long64_t  merge_RooEllipse(void *obj,TCollection *coll,TFileMergeInfo *) {
      return ((::RooEllipse*)obj)->Merge(coll);
   }
} // end of namespace ROOT for class ::RooEllipse

//______________________________________________________________________________
void RooErrorVar::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooErrorVar.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooErrorVar::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooErrorVar::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooErrorVar(void *p) {
      return  p ? new(p) ::RooErrorVar : new ::RooErrorVar;
   }
   static void *newArray_RooErrorVar(Long_t nElements, void *p) {
      return p ? new(p) ::RooErrorVar[nElements] : new ::RooErrorVar[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooErrorVar(void *p) {
      delete ((::RooErrorVar*)p);
   }
   static void deleteArray_RooErrorVar(void *p) {
      delete [] ((::RooErrorVar*)p);
   }
   static void destruct_RooErrorVar(void *p) {
      typedef ::RooErrorVar current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooErrorVar

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooFitResult(void *p) {
      return  p ? new(p) ::RooFitResult : new ::RooFitResult;
   }
   static void *newArray_RooFitResult(Long_t nElements, void *p) {
      return p ? new(p) ::RooFitResult[nElements] : new ::RooFitResult[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooFitResult(void *p) {
      delete ((::RooFitResult*)p);
   }
   static void deleteArray_RooFitResult(void *p) {
      delete [] ((::RooFitResult*)p);
   }
   static void destruct_RooFitResult(void *p) {
      typedef ::RooFitResult current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_RooFitResult(TBuffer &buf, void *obj) {
      ((::RooFitResult*)obj)->::RooFitResult::Streamer(buf);
   }
} // end of namespace ROOT for class ::RooFitResult

//______________________________________________________________________________
void RooGaussKronrodIntegrator1D::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooGaussKronrodIntegrator1D.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooGaussKronrodIntegrator1D::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooGaussKronrodIntegrator1D::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooGaussKronrodIntegrator1D(void *p) {
      return  p ? new(p) ::RooGaussKronrodIntegrator1D : new ::RooGaussKronrodIntegrator1D;
   }
   static void *newArray_RooGaussKronrodIntegrator1D(Long_t nElements, void *p) {
      return p ? new(p) ::RooGaussKronrodIntegrator1D[nElements] : new ::RooGaussKronrodIntegrator1D[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooGaussKronrodIntegrator1D(void *p) {
      delete ((::RooGaussKronrodIntegrator1D*)p);
   }
   static void deleteArray_RooGaussKronrodIntegrator1D(void *p) {
      delete [] ((::RooGaussKronrodIntegrator1D*)p);
   }
   static void destruct_RooGaussKronrodIntegrator1D(void *p) {
      typedef ::RooGaussKronrodIntegrator1D current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooGaussKronrodIntegrator1D

//______________________________________________________________________________
void RooGenContext::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooGenContext.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooGenContext::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooGenContext::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooGenContext(void *p) {
      delete ((::RooGenContext*)p);
   }
   static void deleteArray_RooGenContext(void *p) {
      delete [] ((::RooGenContext*)p);
   }
   static void destruct_RooGenContext(void *p) {
      typedef ::RooGenContext current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooGenContext

//______________________________________________________________________________
void RooGenericPdf::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooGenericPdf.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooGenericPdf::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooGenericPdf::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooGenericPdf(void *p) {
      return  p ? new(p) ::RooGenericPdf : new ::RooGenericPdf;
   }
   static void *newArray_RooGenericPdf(Long_t nElements, void *p) {
      return p ? new(p) ::RooGenericPdf[nElements] : new ::RooGenericPdf[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooGenericPdf(void *p) {
      delete ((::RooGenericPdf*)p);
   }
   static void deleteArray_RooGenericPdf(void *p) {
      delete [] ((::RooGenericPdf*)p);
   }
   static void destruct_RooGenericPdf(void *p) {
      typedef ::RooGenericPdf current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooGenericPdf

//______________________________________________________________________________
void RooGenProdProj::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooGenProdProj.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooGenProdProj::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooGenProdProj::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooGenProdProj(void *p) {
      return  p ? new(p) ::RooGenProdProj : new ::RooGenProdProj;
   }
   static void *newArray_RooGenProdProj(Long_t nElements, void *p) {
      return p ? new(p) ::RooGenProdProj[nElements] : new ::RooGenProdProj[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooGenProdProj(void *p) {
      delete ((::RooGenProdProj*)p);
   }
   static void deleteArray_RooGenProdProj(void *p) {
      delete [] ((::RooGenProdProj*)p);
   }
   static void destruct_RooGenProdProj(void *p) {
      typedef ::RooGenProdProj current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooGenProdProj

//______________________________________________________________________________
void RooGrid::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooGrid.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooGrid::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooGrid::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooGrid(void *p) {
      return  p ? new(p) ::RooGrid : new ::RooGrid;
   }
   static void *newArray_RooGrid(Long_t nElements, void *p) {
      return p ? new(p) ::RooGrid[nElements] : new ::RooGrid[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooGrid(void *p) {
      delete ((::RooGrid*)p);
   }
   static void deleteArray_RooGrid(void *p) {
      delete [] ((::RooGrid*)p);
   }
   static void destruct_RooGrid(void *p) {
      typedef ::RooGrid current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooGrid

//______________________________________________________________________________
void RooHistError::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooHistError.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooHistError::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooHistError::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooHistError(void *p) {
      delete ((::RooHistError*)p);
   }
   static void deleteArray_RooHistError(void *p) {
      delete [] ((::RooHistError*)p);
   }
   static void destruct_RooHistError(void *p) {
      typedef ::RooHistError current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooHistError

//______________________________________________________________________________
void RooHist::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooHist.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooHist::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooHist::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooHist(void *p) {
      return  p ? new(p) ::RooHist : new ::RooHist;
   }
   static void *newArray_RooHist(Long_t nElements, void *p) {
      return p ? new(p) ::RooHist[nElements] : new ::RooHist[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooHist(void *p) {
      delete ((::RooHist*)p);
   }
   static void deleteArray_RooHist(void *p) {
      delete [] ((::RooHist*)p);
   }
   static void destruct_RooHist(void *p) {
      typedef ::RooHist current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around the merge function.
   static Long64_t  merge_RooHist(void *obj,TCollection *coll,TFileMergeInfo *) {
      return ((::RooHist*)obj)->Merge(coll);
   }
} // end of namespace ROOT for class ::RooHist

//______________________________________________________________________________
void RooImproperIntegrator1D::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooImproperIntegrator1D.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooImproperIntegrator1D::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooImproperIntegrator1D::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooImproperIntegrator1D(void *p) {
      return  p ? new(p) ::RooImproperIntegrator1D : new ::RooImproperIntegrator1D;
   }
   static void *newArray_RooImproperIntegrator1D(Long_t nElements, void *p) {
      return p ? new(p) ::RooImproperIntegrator1D[nElements] : new ::RooImproperIntegrator1D[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooImproperIntegrator1D(void *p) {
      delete ((::RooImproperIntegrator1D*)p);
   }
   static void deleteArray_RooImproperIntegrator1D(void *p) {
      delete [] ((::RooImproperIntegrator1D*)p);
   }
   static void destruct_RooImproperIntegrator1D(void *p) {
      typedef ::RooImproperIntegrator1D current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooImproperIntegrator1D

//______________________________________________________________________________
void RooBinIntegrator::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooBinIntegrator.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooBinIntegrator::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooBinIntegrator::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooBinIntegrator(void *p) {
      return  p ? new(p) ::RooBinIntegrator : new ::RooBinIntegrator;
   }
   static void *newArray_RooBinIntegrator(Long_t nElements, void *p) {
      return p ? new(p) ::RooBinIntegrator[nElements] : new ::RooBinIntegrator[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooBinIntegrator(void *p) {
      delete ((::RooBinIntegrator*)p);
   }
   static void deleteArray_RooBinIntegrator(void *p) {
      delete [] ((::RooBinIntegrator*)p);
   }
   static void destruct_RooBinIntegrator(void *p) {
      typedef ::RooBinIntegrator current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooBinIntegrator

//______________________________________________________________________________
void RooIntegrator1D::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooIntegrator1D.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooIntegrator1D::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooIntegrator1D::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooIntegrator1D(void *p) {
      return  p ? new(p) ::RooIntegrator1D : new ::RooIntegrator1D;
   }
   static void *newArray_RooIntegrator1D(Long_t nElements, void *p) {
      return p ? new(p) ::RooIntegrator1D[nElements] : new ::RooIntegrator1D[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooIntegrator1D(void *p) {
      delete ((::RooIntegrator1D*)p);
   }
   static void deleteArray_RooIntegrator1D(void *p) {
      delete [] ((::RooIntegrator1D*)p);
   }
   static void destruct_RooIntegrator1D(void *p) {
      typedef ::RooIntegrator1D current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooIntegrator1D

//______________________________________________________________________________
void RooIntegrator2D::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooIntegrator2D.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooIntegrator2D::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooIntegrator2D::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooIntegrator2D(void *p) {
      return  p ? new(p) ::RooIntegrator2D : new ::RooIntegrator2D;
   }
   static void *newArray_RooIntegrator2D(Long_t nElements, void *p) {
      return p ? new(p) ::RooIntegrator2D[nElements] : new ::RooIntegrator2D[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooIntegrator2D(void *p) {
      delete ((::RooIntegrator2D*)p);
   }
   static void deleteArray_RooIntegrator2D(void *p) {
      delete [] ((::RooIntegrator2D*)p);
   }
   static void destruct_RooIntegrator2D(void *p) {
      typedef ::RooIntegrator2D current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooIntegrator2D

//______________________________________________________________________________
void RooIntegratorBinding::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooIntegratorBinding.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooIntegratorBinding::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooIntegratorBinding::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooIntegratorBinding(void *p) {
      delete ((::RooIntegratorBinding*)p);
   }
   static void deleteArray_RooIntegratorBinding(void *p) {
      delete [] ((::RooIntegratorBinding*)p);
   }
   static void destruct_RooIntegratorBinding(void *p) {
      typedef ::RooIntegratorBinding current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooIntegratorBinding

//______________________________________________________________________________
void RooInt::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooInt.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooInt::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooInt::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooInt(void *p) {
      return  p ? new(p) ::RooInt : new ::RooInt;
   }
   static void *newArray_RooInt(Long_t nElements, void *p) {
      return p ? new(p) ::RooInt[nElements] : new ::RooInt[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooInt(void *p) {
      delete ((::RooInt*)p);
   }
   static void deleteArray_RooInt(void *p) {
      delete [] ((::RooInt*)p);
   }
   static void destruct_RooInt(void *p) {
      typedef ::RooInt current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooInt

//______________________________________________________________________________
void RooInvTransform::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooInvTransform.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooInvTransform::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooInvTransform::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooInvTransform(void *p) {
      delete ((::RooInvTransform*)p);
   }
   static void deleteArray_RooInvTransform(void *p) {
      delete [] ((::RooInvTransform*)p);
   }
   static void destruct_RooInvTransform(void *p) {
      typedef ::RooInvTransform current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooInvTransform

//______________________________________________________________________________
void RooLinTransBinning::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooLinTransBinning.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooLinTransBinning::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooLinTransBinning::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooLinTransBinning(void *p) {
      return  p ? new(p) ::RooLinTransBinning : new ::RooLinTransBinning;
   }
   static void *newArray_RooLinTransBinning(Long_t nElements, void *p) {
      return p ? new(p) ::RooLinTransBinning[nElements] : new ::RooLinTransBinning[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooLinTransBinning(void *p) {
      delete ((::RooLinTransBinning*)p);
   }
   static void deleteArray_RooLinTransBinning(void *p) {
      delete [] ((::RooLinTransBinning*)p);
   }
   static void destruct_RooLinTransBinning(void *p) {
      typedef ::RooLinTransBinning current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooLinTransBinning

//______________________________________________________________________________
void RooLinearVar::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooLinearVar.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooLinearVar::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooLinearVar::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooLinearVar(void *p) {
      return  p ? new(p) ::RooLinearVar : new ::RooLinearVar;
   }
   static void *newArray_RooLinearVar(Long_t nElements, void *p) {
      return p ? new(p) ::RooLinearVar[nElements] : new ::RooLinearVar[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooLinearVar(void *p) {
      delete ((::RooLinearVar*)p);
   }
   static void deleteArray_RooLinearVar(void *p) {
      delete [] ((::RooLinearVar*)p);
   }
   static void destruct_RooLinearVar(void *p) {
      typedef ::RooLinearVar current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooLinearVar

//______________________________________________________________________________
void RooList::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooList.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooList::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooList::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooList(void *p) {
      return  p ? new(p) ::RooList : new ::RooList;
   }
   static void *newArray_RooList(Long_t nElements, void *p) {
      return p ? new(p) ::RooList[nElements] : new ::RooList[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooList(void *p) {
      delete ((::RooList*)p);
   }
   static void deleteArray_RooList(void *p) {
      delete [] ((::RooList*)p);
   }
   static void destruct_RooList(void *p) {
      typedef ::RooList current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around the merge function.
   static Long64_t  merge_RooList(void *obj,TCollection *coll,TFileMergeInfo *) {
      return ((::RooList*)obj)->Merge(coll);
   }
} // end of namespace ROOT for class ::RooList

//______________________________________________________________________________
void RooMapCatEntry::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooMapCatEntry.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooMapCatEntry::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooMapCatEntry::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooMapCatEntry(void *p) {
      return  p ? new(p) ::RooMapCatEntry : new ::RooMapCatEntry;
   }
   static void *newArray_RooMapCatEntry(Long_t nElements, void *p) {
      return p ? new(p) ::RooMapCatEntry[nElements] : new ::RooMapCatEntry[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooMapCatEntry(void *p) {
      delete ((::RooMapCatEntry*)p);
   }
   static void deleteArray_RooMapCatEntry(void *p) {
      delete [] ((::RooMapCatEntry*)p);
   }
   static void destruct_RooMapCatEntry(void *p) {
      typedef ::RooMapCatEntry current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooMapCatEntry

//______________________________________________________________________________
void RooMappedCategory::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooMappedCategory.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooMappedCategory::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooMappedCategory::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooMappedCategory(void *p) {
      return  p ? new(p) ::RooMappedCategory : new ::RooMappedCategory;
   }
   static void *newArray_RooMappedCategory(Long_t nElements, void *p) {
      return p ? new(p) ::RooMappedCategory[nElements] : new ::RooMappedCategory[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooMappedCategory(void *p) {
      delete ((::RooMappedCategory*)p);
   }
   static void deleteArray_RooMappedCategory(void *p) {
      delete [] ((::RooMappedCategory*)p);
   }
   static void destruct_RooMappedCategory(void *p) {
      typedef ::RooMappedCategory current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooMappedCategory

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooMappedCategorycLcLEntry(void *p) {
      return  p ? new(p) ::RooMappedCategory::Entry : new ::RooMappedCategory::Entry;
   }
   static void *newArray_RooMappedCategorycLcLEntry(Long_t nElements, void *p) {
      return p ? new(p) ::RooMappedCategory::Entry[nElements] : new ::RooMappedCategory::Entry[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooMappedCategorycLcLEntry(void *p) {
      delete ((::RooMappedCategory::Entry*)p);
   }
   static void deleteArray_RooMappedCategorycLcLEntry(void *p) {
      delete [] ((::RooMappedCategory::Entry*)p);
   }
   static void destruct_RooMappedCategorycLcLEntry(void *p) {
      typedef ::RooMappedCategory::Entry current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_RooMappedCategorycLcLEntry(TBuffer &buf, void *obj) {
      ((::RooMappedCategory::Entry*)obj)->::RooMappedCategory::Entry::Streamer(buf);
   }
} // end of namespace ROOT for class ::RooMappedCategory::Entry

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooMath(void *p) {
      return  p ? new(p) ::RooMath : new ::RooMath;
   }
   static void *newArray_RooMath(Long_t nElements, void *p) {
      return p ? new(p) ::RooMath[nElements] : new ::RooMath[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooMath(void *p) {
      delete ((::RooMath*)p);
   }
   static void deleteArray_RooMath(void *p) {
      delete [] ((::RooMath*)p);
   }
   static void destruct_RooMath(void *p) {
      typedef ::RooMath current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooMath

//______________________________________________________________________________
void RooMCIntegrator::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooMCIntegrator.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooMCIntegrator::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooMCIntegrator::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooMCIntegrator(void *p) {
      return  p ? new(p) ::RooMCIntegrator : new ::RooMCIntegrator;
   }
   static void *newArray_RooMCIntegrator(Long_t nElements, void *p) {
      return p ? new(p) ::RooMCIntegrator[nElements] : new ::RooMCIntegrator[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooMCIntegrator(void *p) {
      delete ((::RooMCIntegrator*)p);
   }
   static void deleteArray_RooMCIntegrator(void *p) {
      delete [] ((::RooMCIntegrator*)p);
   }
   static void destruct_RooMCIntegrator(void *p) {
      typedef ::RooMCIntegrator current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooMCIntegrator

//______________________________________________________________________________
void RooMinuit::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooMinuit.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooMinuit::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooMinuit::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooMinuit(void *p) {
      delete ((::RooMinuit*)p);
   }
   static void deleteArray_RooMinuit(void *p) {
      delete [] ((::RooMinuit*)p);
   }
   static void destruct_RooMinuit(void *p) {
      typedef ::RooMinuit current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooMinuit

//______________________________________________________________________________
void RooMPSentinel::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooMPSentinel.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooMPSentinel::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooMPSentinel::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooMPSentinel(void *p) {
      return  p ? new(p) ::RooMPSentinel : new ::RooMPSentinel;
   }
   static void *newArray_RooMPSentinel(Long_t nElements, void *p) {
      return p ? new(p) ::RooMPSentinel[nElements] : new ::RooMPSentinel[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooMPSentinel(void *p) {
      delete ((::RooMPSentinel*)p);
   }
   static void deleteArray_RooMPSentinel(void *p) {
      delete [] ((::RooMPSentinel*)p);
   }
   static void destruct_RooMPSentinel(void *p) {
      typedef ::RooMPSentinel current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooMPSentinel

//______________________________________________________________________________
void RooMultiCategory::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooMultiCategory.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooMultiCategory::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooMultiCategory::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooMultiCategory(void *p) {
      return  p ? new(p) ::RooMultiCategory : new ::RooMultiCategory;
   }
   static void *newArray_RooMultiCategory(Long_t nElements, void *p) {
      return p ? new(p) ::RooMultiCategory[nElements] : new ::RooMultiCategory[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooMultiCategory(void *p) {
      delete ((::RooMultiCategory*)p);
   }
   static void deleteArray_RooMultiCategory(void *p) {
      delete [] ((::RooMultiCategory*)p);
   }
   static void destruct_RooMultiCategory(void *p) {
      typedef ::RooMultiCategory current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooMultiCategory

//______________________________________________________________________________
void RooMultiCatIter::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooMultiCatIter.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooMultiCatIter::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooMultiCatIter::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooMultiCatIter(void *p) {
      delete ((::RooMultiCatIter*)p);
   }
   static void deleteArray_RooMultiCatIter(void *p) {
      delete [] ((::RooMultiCatIter*)p);
   }
   static void destruct_RooMultiCatIter(void *p) {
      typedef ::RooMultiCatIter current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooMultiCatIter

//______________________________________________________________________________
void RooNLLVar::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooNLLVar.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooNLLVar::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooNLLVar::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooNLLVar(void *p) {
      return  p ? new(p) ::RooNLLVar : new ::RooNLLVar;
   }
   static void *newArray_RooNLLVar(Long_t nElements, void *p) {
      return p ? new(p) ::RooNLLVar[nElements] : new ::RooNLLVar[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooNLLVar(void *p) {
      delete ((::RooNLLVar*)p);
   }
   static void deleteArray_RooNLLVar(void *p) {
      delete [] ((::RooNLLVar*)p);
   }
   static void destruct_RooNLLVar(void *p) {
      typedef ::RooNLLVar current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooNLLVar

//______________________________________________________________________________
void RooNumConvolution::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooNumConvolution.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooNumConvolution::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooNumConvolution::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooNumConvolution(void *p) {
      return  p ? new(p) ::RooNumConvolution : new ::RooNumConvolution;
   }
   static void *newArray_RooNumConvolution(Long_t nElements, void *p) {
      return p ? new(p) ::RooNumConvolution[nElements] : new ::RooNumConvolution[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooNumConvolution(void *p) {
      delete ((::RooNumConvolution*)p);
   }
   static void deleteArray_RooNumConvolution(void *p) {
      delete [] ((::RooNumConvolution*)p);
   }
   static void destruct_RooNumConvolution(void *p) {
      typedef ::RooNumConvolution current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooNumConvolution

//______________________________________________________________________________
void RooNumConvPdf::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooNumConvPdf.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooNumConvPdf::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooNumConvPdf::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooNumConvPdf(void *p) {
      return  p ? new(p) ::RooNumConvPdf : new ::RooNumConvPdf;
   }
   static void *newArray_RooNumConvPdf(Long_t nElements, void *p) {
      return p ? new(p) ::RooNumConvPdf[nElements] : new ::RooNumConvPdf[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooNumConvPdf(void *p) {
      delete ((::RooNumConvPdf*)p);
   }
   static void deleteArray_RooNumConvPdf(void *p) {
      delete [] ((::RooNumConvPdf*)p);
   }
   static void destruct_RooNumConvPdf(void *p) {
      typedef ::RooNumConvPdf current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooNumConvPdf

//______________________________________________________________________________
void RooNumIntFactory::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooNumIntFactory.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooNumIntFactory::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooNumIntFactory::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooNumIntFactory(void *p) {
      delete ((::RooNumIntFactory*)p);
   }
   static void deleteArray_RooNumIntFactory(void *p) {
      delete [] ((::RooNumIntFactory*)p);
   }
   static void destruct_RooNumIntFactory(void *p) {
      typedef ::RooNumIntFactory current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooNumIntFactory

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooPlot(void *p) {
      return  p ? new(p) ::RooPlot : new ::RooPlot;
   }
   static void *newArray_RooPlot(Long_t nElements, void *p) {
      return p ? new(p) ::RooPlot[nElements] : new ::RooPlot[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooPlot(void *p) {
      delete ((::RooPlot*)p);
   }
   static void deleteArray_RooPlot(void *p) {
      delete [] ((::RooPlot*)p);
   }
   static void destruct_RooPlot(void *p) {
      typedef ::RooPlot current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_RooPlot(TBuffer &buf, void *obj) {
      ((::RooPlot*)obj)->::RooPlot::Streamer(buf);
   }
} // end of namespace ROOT for class ::RooPlot

//______________________________________________________________________________
void RooPolyVar::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooPolyVar.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooPolyVar::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooPolyVar::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooPolyVar(void *p) {
      return  p ? new(p) ::RooPolyVar : new ::RooPolyVar;
   }
   static void *newArray_RooPolyVar(Long_t nElements, void *p) {
      return p ? new(p) ::RooPolyVar[nElements] : new ::RooPolyVar[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooPolyVar(void *p) {
      delete ((::RooPolyVar*)p);
   }
   static void deleteArray_RooPolyVar(void *p) {
      delete [] ((::RooPolyVar*)p);
   }
   static void destruct_RooPolyVar(void *p) {
      typedef ::RooPolyVar current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooPolyVar

//______________________________________________________________________________
void RooProdGenContext::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooProdGenContext.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooProdGenContext::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooProdGenContext::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooProdGenContext(void *p) {
      delete ((::RooProdGenContext*)p);
   }
   static void deleteArray_RooProdGenContext(void *p) {
      delete [] ((::RooProdGenContext*)p);
   }
   static void destruct_RooProdGenContext(void *p) {
      typedef ::RooProdGenContext current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooProdGenContext

//______________________________________________________________________________
void RooProduct::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooProduct.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooProduct::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooProduct::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooProduct(void *p) {
      return  p ? new(p) ::RooProduct : new ::RooProduct;
   }
   static void *newArray_RooProduct(Long_t nElements, void *p) {
      return p ? new(p) ::RooProduct[nElements] : new ::RooProduct[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooProduct(void *p) {
      delete ((::RooProduct*)p);
   }
   static void deleteArray_RooProduct(void *p) {
      delete [] ((::RooProduct*)p);
   }
   static void destruct_RooProduct(void *p) {
      typedef ::RooProduct current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooProduct

//______________________________________________________________________________
void RooPullVar::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooPullVar.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooPullVar::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooPullVar::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooPullVar(void *p) {
      return  p ? new(p) ::RooPullVar : new ::RooPullVar;
   }
   static void *newArray_RooPullVar(Long_t nElements, void *p) {
      return p ? new(p) ::RooPullVar[nElements] : new ::RooPullVar[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooPullVar(void *p) {
      delete ((::RooPullVar*)p);
   }
   static void deleteArray_RooPullVar(void *p) {
      delete [] ((::RooPullVar*)p);
   }
   static void destruct_RooPullVar(void *p) {
      typedef ::RooPullVar current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooPullVar

//______________________________________________________________________________
void RooQuasiRandomGenerator::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooQuasiRandomGenerator.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooQuasiRandomGenerator::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooQuasiRandomGenerator::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooQuasiRandomGenerator(void *p) {
      return  p ? new(p) ::RooQuasiRandomGenerator : new ::RooQuasiRandomGenerator;
   }
   static void *newArray_RooQuasiRandomGenerator(Long_t nElements, void *p) {
      return p ? new(p) ::RooQuasiRandomGenerator[nElements] : new ::RooQuasiRandomGenerator[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooQuasiRandomGenerator(void *p) {
      delete ((::RooQuasiRandomGenerator*)p);
   }
   static void deleteArray_RooQuasiRandomGenerator(void *p) {
      delete [] ((::RooQuasiRandomGenerator*)p);
   }
   static void destruct_RooQuasiRandomGenerator(void *p) {
      typedef ::RooQuasiRandomGenerator current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooQuasiRandomGenerator

//______________________________________________________________________________
void RooRandom::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooRandom.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooRandom::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooRandom::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooRandom(void *p) {
      delete ((::RooRandom*)p);
   }
   static void deleteArray_RooRandom(void *p) {
      delete [] ((::RooRandom*)p);
   }
   static void destruct_RooRandom(void *p) {
      typedef ::RooRandom current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooRandom

//______________________________________________________________________________
void RooRandomizeParamMCSModule::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooRandomizeParamMCSModule.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooRandomizeParamMCSModule::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooRandomizeParamMCSModule::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooRandomizeParamMCSModule(void *p) {
      return  p ? new(p) ::RooRandomizeParamMCSModule : new ::RooRandomizeParamMCSModule;
   }
   static void *newArray_RooRandomizeParamMCSModule(Long_t nElements, void *p) {
      return p ? new(p) ::RooRandomizeParamMCSModule[nElements] : new ::RooRandomizeParamMCSModule[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooRandomizeParamMCSModule(void *p) {
      delete ((::RooRandomizeParamMCSModule*)p);
   }
   static void deleteArray_RooRandomizeParamMCSModule(void *p) {
      delete [] ((::RooRandomizeParamMCSModule*)p);
   }
   static void destruct_RooRandomizeParamMCSModule(void *p) {
      typedef ::RooRandomizeParamMCSModule current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooRandomizeParamMCSModule

//______________________________________________________________________________
void RooRangeBinning::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooRangeBinning.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooRangeBinning::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooRangeBinning::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooRangeBinning(void *p) {
      return  p ? new(p) ::RooRangeBinning : new ::RooRangeBinning;
   }
   static void *newArray_RooRangeBinning(Long_t nElements, void *p) {
      return p ? new(p) ::RooRangeBinning[nElements] : new ::RooRangeBinning[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooRangeBinning(void *p) {
      delete ((::RooRangeBinning*)p);
   }
   static void deleteArray_RooRangeBinning(void *p) {
      delete [] ((::RooRangeBinning*)p);
   }
   static void destruct_RooRangeBinning(void *p) {
      typedef ::RooRangeBinning current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooRangeBinning

//______________________________________________________________________________
void RooRealAnalytic::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooRealAnalytic.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooRealAnalytic::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooRealAnalytic::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooRealAnalytic(void *p) {
      delete ((::RooRealAnalytic*)p);
   }
   static void deleteArray_RooRealAnalytic(void *p) {
      delete [] ((::RooRealAnalytic*)p);
   }
   static void destruct_RooRealAnalytic(void *p) {
      typedef ::RooRealAnalytic current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooRealAnalytic

//______________________________________________________________________________
void RooRealConstant::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooRealConstant.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooRealConstant::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooRealConstant::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooRealConstant(void *p) {
      return  p ? new(p) ::RooRealConstant : new ::RooRealConstant;
   }
   static void *newArray_RooRealConstant(Long_t nElements, void *p) {
      return p ? new(p) ::RooRealConstant[nElements] : new ::RooRealConstant[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooRealConstant(void *p) {
      delete ((::RooRealConstant*)p);
   }
   static void deleteArray_RooRealConstant(void *p) {
      delete [] ((::RooRealConstant*)p);
   }
   static void destruct_RooRealConstant(void *p) {
      typedef ::RooRealConstant current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooRealConstant

//______________________________________________________________________________
void RooRealIntegral::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooRealIntegral.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooRealIntegral::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooRealIntegral::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooRealIntegral(void *p) {
      return  p ? new(p) ::RooRealIntegral : new ::RooRealIntegral;
   }
   static void *newArray_RooRealIntegral(Long_t nElements, void *p) {
      return p ? new(p) ::RooRealIntegral[nElements] : new ::RooRealIntegral[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooRealIntegral(void *p) {
      delete ((::RooRealIntegral*)p);
   }
   static void deleteArray_RooRealIntegral(void *p) {
      delete [] ((::RooRealIntegral*)p);
   }
   static void destruct_RooRealIntegral(void *p) {
      typedef ::RooRealIntegral current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooRealIntegral

//______________________________________________________________________________
void RooRealMPFE::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooRealMPFE.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooRealMPFE::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooRealMPFE::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooRealMPFE(void *p) {
      delete ((::RooRealMPFE*)p);
   }
   static void deleteArray_RooRealMPFE(void *p) {
      delete [] ((::RooRealMPFE*)p);
   }
   static void destruct_RooRealMPFE(void *p) {
      typedef ::RooRealMPFE current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooRealMPFE

//______________________________________________________________________________
void RooScaledFunc::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooScaledFunc.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooScaledFunc::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooScaledFunc::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooScaledFunc(void *p) {
      delete ((::RooScaledFunc*)p);
   }
   static void deleteArray_RooScaledFunc(void *p) {
      delete [] ((::RooScaledFunc*)p);
   }
   static void destruct_RooScaledFunc(void *p) {
      typedef ::RooScaledFunc current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooScaledFunc

//______________________________________________________________________________
void RooSegmentedIntegrator1D::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooSegmentedIntegrator1D.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooSegmentedIntegrator1D::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooSegmentedIntegrator1D::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooSegmentedIntegrator1D(void *p) {
      return  p ? new(p) ::RooSegmentedIntegrator1D : new ::RooSegmentedIntegrator1D;
   }
   static void *newArray_RooSegmentedIntegrator1D(Long_t nElements, void *p) {
      return p ? new(p) ::RooSegmentedIntegrator1D[nElements] : new ::RooSegmentedIntegrator1D[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooSegmentedIntegrator1D(void *p) {
      delete ((::RooSegmentedIntegrator1D*)p);
   }
   static void deleteArray_RooSegmentedIntegrator1D(void *p) {
      delete [] ((::RooSegmentedIntegrator1D*)p);
   }
   static void destruct_RooSegmentedIntegrator1D(void *p) {
      typedef ::RooSegmentedIntegrator1D current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooSegmentedIntegrator1D

//______________________________________________________________________________
void RooSegmentedIntegrator2D::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooSegmentedIntegrator2D.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooSegmentedIntegrator2D::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooSegmentedIntegrator2D::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooSegmentedIntegrator2D(void *p) {
      return  p ? new(p) ::RooSegmentedIntegrator2D : new ::RooSegmentedIntegrator2D;
   }
   static void *newArray_RooSegmentedIntegrator2D(Long_t nElements, void *p) {
      return p ? new(p) ::RooSegmentedIntegrator2D[nElements] : new ::RooSegmentedIntegrator2D[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooSegmentedIntegrator2D(void *p) {
      delete ((::RooSegmentedIntegrator2D*)p);
   }
   static void deleteArray_RooSegmentedIntegrator2D(void *p) {
      delete [] ((::RooSegmentedIntegrator2D*)p);
   }
   static void destruct_RooSegmentedIntegrator2D(void *p) {
      typedef ::RooSegmentedIntegrator2D current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooSegmentedIntegrator2D

//______________________________________________________________________________
void RooSetPair::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooSetPair.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooSetPair::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooSetPair::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooSetPair(void *p) {
      return  p ? new(p) ::RooSetPair : new ::RooSetPair;
   }
   static void *newArray_RooSetPair(Long_t nElements, void *p) {
      return p ? new(p) ::RooSetPair[nElements] : new ::RooSetPair[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooSetPair(void *p) {
      delete ((::RooSetPair*)p);
   }
   static void deleteArray_RooSetPair(void *p) {
      delete [] ((::RooSetPair*)p);
   }
   static void destruct_RooSetPair(void *p) {
      typedef ::RooSetPair current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooSetPair

//______________________________________________________________________________
void RooSimGenContext::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooSimGenContext.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooSimGenContext::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooSimGenContext::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooSimGenContext(void *p) {
      delete ((::RooSimGenContext*)p);
   }
   static void deleteArray_RooSimGenContext(void *p) {
      delete [] ((::RooSimGenContext*)p);
   }
   static void destruct_RooSimGenContext(void *p) {
      typedef ::RooSimGenContext current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooSimGenContext

//______________________________________________________________________________
void RooSimSplitGenContext::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooSimSplitGenContext.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooSimSplitGenContext::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooSimSplitGenContext::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooSimSplitGenContext(void *p) {
      delete ((::RooSimSplitGenContext*)p);
   }
   static void deleteArray_RooSimSplitGenContext(void *p) {
      delete [] ((::RooSimSplitGenContext*)p);
   }
   static void destruct_RooSimSplitGenContext(void *p) {
      typedef ::RooSimSplitGenContext current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooSimSplitGenContext

//______________________________________________________________________________
void RooStreamParser::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooStreamParser.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooStreamParser::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooStreamParser::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooStreamParser(void *p) {
      delete ((::RooStreamParser*)p);
   }
   static void deleteArray_RooStreamParser(void *p) {
      delete [] ((::RooStreamParser*)p);
   }
   static void destruct_RooStreamParser(void *p) {
      typedef ::RooStreamParser current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooStreamParser

//______________________________________________________________________________
void RooStringVar::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooStringVar.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooStringVar::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooStringVar::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooStringVar(void *p) {
      return  p ? new(p) ::RooStringVar : new ::RooStringVar;
   }
   static void *newArray_RooStringVar(Long_t nElements, void *p) {
      return p ? new(p) ::RooStringVar[nElements] : new ::RooStringVar[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooStringVar(void *p) {
      delete ((::RooStringVar*)p);
   }
   static void deleteArray_RooStringVar(void *p) {
      delete [] ((::RooStringVar*)p);
   }
   static void destruct_RooStringVar(void *p) {
      typedef ::RooStringVar current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooStringVar

//______________________________________________________________________________
void RooSuperCategory::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooSuperCategory.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooSuperCategory::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooSuperCategory::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooSuperCategory(void *p) {
      return  p ? new(p) ::RooSuperCategory : new ::RooSuperCategory;
   }
   static void *newArray_RooSuperCategory(Long_t nElements, void *p) {
      return p ? new(p) ::RooSuperCategory[nElements] : new ::RooSuperCategory[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooSuperCategory(void *p) {
      delete ((::RooSuperCategory*)p);
   }
   static void deleteArray_RooSuperCategory(void *p) {
      delete [] ((::RooSuperCategory*)p);
   }
   static void destruct_RooSuperCategory(void *p) {
      typedef ::RooSuperCategory current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooSuperCategory

//______________________________________________________________________________
void RooThreshEntry::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooThreshEntry.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooThreshEntry::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooThreshEntry::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooThreshEntry(void *p) {
      return  p ? new(p) ::RooThreshEntry : new ::RooThreshEntry;
   }
   static void *newArray_RooThreshEntry(Long_t nElements, void *p) {
      return p ? new(p) ::RooThreshEntry[nElements] : new ::RooThreshEntry[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooThreshEntry(void *p) {
      delete ((::RooThreshEntry*)p);
   }
   static void deleteArray_RooThreshEntry(void *p) {
      delete [] ((::RooThreshEntry*)p);
   }
   static void destruct_RooThreshEntry(void *p) {
      typedef ::RooThreshEntry current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooThreshEntry

//______________________________________________________________________________
void RooThresholdCategory::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooThresholdCategory.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooThresholdCategory::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooThresholdCategory::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooThresholdCategory(void *p) {
      return  p ? new(p) ::RooThresholdCategory : new ::RooThresholdCategory;
   }
   static void *newArray_RooThresholdCategory(Long_t nElements, void *p) {
      return p ? new(p) ::RooThresholdCategory[nElements] : new ::RooThresholdCategory[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooThresholdCategory(void *p) {
      delete ((::RooThresholdCategory*)p);
   }
   static void deleteArray_RooThresholdCategory(void *p) {
      delete [] ((::RooThresholdCategory*)p);
   }
   static void destruct_RooThresholdCategory(void *p) {
      typedef ::RooThresholdCategory current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooThresholdCategory

//______________________________________________________________________________
void RooTObjWrap::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooTObjWrap.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooTObjWrap::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooTObjWrap::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooTObjWrap(void *p) {
      return  p ? new(p) ::RooTObjWrap : new ::RooTObjWrap;
   }
   static void *newArray_RooTObjWrap(Long_t nElements, void *p) {
      return p ? new(p) ::RooTObjWrap[nElements] : new ::RooTObjWrap[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooTObjWrap(void *p) {
      delete ((::RooTObjWrap*)p);
   }
   static void deleteArray_RooTObjWrap(void *p) {
      delete [] ((::RooTObjWrap*)p);
   }
   static void destruct_RooTObjWrap(void *p) {
      typedef ::RooTObjWrap current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooTObjWrap

//______________________________________________________________________________
void RooSimultaneous::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooSimultaneous.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooSimultaneous::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooSimultaneous::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooSimultaneous(void *p) {
      return  p ? new(p) ::RooSimultaneous : new ::RooSimultaneous;
   }
   static void *newArray_RooSimultaneous(Long_t nElements, void *p) {
      return p ? new(p) ::RooSimultaneous[nElements] : new ::RooSimultaneous[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooSimultaneous(void *p) {
      delete ((::RooSimultaneous*)p);
   }
   static void deleteArray_RooSimultaneous(void *p) {
      delete [] ((::RooSimultaneous*)p);
   }
   static void destruct_RooSimultaneous(void *p) {
      typedef ::RooSimultaneous current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooSimultaneous

//______________________________________________________________________________
void RooRealSumPdf::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooRealSumPdf.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooRealSumPdf::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooRealSumPdf::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooRealSumPdf(void *p) {
      return  p ? new(p) ::RooRealSumPdf : new ::RooRealSumPdf;
   }
   static void *newArray_RooRealSumPdf(Long_t nElements, void *p) {
      return p ? new(p) ::RooRealSumPdf[nElements] : new ::RooRealSumPdf[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooRealSumPdf(void *p) {
      delete ((::RooRealSumPdf*)p);
   }
   static void deleteArray_RooRealSumPdf(void *p) {
      delete [] ((::RooRealSumPdf*)p);
   }
   static void destruct_RooRealSumPdf(void *p) {
      typedef ::RooRealSumPdf current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooRealSumPdf

//______________________________________________________________________________
void RooProdPdf::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooProdPdf.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooProdPdf::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooProdPdf::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooProdPdf(void *p) {
      return  p ? new(p) ::RooProdPdf : new ::RooProdPdf;
   }
   static void *newArray_RooProdPdf(Long_t nElements, void *p) {
      return p ? new(p) ::RooProdPdf[nElements] : new ::RooProdPdf[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooProdPdf(void *p) {
      delete ((::RooProdPdf*)p);
   }
   static void deleteArray_RooProdPdf(void *p) {
      delete [] ((::RooProdPdf*)p);
   }
   static void destruct_RooProdPdf(void *p) {
      typedef ::RooProdPdf current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooProdPdf

//______________________________________________________________________________
void RooSimPdfBuilder::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooSimPdfBuilder.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooSimPdfBuilder::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooSimPdfBuilder::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooSimPdfBuilder(void *p) {
      delete ((::RooSimPdfBuilder*)p);
   }
   static void deleteArray_RooSimPdfBuilder(void *p) {
      delete [] ((::RooSimPdfBuilder*)p);
   }
   static void destruct_RooSimPdfBuilder(void *p) {
      typedef ::RooSimPdfBuilder current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooSimPdfBuilder

//______________________________________________________________________________
void RooTruthModel::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooTruthModel.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooTruthModel::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooTruthModel::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooTruthModel(void *p) {
      return  p ? new(p) ::RooTruthModel : new ::RooTruthModel;
   }
   static void *newArray_RooTruthModel(Long_t nElements, void *p) {
      return p ? new(p) ::RooTruthModel[nElements] : new ::RooTruthModel[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooTruthModel(void *p) {
      delete ((::RooTruthModel*)p);
   }
   static void deleteArray_RooTruthModel(void *p) {
      delete [] ((::RooTruthModel*)p);
   }
   static void destruct_RooTruthModel(void *p) {
      typedef ::RooTruthModel current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooTruthModel

//______________________________________________________________________________
void RooProjectedPdf::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooProjectedPdf.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooProjectedPdf::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooProjectedPdf::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooProjectedPdf(void *p) {
      return  p ? new(p) ::RooProjectedPdf : new ::RooProjectedPdf;
   }
   static void *newArray_RooProjectedPdf(Long_t nElements, void *p) {
      return p ? new(p) ::RooProjectedPdf[nElements] : new ::RooProjectedPdf[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooProjectedPdf(void *p) {
      delete ((::RooProjectedPdf*)p);
   }
   static void deleteArray_RooProjectedPdf(void *p) {
      delete [] ((::RooProjectedPdf*)p);
   }
   static void destruct_RooProjectedPdf(void *p) {
      typedef ::RooProjectedPdf current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooProjectedPdf

//______________________________________________________________________________
void RooExpensiveObjectCache::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooExpensiveObjectCache.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooExpensiveObjectCache::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooExpensiveObjectCache::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooExpensiveObjectCache(void *p) {
      return  p ? new(p) ::RooExpensiveObjectCache : new ::RooExpensiveObjectCache;
   }
   static void *newArray_RooExpensiveObjectCache(Long_t nElements, void *p) {
      return p ? new(p) ::RooExpensiveObjectCache[nElements] : new ::RooExpensiveObjectCache[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooExpensiveObjectCache(void *p) {
      delete ((::RooExpensiveObjectCache*)p);
   }
   static void deleteArray_RooExpensiveObjectCache(void *p) {
      delete [] ((::RooExpensiveObjectCache*)p);
   }
   static void destruct_RooExpensiveObjectCache(void *p) {
      typedef ::RooExpensiveObjectCache current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooExpensiveObjectCache

//______________________________________________________________________________
void RooExpensiveObjectCache::ExpensiveObject::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooExpensiveObjectCache::ExpensiveObject.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooExpensiveObjectCache::ExpensiveObject::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooExpensiveObjectCache::ExpensiveObject::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooExpensiveObjectCachecLcLExpensiveObject(void *p) {
      return  p ? new(p) ::RooExpensiveObjectCache::ExpensiveObject : new ::RooExpensiveObjectCache::ExpensiveObject;
   }
   static void *newArray_RooExpensiveObjectCachecLcLExpensiveObject(Long_t nElements, void *p) {
      return p ? new(p) ::RooExpensiveObjectCache::ExpensiveObject[nElements] : new ::RooExpensiveObjectCache::ExpensiveObject[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooExpensiveObjectCachecLcLExpensiveObject(void *p) {
      delete ((::RooExpensiveObjectCache::ExpensiveObject*)p);
   }
   static void deleteArray_RooExpensiveObjectCachecLcLExpensiveObject(void *p) {
      delete [] ((::RooExpensiveObjectCache::ExpensiveObject*)p);
   }
   static void destruct_RooExpensiveObjectCachecLcLExpensiveObject(void *p) {
      typedef ::RooExpensiveObjectCache::ExpensiveObject current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooExpensiveObjectCache::ExpensiveObject

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooWorkspace(void *p) {
      return  p ? new(p) ::RooWorkspace : new ::RooWorkspace;
   }
   static void *newArray_RooWorkspace(Long_t nElements, void *p) {
      return p ? new(p) ::RooWorkspace[nElements] : new ::RooWorkspace[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooWorkspace(void *p) {
      delete ((::RooWorkspace*)p);
   }
   static void deleteArray_RooWorkspace(void *p) {
      delete [] ((::RooWorkspace*)p);
   }
   static void destruct_RooWorkspace(void *p) {
      typedef ::RooWorkspace current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_RooWorkspace(TBuffer &buf, void *obj) {
      ((::RooWorkspace*)obj)->::RooWorkspace::Streamer(buf);
   }
} // end of namespace ROOT for class ::RooWorkspace

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooWorkspacecLcLCodeRepo(void *p) {
      return  p ? new(p) ::RooWorkspace::CodeRepo : new ::RooWorkspace::CodeRepo;
   }
   static void *newArray_RooWorkspacecLcLCodeRepo(Long_t nElements, void *p) {
      return p ? new(p) ::RooWorkspace::CodeRepo[nElements] : new ::RooWorkspace::CodeRepo[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooWorkspacecLcLCodeRepo(void *p) {
      delete ((::RooWorkspace::CodeRepo*)p);
   }
   static void deleteArray_RooWorkspacecLcLCodeRepo(void *p) {
      delete [] ((::RooWorkspace::CodeRepo*)p);
   }
   static void destruct_RooWorkspacecLcLCodeRepo(void *p) {
      typedef ::RooWorkspace::CodeRepo current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_RooWorkspacecLcLCodeRepo(TBuffer &buf, void *obj) {
      ((::RooWorkspace::CodeRepo*)obj)->::RooWorkspace::CodeRepo::Streamer(buf);
   }
} // end of namespace ROOT for class ::RooWorkspace::CodeRepo

//______________________________________________________________________________
void RooWorkspace::WSDir::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooWorkspace::WSDir.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooWorkspace::WSDir::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooWorkspace::WSDir::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooWorkspacecLcLWSDir(void *p) {
      delete ((::RooWorkspace::WSDir*)p);
   }
   static void deleteArray_RooWorkspacecLcLWSDir(void *p) {
      delete [] ((::RooWorkspace::WSDir*)p);
   }
   static void destruct_RooWorkspacecLcLWSDir(void *p) {
      typedef ::RooWorkspace::WSDir current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around the Reset function.
   static void reset_RooWorkspacecLcLWSDir(void *obj,TFileMergeInfo *info) {
      ((::RooWorkspace::WSDir*)obj)->ResetAfterMerge(info);
   }
} // end of namespace ROOT for class ::RooWorkspace::WSDir

//______________________________________________________________________________
void RooProfileLL::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooProfileLL.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooProfileLL::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooProfileLL::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooProfileLL(void *p) {
      return  p ? new(p) ::RooProfileLL : new ::RooProfileLL;
   }
   static void *newArray_RooProfileLL(Long_t nElements, void *p) {
      return p ? new(p) ::RooProfileLL[nElements] : new ::RooProfileLL[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooProfileLL(void *p) {
      delete ((::RooProfileLL*)p);
   }
   static void deleteArray_RooProfileLL(void *p) {
      delete [] ((::RooProfileLL*)p);
   }
   static void destruct_RooProfileLL(void *p) {
      typedef ::RooProfileLL current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooProfileLL

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooHistPdf(void *p) {
      return  p ? new(p) ::RooHistPdf : new ::RooHistPdf;
   }
   static void *newArray_RooHistPdf(Long_t nElements, void *p) {
      return p ? new(p) ::RooHistPdf[nElements] : new ::RooHistPdf[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooHistPdf(void *p) {
      delete ((::RooHistPdf*)p);
   }
   static void deleteArray_RooHistPdf(void *p) {
      delete [] ((::RooHistPdf*)p);
   }
   static void destruct_RooHistPdf(void *p) {
      typedef ::RooHistPdf current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_RooHistPdf(TBuffer &buf, void *obj) {
      ((::RooHistPdf*)obj)->::RooHistPdf::Streamer(buf);
   }
} // end of namespace ROOT for class ::RooHistPdf

//______________________________________________________________________________
void RooAbsCachedPdf::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooAbsCachedPdf.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooAbsCachedPdf::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooAbsCachedPdf::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooAbsCachedPdf(void *p) {
      delete ((::RooAbsCachedPdf*)p);
   }
   static void deleteArray_RooAbsCachedPdf(void *p) {
      delete [] ((::RooAbsCachedPdf*)p);
   }
   static void destruct_RooAbsCachedPdf(void *p) {
      typedef ::RooAbsCachedPdf current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooAbsCachedPdf

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooAbsCachedPdfcLcLPdfCacheElem(void *p) {
      delete ((::RooAbsCachedPdf::PdfCacheElem*)p);
   }
   static void deleteArray_RooAbsCachedPdfcLcLPdfCacheElem(void *p) {
      delete [] ((::RooAbsCachedPdf::PdfCacheElem*)p);
   }
   static void destruct_RooAbsCachedPdfcLcLPdfCacheElem(void *p) {
      typedef ::RooAbsCachedPdf::PdfCacheElem current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooAbsCachedPdf::PdfCacheElem

//______________________________________________________________________________
void RooAbsSelfCachedPdf::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooAbsSelfCachedPdf.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooAbsSelfCachedPdf::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooAbsSelfCachedPdf::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooAbsSelfCachedPdf(void *p) {
      delete ((::RooAbsSelfCachedPdf*)p);
   }
   static void deleteArray_RooAbsSelfCachedPdf(void *p) {
      delete [] ((::RooAbsSelfCachedPdf*)p);
   }
   static void destruct_RooAbsSelfCachedPdf(void *p) {
      typedef ::RooAbsSelfCachedPdf current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooAbsSelfCachedPdf

//______________________________________________________________________________
void RooCachedPdf::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooCachedPdf.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooCachedPdf::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooCachedPdf::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooCachedPdf(void *p) {
      return  p ? new(p) ::RooCachedPdf : new ::RooCachedPdf;
   }
   static void *newArray_RooCachedPdf(Long_t nElements, void *p) {
      return p ? new(p) ::RooCachedPdf[nElements] : new ::RooCachedPdf[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooCachedPdf(void *p) {
      delete ((::RooCachedPdf*)p);
   }
   static void deleteArray_RooCachedPdf(void *p) {
      delete [] ((::RooCachedPdf*)p);
   }
   static void destruct_RooCachedPdf(void *p) {
      typedef ::RooCachedPdf current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooCachedPdf

//______________________________________________________________________________
void RooFFTConvPdf::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooFFTConvPdf.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooFFTConvPdf::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooFFTConvPdf::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooFFTConvPdf(void *p) {
      return  p ? new(p) ::RooFFTConvPdf : new ::RooFFTConvPdf;
   }
   static void *newArray_RooFFTConvPdf(Long_t nElements, void *p) {
      return p ? new(p) ::RooFFTConvPdf[nElements] : new ::RooFFTConvPdf[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooFFTConvPdf(void *p) {
      delete ((::RooFFTConvPdf*)p);
   }
   static void deleteArray_RooFFTConvPdf(void *p) {
      delete [] ((::RooFFTConvPdf*)p);
   }
   static void destruct_RooFFTConvPdf(void *p) {
      typedef ::RooFFTConvPdf current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooFFTConvPdf

//______________________________________________________________________________
void RooDataHistSliceIter::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooDataHistSliceIter.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooDataHistSliceIter::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooDataHistSliceIter::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooDataHistSliceIter(void *p) {
      delete ((::RooDataHistSliceIter*)p);
   }
   static void deleteArray_RooDataHistSliceIter(void *p) {
      delete [] ((::RooDataHistSliceIter*)p);
   }
   static void destruct_RooDataHistSliceIter(void *p) {
      typedef ::RooDataHistSliceIter current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooDataHistSliceIter

//______________________________________________________________________________
void RooExtendedTerm::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooExtendedTerm.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooExtendedTerm::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooExtendedTerm::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooExtendedTerm(void *p) {
      return  p ? new(p) ::RooExtendedTerm : new ::RooExtendedTerm;
   }
   static void *newArray_RooExtendedTerm(Long_t nElements, void *p) {
      return p ? new(p) ::RooExtendedTerm[nElements] : new ::RooExtendedTerm[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooExtendedTerm(void *p) {
      delete ((::RooExtendedTerm*)p);
   }
   static void deleteArray_RooExtendedTerm(void *p) {
      delete [] ((::RooExtendedTerm*)p);
   }
   static void destruct_RooExtendedTerm(void *p) {
      typedef ::RooExtendedTerm current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooExtendedTerm

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooSentinel(void *p) {
      delete ((::RooSentinel*)p);
   }
   static void deleteArray_RooSentinel(void *p) {
      delete [] ((::RooSentinel*)p);
   }
   static void destruct_RooSentinel(void *p) {
      typedef ::RooSentinel current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooSentinel

//______________________________________________________________________________
void RooParamBinning::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooParamBinning.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooParamBinning::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooParamBinning::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooParamBinning(void *p) {
      return  p ? new(p) ::RooParamBinning : new ::RooParamBinning;
   }
   static void *newArray_RooParamBinning(Long_t nElements, void *p) {
      return p ? new(p) ::RooParamBinning[nElements] : new ::RooParamBinning[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooParamBinning(void *p) {
      delete ((::RooParamBinning*)p);
   }
   static void deleteArray_RooParamBinning(void *p) {
      delete [] ((::RooParamBinning*)p);
   }
   static void destruct_RooParamBinning(void *p) {
      typedef ::RooParamBinning current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooParamBinning

//______________________________________________________________________________
void RooConstraintSum::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooConstraintSum.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooConstraintSum::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooConstraintSum::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooConstraintSum(void *p) {
      return  p ? new(p) ::RooConstraintSum : new ::RooConstraintSum;
   }
   static void *newArray_RooConstraintSum(Long_t nElements, void *p) {
      return p ? new(p) ::RooConstraintSum[nElements] : new ::RooConstraintSum[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooConstraintSum(void *p) {
      delete ((::RooConstraintSum*)p);
   }
   static void deleteArray_RooConstraintSum(void *p) {
      delete [] ((::RooConstraintSum*)p);
   }
   static void destruct_RooConstraintSum(void *p) {
      typedef ::RooConstraintSum current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooConstraintSum

//______________________________________________________________________________
void RooRecursiveFraction::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooRecursiveFraction.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooRecursiveFraction::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooRecursiveFraction::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooRecursiveFraction(void *p) {
      return  p ? new(p) ::RooRecursiveFraction : new ::RooRecursiveFraction;
   }
   static void *newArray_RooRecursiveFraction(Long_t nElements, void *p) {
      return p ? new(p) ::RooRecursiveFraction[nElements] : new ::RooRecursiveFraction[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooRecursiveFraction(void *p) {
      delete ((::RooRecursiveFraction*)p);
   }
   static void deleteArray_RooRecursiveFraction(void *p) {
      delete [] ((::RooRecursiveFraction*)p);
   }
   static void destruct_RooRecursiveFraction(void *p) {
      typedef ::RooRecursiveFraction current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooRecursiveFraction

//______________________________________________________________________________
void RooDataWeightedAverage::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooDataWeightedAverage.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooDataWeightedAverage::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooDataWeightedAverage::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooDataWeightedAverage(void *p) {
      return  p ? new(p) ::RooDataWeightedAverage : new ::RooDataWeightedAverage;
   }
   static void *newArray_RooDataWeightedAverage(Long_t nElements, void *p) {
      return p ? new(p) ::RooDataWeightedAverage[nElements] : new ::RooDataWeightedAverage[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooDataWeightedAverage(void *p) {
      delete ((::RooDataWeightedAverage*)p);
   }
   static void deleteArray_RooDataWeightedAverage(void *p) {
      delete [] ((::RooDataWeightedAverage*)p);
   }
   static void destruct_RooDataWeightedAverage(void *p) {
      typedef ::RooDataWeightedAverage current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooDataWeightedAverage

//______________________________________________________________________________
void RooSimWSTool::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooSimWSTool.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooSimWSTool::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooSimWSTool::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooSimWSTool(void *p) {
      delete ((::RooSimWSTool*)p);
   }
   static void deleteArray_RooSimWSTool(void *p) {
      delete [] ((::RooSimWSTool*)p);
   }
   static void destruct_RooSimWSTool(void *p) {
      typedef ::RooSimWSTool current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooSimWSTool

//______________________________________________________________________________
void RooSimWSTool::SplitRule::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooSimWSTool::SplitRule.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooSimWSTool::SplitRule::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooSimWSTool::SplitRule::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooSimWSToolcLcLSplitRule(void *p) {
      return  p ? new(p) ::RooSimWSTool::SplitRule : new ::RooSimWSTool::SplitRule;
   }
   static void *newArray_RooSimWSToolcLcLSplitRule(Long_t nElements, void *p) {
      return p ? new(p) ::RooSimWSTool::SplitRule[nElements] : new ::RooSimWSTool::SplitRule[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooSimWSToolcLcLSplitRule(void *p) {
      delete ((::RooSimWSTool::SplitRule*)p);
   }
   static void deleteArray_RooSimWSToolcLcLSplitRule(void *p) {
      delete [] ((::RooSimWSTool::SplitRule*)p);
   }
   static void destruct_RooSimWSToolcLcLSplitRule(void *p) {
      typedef ::RooSimWSTool::SplitRule current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooSimWSTool::SplitRule

//______________________________________________________________________________
void RooSimWSTool::BuildConfig::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooSimWSTool::BuildConfig.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooSimWSTool::BuildConfig::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooSimWSTool::BuildConfig::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooSimWSToolcLcLBuildConfig(void *p) {
      delete ((::RooSimWSTool::BuildConfig*)p);
   }
   static void deleteArray_RooSimWSToolcLcLBuildConfig(void *p) {
      delete [] ((::RooSimWSTool::BuildConfig*)p);
   }
   static void destruct_RooSimWSToolcLcLBuildConfig(void *p) {
      typedef ::RooSimWSTool::BuildConfig current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooSimWSTool::BuildConfig

//______________________________________________________________________________
void RooSimWSTool::MultiBuildConfig::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooSimWSTool::MultiBuildConfig.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooSimWSTool::MultiBuildConfig::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooSimWSTool::MultiBuildConfig::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooSimWSToolcLcLMultiBuildConfig(void *p) {
      delete ((::RooSimWSTool::MultiBuildConfig*)p);
   }
   static void deleteArray_RooSimWSToolcLcLMultiBuildConfig(void *p) {
      delete [] ((::RooSimWSTool::MultiBuildConfig*)p);
   }
   static void destruct_RooSimWSToolcLcLMultiBuildConfig(void *p) {
      typedef ::RooSimWSTool::MultiBuildConfig current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooSimWSTool::MultiBuildConfig

//______________________________________________________________________________
void RooSimWSTool::ObjSplitRule::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooSimWSTool::ObjSplitRule.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooSimWSTool::ObjSplitRule::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooSimWSTool::ObjSplitRule::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooSimWSToolcLcLObjSplitRule(void *p) {
      return  p ? new(p) ::RooSimWSTool::ObjSplitRule : new ::RooSimWSTool::ObjSplitRule;
   }
   static void *newArray_RooSimWSToolcLcLObjSplitRule(Long_t nElements, void *p) {
      return p ? new(p) ::RooSimWSTool::ObjSplitRule[nElements] : new ::RooSimWSTool::ObjSplitRule[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooSimWSToolcLcLObjSplitRule(void *p) {
      delete ((::RooSimWSTool::ObjSplitRule*)p);
   }
   static void deleteArray_RooSimWSToolcLcLObjSplitRule(void *p) {
      delete [] ((::RooSimWSTool::ObjSplitRule*)p);
   }
   static void destruct_RooSimWSToolcLcLObjSplitRule(void *p) {
      typedef ::RooSimWSTool::ObjSplitRule current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooSimWSTool::ObjSplitRule

//______________________________________________________________________________
void RooSimWSTool::ObjBuildConfig::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooSimWSTool::ObjBuildConfig.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooSimWSTool::ObjBuildConfig::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooSimWSTool::ObjBuildConfig::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooSimWSToolcLcLObjBuildConfig(void *p) {
      return  p ? new(p) ::RooSimWSTool::ObjBuildConfig : new ::RooSimWSTool::ObjBuildConfig;
   }
   static void *newArray_RooSimWSToolcLcLObjBuildConfig(Long_t nElements, void *p) {
      return p ? new(p) ::RooSimWSTool::ObjBuildConfig[nElements] : new ::RooSimWSTool::ObjBuildConfig[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooSimWSToolcLcLObjBuildConfig(void *p) {
      delete ((::RooSimWSTool::ObjBuildConfig*)p);
   }
   static void deleteArray_RooSimWSToolcLcLObjBuildConfig(void *p) {
      delete [] ((::RooSimWSTool::ObjBuildConfig*)p);
   }
   static void destruct_RooSimWSToolcLcLObjBuildConfig(void *p) {
      typedef ::RooSimWSTool::ObjBuildConfig current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooSimWSTool::ObjBuildConfig

//______________________________________________________________________________
void RooFracRemainder::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooFracRemainder.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooFracRemainder::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooFracRemainder::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooFracRemainder(void *p) {
      return  p ? new(p) ::RooFracRemainder : new ::RooFracRemainder;
   }
   static void *newArray_RooFracRemainder(Long_t nElements, void *p) {
      return p ? new(p) ::RooFracRemainder[nElements] : new ::RooFracRemainder[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooFracRemainder(void *p) {
      delete ((::RooFracRemainder*)p);
   }
   static void deleteArray_RooFracRemainder(void *p) {
      delete [] ((::RooFracRemainder*)p);
   }
   static void destruct_RooFracRemainder(void *p) {
      typedef ::RooFracRemainder current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooFracRemainder

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooHistFunc(void *p) {
      return  p ? new(p) ::RooHistFunc : new ::RooHistFunc;
   }
   static void *newArray_RooHistFunc(Long_t nElements, void *p) {
      return p ? new(p) ::RooHistFunc[nElements] : new ::RooHistFunc[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooHistFunc(void *p) {
      delete ((::RooHistFunc*)p);
   }
   static void deleteArray_RooHistFunc(void *p) {
      delete [] ((::RooHistFunc*)p);
   }
   static void destruct_RooHistFunc(void *p) {
      typedef ::RooHistFunc current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_RooHistFunc(TBuffer &buf, void *obj) {
      ((::RooHistFunc*)obj)->::RooHistFunc::Streamer(buf);
   }
} // end of namespace ROOT for class ::RooHistFunc

//______________________________________________________________________________
void RooAbsCachedReal::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooAbsCachedReal.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooAbsCachedReal::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooAbsCachedReal::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooAbsCachedReal(void *p) {
      delete ((::RooAbsCachedReal*)p);
   }
   static void deleteArray_RooAbsCachedReal(void *p) {
      delete [] ((::RooAbsCachedReal*)p);
   }
   static void destruct_RooAbsCachedReal(void *p) {
      typedef ::RooAbsCachedReal current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooAbsCachedReal

//______________________________________________________________________________
void RooAbsSelfCachedReal::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooAbsSelfCachedReal.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooAbsSelfCachedReal::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooAbsSelfCachedReal::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooAbsSelfCachedReal(void *p) {
      delete ((::RooAbsSelfCachedReal*)p);
   }
   static void deleteArray_RooAbsSelfCachedReal(void *p) {
      delete [] ((::RooAbsSelfCachedReal*)p);
   }
   static void destruct_RooAbsSelfCachedReal(void *p) {
      typedef ::RooAbsSelfCachedReal current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooAbsSelfCachedReal

//______________________________________________________________________________
void RooCachedReal::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooCachedReal.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooCachedReal::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooCachedReal::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooCachedReal(void *p) {
      return  p ? new(p) ::RooCachedReal : new ::RooCachedReal;
   }
   static void *newArray_RooCachedReal(Long_t nElements, void *p) {
      return p ? new(p) ::RooCachedReal[nElements] : new ::RooCachedReal[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooCachedReal(void *p) {
      delete ((::RooCachedReal*)p);
   }
   static void deleteArray_RooCachedReal(void *p) {
      delete [] ((::RooCachedReal*)p);
   }
   static void destruct_RooCachedReal(void *p) {
      typedef ::RooCachedReal current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooCachedReal

//______________________________________________________________________________
void RooNumRunningInt::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooNumRunningInt.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooNumRunningInt::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooNumRunningInt::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooNumRunningInt(void *p) {
      delete ((::RooNumRunningInt*)p);
   }
   static void deleteArray_RooNumRunningInt(void *p) {
      delete [] ((::RooNumRunningInt*)p);
   }
   static void destruct_RooNumRunningInt(void *p) {
      typedef ::RooNumRunningInt current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooNumRunningInt

//______________________________________________________________________________
void RooNumCdf::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooNumCdf.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooNumCdf::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooNumCdf::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooNumCdf(void *p) {
      delete ((::RooNumCdf*)p);
   }
   static void deleteArray_RooNumCdf(void *p) {
      delete [] ((::RooNumCdf*)p);
   }
   static void destruct_RooNumCdf(void *p) {
      typedef ::RooNumCdf current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooNumCdf

//______________________________________________________________________________
void RooChangeTracker::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooChangeTracker.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooChangeTracker::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooChangeTracker::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooChangeTracker(void *p) {
      return  p ? new(p) ::RooChangeTracker : new ::RooChangeTracker;
   }
   static void *newArray_RooChangeTracker(Long_t nElements, void *p) {
      return p ? new(p) ::RooChangeTracker[nElements] : new ::RooChangeTracker[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooChangeTracker(void *p) {
      delete ((::RooChangeTracker*)p);
   }
   static void deleteArray_RooChangeTracker(void *p) {
      delete [] ((::RooChangeTracker*)p);
   }
   static void destruct_RooChangeTracker(void *p) {
      typedef ::RooChangeTracker current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooChangeTracker

//______________________________________________________________________________
void RooBinningCategory::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooBinningCategory.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooBinningCategory::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooBinningCategory::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooBinningCategory(void *p) {
      return  p ? new(p) ::RooBinningCategory : new ::RooBinningCategory;
   }
   static void *newArray_RooBinningCategory(Long_t nElements, void *p) {
      return p ? new(p) ::RooBinningCategory[nElements] : new ::RooBinningCategory[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooBinningCategory(void *p) {
      delete ((::RooBinningCategory*)p);
   }
   static void deleteArray_RooBinningCategory(void *p) {
      delete [] ((::RooBinningCategory*)p);
   }
   static void destruct_RooBinningCategory(void *p) {
      typedef ::RooBinningCategory current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooBinningCategory

//______________________________________________________________________________
void RooTFoamBinding::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooTFoamBinding.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooTFoamBinding::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooTFoamBinding::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooTFoamBinding(void *p) {
      delete ((::RooTFoamBinding*)p);
   }
   static void deleteArray_RooTFoamBinding(void *p) {
      delete [] ((::RooTFoamBinding*)p);
   }
   static void destruct_RooTFoamBinding(void *p) {
      typedef ::RooTFoamBinding current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooTFoamBinding

//______________________________________________________________________________
void RooFunctor::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooFunctor.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooFunctor::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooFunctor::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooFunctor(void *p) {
      delete ((::RooFunctor*)p);
   }
   static void deleteArray_RooFunctor(void *p) {
      delete [] ((::RooFunctor*)p);
   }
   static void destruct_RooFunctor(void *p) {
      typedef ::RooFunctor current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooFunctor

//______________________________________________________________________________
void RooDerivative::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooDerivative.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooDerivative::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooDerivative::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooDerivative(void *p) {
      return  p ? new(p) ::RooDerivative : new ::RooDerivative;
   }
   static void *newArray_RooDerivative(Long_t nElements, void *p) {
      return p ? new(p) ::RooDerivative[nElements] : new ::RooDerivative[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooDerivative(void *p) {
      delete ((::RooDerivative*)p);
   }
   static void deleteArray_RooDerivative(void *p) {
      delete [] ((::RooDerivative*)p);
   }
   static void destruct_RooDerivative(void *p) {
      typedef ::RooDerivative current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooDerivative

//______________________________________________________________________________
void RooGenFunction::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooGenFunction.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooGenFunction::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooGenFunction::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooGenFunction(void *p) {
      delete ((::RooGenFunction*)p);
   }
   static void deleteArray_RooGenFunction(void *p) {
      delete [] ((::RooGenFunction*)p);
   }
   static void destruct_RooGenFunction(void *p) {
      typedef ::RooGenFunction current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooGenFunction

//______________________________________________________________________________
void RooMultiGenFunction::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooMultiGenFunction.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooMultiGenFunction::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooMultiGenFunction::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooMultiGenFunction(void *p) {
      delete ((::RooMultiGenFunction*)p);
   }
   static void deleteArray_RooMultiGenFunction(void *p) {
      delete [] ((::RooMultiGenFunction*)p);
   }
   static void destruct_RooMultiGenFunction(void *p) {
      typedef ::RooMultiGenFunction current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooMultiGenFunction

//______________________________________________________________________________
void RooAdaptiveIntegratorND::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooAdaptiveIntegratorND.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooAdaptiveIntegratorND::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooAdaptiveIntegratorND::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooAdaptiveIntegratorND(void *p) {
      return  p ? new(p) ::RooAdaptiveIntegratorND : new ::RooAdaptiveIntegratorND;
   }
   static void *newArray_RooAdaptiveIntegratorND(Long_t nElements, void *p) {
      return p ? new(p) ::RooAdaptiveIntegratorND[nElements] : new ::RooAdaptiveIntegratorND[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooAdaptiveIntegratorND(void *p) {
      delete ((::RooAdaptiveIntegratorND*)p);
   }
   static void deleteArray_RooAdaptiveIntegratorND(void *p) {
      delete [] ((::RooAdaptiveIntegratorND*)p);
   }
   static void destruct_RooAdaptiveIntegratorND(void *p) {
      typedef ::RooAdaptiveIntegratorND current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooAdaptiveIntegratorND

//______________________________________________________________________________
void RooFoamGenerator::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooFoamGenerator.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooFoamGenerator::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooFoamGenerator::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooFoamGenerator(void *p) {
      return  p ? new(p) ::RooFoamGenerator : new ::RooFoamGenerator;
   }
   static void *newArray_RooFoamGenerator(Long_t nElements, void *p) {
      return p ? new(p) ::RooFoamGenerator[nElements] : new ::RooFoamGenerator[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooFoamGenerator(void *p) {
      delete ((::RooFoamGenerator*)p);
   }
   static void deleteArray_RooFoamGenerator(void *p) {
      delete [] ((::RooFoamGenerator*)p);
   }
   static void destruct_RooFoamGenerator(void *p) {
      typedef ::RooFoamGenerator current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooFoamGenerator

//______________________________________________________________________________
void RooNumGenConfig::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooNumGenConfig.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooNumGenConfig::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooNumGenConfig::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooNumGenConfig(void *p) {
      return  p ? new(p) ::RooNumGenConfig : new ::RooNumGenConfig;
   }
   static void *newArray_RooNumGenConfig(Long_t nElements, void *p) {
      return p ? new(p) ::RooNumGenConfig[nElements] : new ::RooNumGenConfig[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooNumGenConfig(void *p) {
      delete ((::RooNumGenConfig*)p);
   }
   static void deleteArray_RooNumGenConfig(void *p) {
      delete [] ((::RooNumGenConfig*)p);
   }
   static void destruct_RooNumGenConfig(void *p) {
      typedef ::RooNumGenConfig current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooNumGenConfig

//______________________________________________________________________________
void RooNumGenFactory::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooNumGenFactory.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooNumGenFactory::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooNumGenFactory::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooNumGenFactory(void *p) {
      delete ((::RooNumGenFactory*)p);
   }
   static void deleteArray_RooNumGenFactory(void *p) {
      delete [] ((::RooNumGenFactory*)p);
   }
   static void destruct_RooNumGenFactory(void *p) {
      typedef ::RooNumGenFactory current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooNumGenFactory

//______________________________________________________________________________
void RooMultiVarGaussian::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooMultiVarGaussian.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooMultiVarGaussian::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooMultiVarGaussian::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooMultiVarGaussian(void *p) {
      return  p ? new(p) ::RooMultiVarGaussian : new ::RooMultiVarGaussian;
   }
   static void *newArray_RooMultiVarGaussian(Long_t nElements, void *p) {
      return p ? new(p) ::RooMultiVarGaussian[nElements] : new ::RooMultiVarGaussian[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooMultiVarGaussian(void *p) {
      delete ((::RooMultiVarGaussian*)p);
   }
   static void deleteArray_RooMultiVarGaussian(void *p) {
      delete [] ((::RooMultiVarGaussian*)p);
   }
   static void destruct_RooMultiVarGaussian(void *p) {
      typedef ::RooMultiVarGaussian current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooMultiVarGaussian

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooMultiVarGaussiancLcLAnaIntData(void *p) {
      return  p ? new(p) ::RooMultiVarGaussian::AnaIntData : new ::RooMultiVarGaussian::AnaIntData;
   }
   static void *newArray_RooMultiVarGaussiancLcLAnaIntData(Long_t nElements, void *p) {
      return p ? new(p) ::RooMultiVarGaussian::AnaIntData[nElements] : new ::RooMultiVarGaussian::AnaIntData[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooMultiVarGaussiancLcLAnaIntData(void *p) {
      delete ((::RooMultiVarGaussian::AnaIntData*)p);
   }
   static void deleteArray_RooMultiVarGaussiancLcLAnaIntData(void *p) {
      delete [] ((::RooMultiVarGaussian::AnaIntData*)p);
   }
   static void destruct_RooMultiVarGaussiancLcLAnaIntData(void *p) {
      typedef ::RooMultiVarGaussian::AnaIntData current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooMultiVarGaussian::AnaIntData

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooMultiVarGaussiancLcLGenData(void *p) {
      return  p ? new(p) ::RooMultiVarGaussian::GenData : new ::RooMultiVarGaussian::GenData;
   }
   static void *newArray_RooMultiVarGaussiancLcLGenData(Long_t nElements, void *p) {
      return p ? new(p) ::RooMultiVarGaussian::GenData[nElements] : new ::RooMultiVarGaussian::GenData[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooMultiVarGaussiancLcLGenData(void *p) {
      delete ((::RooMultiVarGaussian::GenData*)p);
   }
   static void deleteArray_RooMultiVarGaussiancLcLGenData(void *p) {
      delete [] ((::RooMultiVarGaussian::GenData*)p);
   }
   static void destruct_RooMultiVarGaussiancLcLGenData(void *p) {
      typedef ::RooMultiVarGaussian::GenData current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooMultiVarGaussian::GenData

//______________________________________________________________________________
void RooXYChi2Var::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooXYChi2Var.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooXYChi2Var::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooXYChi2Var::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooXYChi2Var(void *p) {
      return  p ? new(p) ::RooXYChi2Var : new ::RooXYChi2Var;
   }
   static void *newArray_RooXYChi2Var(Long_t nElements, void *p) {
      return p ? new(p) ::RooXYChi2Var[nElements] : new ::RooXYChi2Var[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooXYChi2Var(void *p) {
      delete ((::RooXYChi2Var*)p);
   }
   static void deleteArray_RooXYChi2Var(void *p) {
      delete [] ((::RooXYChi2Var*)p);
   }
   static void destruct_RooXYChi2Var(void *p) {
      typedef ::RooXYChi2Var current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooXYChi2Var

//______________________________________________________________________________
void RooAbsDataStore::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooAbsDataStore.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooAbsDataStore::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooAbsDataStore::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooAbsDataStore(void *p) {
      delete ((::RooAbsDataStore*)p);
   }
   static void deleteArray_RooAbsDataStore(void *p) {
      delete [] ((::RooAbsDataStore*)p);
   }
   static void destruct_RooAbsDataStore(void *p) {
      typedef ::RooAbsDataStore current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooAbsDataStore

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooTreeDataStore(void *p) {
      return  p ? new(p) ::RooTreeDataStore : new ::RooTreeDataStore;
   }
   static void *newArray_RooTreeDataStore(Long_t nElements, void *p) {
      return p ? new(p) ::RooTreeDataStore[nElements] : new ::RooTreeDataStore[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooTreeDataStore(void *p) {
      delete ((::RooTreeDataStore*)p);
   }
   static void deleteArray_RooTreeDataStore(void *p) {
      delete [] ((::RooTreeDataStore*)p);
   }
   static void destruct_RooTreeDataStore(void *p) {
      typedef ::RooTreeDataStore current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_RooTreeDataStore(TBuffer &buf, void *obj) {
      ((::RooTreeDataStore*)obj)->::RooTreeDataStore::Streamer(buf);
   }
} // end of namespace ROOT for class ::RooTreeDataStore

//______________________________________________________________________________
void RooTreeData::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooTreeData.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooTreeData::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooTreeData::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooTreeData(void *p) {
      delete ((::RooTreeData*)p);
   }
   static void deleteArray_RooTreeData(void *p) {
      delete [] ((::RooTreeData*)p);
   }
   static void destruct_RooTreeData(void *p) {
      typedef ::RooTreeData current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooTreeData

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooMinimizerFcn(void *p) {
      delete ((::RooMinimizerFcn*)p);
   }
   static void deleteArray_RooMinimizerFcn(void *p) {
      delete [] ((::RooMinimizerFcn*)p);
   }
   static void destruct_RooMinimizerFcn(void *p) {
      typedef ::RooMinimizerFcn current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooMinimizerFcn

//______________________________________________________________________________
void RooMinimizer::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooMinimizer.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooMinimizer::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooMinimizer::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooMinimizer(void *p) {
      delete ((::RooMinimizer*)p);
   }
   static void deleteArray_RooMinimizer(void *p) {
      delete [] ((::RooMinimizer*)p);
   }
   static void destruct_RooMinimizer(void *p) {
      typedef ::RooMinimizer current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooMinimizer

//______________________________________________________________________________
void RooAbsMoment::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooAbsMoment.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooAbsMoment::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooAbsMoment::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooAbsMoment(void *p) {
      delete ((::RooAbsMoment*)p);
   }
   static void deleteArray_RooAbsMoment(void *p) {
      delete [] ((::RooAbsMoment*)p);
   }
   static void destruct_RooAbsMoment(void *p) {
      typedef ::RooAbsMoment current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooAbsMoment

//______________________________________________________________________________
void RooMoment::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooMoment.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooMoment::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooMoment::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooMoment(void *p) {
      return  p ? new(p) ::RooMoment : new ::RooMoment;
   }
   static void *newArray_RooMoment(Long_t nElements, void *p) {
      return p ? new(p) ::RooMoment[nElements] : new ::RooMoment[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooMoment(void *p) {
      delete ((::RooMoment*)p);
   }
   static void deleteArray_RooMoment(void *p) {
      delete [] ((::RooMoment*)p);
   }
   static void destruct_RooMoment(void *p) {
      typedef ::RooMoment current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooMoment

//______________________________________________________________________________
void RooStudyPackage::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooStudyPackage.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooStudyPackage::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooStudyPackage::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooStudyPackage(void *p) {
      return  p ? new(p) ::RooStudyPackage : new ::RooStudyPackage;
   }
   static void *newArray_RooStudyPackage(Long_t nElements, void *p) {
      return p ? new(p) ::RooStudyPackage[nElements] : new ::RooStudyPackage[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooStudyPackage(void *p) {
      delete ((::RooStudyPackage*)p);
   }
   static void deleteArray_RooStudyPackage(void *p) {
      delete [] ((::RooStudyPackage*)p);
   }
   static void destruct_RooStudyPackage(void *p) {
      typedef ::RooStudyPackage current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooStudyPackage

//______________________________________________________________________________
void RooStudyManager::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooStudyManager.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooStudyManager::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooStudyManager::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooStudyManager(void *p) {
      delete ((::RooStudyManager*)p);
   }
   static void deleteArray_RooStudyManager(void *p) {
      delete [] ((::RooStudyManager*)p);
   }
   static void destruct_RooStudyManager(void *p) {
      typedef ::RooStudyManager current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooStudyManager

//______________________________________________________________________________
void RooAbsStudy::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooAbsStudy.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooAbsStudy::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooAbsStudy::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooAbsStudy(void *p) {
      delete ((::RooAbsStudy*)p);
   }
   static void deleteArray_RooAbsStudy(void *p) {
      delete [] ((::RooAbsStudy*)p);
   }
   static void destruct_RooAbsStudy(void *p) {
      typedef ::RooAbsStudy current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooAbsStudy

//______________________________________________________________________________
void RooGenFitStudy::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooGenFitStudy.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooGenFitStudy::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooGenFitStudy::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooGenFitStudy(void *p) {
      return  p ? new(p) ::RooGenFitStudy : new ::RooGenFitStudy;
   }
   static void *newArray_RooGenFitStudy(Long_t nElements, void *p) {
      return p ? new(p) ::RooGenFitStudy[nElements] : new ::RooGenFitStudy[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooGenFitStudy(void *p) {
      delete ((::RooGenFitStudy*)p);
   }
   static void deleteArray_RooGenFitStudy(void *p) {
      delete [] ((::RooGenFitStudy*)p);
   }
   static void destruct_RooGenFitStudy(void *p) {
      typedef ::RooGenFitStudy current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooGenFitStudy

//______________________________________________________________________________
void RooProofDriverSelector::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooProofDriverSelector.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooProofDriverSelector::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooProofDriverSelector::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooProofDriverSelector(void *p) {
      return  p ? new(p) ::RooProofDriverSelector : new ::RooProofDriverSelector;
   }
   static void *newArray_RooProofDriverSelector(Long_t nElements, void *p) {
      return p ? new(p) ::RooProofDriverSelector[nElements] : new ::RooProofDriverSelector[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooProofDriverSelector(void *p) {
      delete ((::RooProofDriverSelector*)p);
   }
   static void deleteArray_RooProofDriverSelector(void *p) {
      delete [] ((::RooProofDriverSelector*)p);
   }
   static void destruct_RooProofDriverSelector(void *p) {
      typedef ::RooProofDriverSelector current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooProofDriverSelector

//______________________________________________________________________________
void RooCompositeDataStore::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooCompositeDataStore.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooCompositeDataStore::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooCompositeDataStore::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooCompositeDataStore(void *p) {
      return  p ? new(p) ::RooCompositeDataStore : new ::RooCompositeDataStore;
   }
   static void *newArray_RooCompositeDataStore(Long_t nElements, void *p) {
      return p ? new(p) ::RooCompositeDataStore[nElements] : new ::RooCompositeDataStore[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooCompositeDataStore(void *p) {
      delete ((::RooCompositeDataStore*)p);
   }
   static void deleteArray_RooCompositeDataStore(void *p) {
      delete [] ((::RooCompositeDataStore*)p);
   }
   static void destruct_RooCompositeDataStore(void *p) {
      typedef ::RooCompositeDataStore current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooCompositeDataStore

//______________________________________________________________________________
void RooRangeBoolean::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooRangeBoolean.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooRangeBoolean::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooRangeBoolean::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooRangeBoolean(void *p) {
      return  p ? new(p) ::RooRangeBoolean : new ::RooRangeBoolean;
   }
   static void *newArray_RooRangeBoolean(Long_t nElements, void *p) {
      return p ? new(p) ::RooRangeBoolean[nElements] : new ::RooRangeBoolean[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooRangeBoolean(void *p) {
      delete ((::RooRangeBoolean*)p);
   }
   static void deleteArray_RooRangeBoolean(void *p) {
      delete [] ((::RooRangeBoolean*)p);
   }
   static void destruct_RooRangeBoolean(void *p) {
      typedef ::RooRangeBoolean current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooRangeBoolean

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooVectorDataStore(void *p) {
      return  p ? new(p) ::RooVectorDataStore : new ::RooVectorDataStore;
   }
   static void *newArray_RooVectorDataStore(Long_t nElements, void *p) {
      return p ? new(p) ::RooVectorDataStore[nElements] : new ::RooVectorDataStore[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooVectorDataStore(void *p) {
      delete ((::RooVectorDataStore*)p);
   }
   static void deleteArray_RooVectorDataStore(void *p) {
      delete [] ((::RooVectorDataStore*)p);
   }
   static void destruct_RooVectorDataStore(void *p) {
      typedef ::RooVectorDataStore current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_RooVectorDataStore(TBuffer &buf, void *obj) {
      ((::RooVectorDataStore*)obj)->::RooVectorDataStore::Streamer(buf);
   }
} // end of namespace ROOT for class ::RooVectorDataStore

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooVectorDataStorecLcLRealVector(void *p) {
      return  p ? new(p) ::RooVectorDataStore::RealVector : new ::RooVectorDataStore::RealVector;
   }
   static void *newArray_RooVectorDataStorecLcLRealVector(Long_t nElements, void *p) {
      return p ? new(p) ::RooVectorDataStore::RealVector[nElements] : new ::RooVectorDataStore::RealVector[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooVectorDataStorecLcLRealVector(void *p) {
      delete ((::RooVectorDataStore::RealVector*)p);
   }
   static void deleteArray_RooVectorDataStorecLcLRealVector(void *p) {
      delete [] ((::RooVectorDataStore::RealVector*)p);
   }
   static void destruct_RooVectorDataStorecLcLRealVector(void *p) {
      typedef ::RooVectorDataStore::RealVector current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_RooVectorDataStorecLcLRealVector(TBuffer &buf, void *obj) {
      ((::RooVectorDataStore::RealVector*)obj)->::RooVectorDataStore::RealVector::Streamer(buf);
   }
} // end of namespace ROOT for class ::RooVectorDataStore::RealVector

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooVectorDataStorecLcLRealFullVector(void *p) {
      return  p ? new(p) ::RooVectorDataStore::RealFullVector : new ::RooVectorDataStore::RealFullVector;
   }
   static void *newArray_RooVectorDataStorecLcLRealFullVector(Long_t nElements, void *p) {
      return p ? new(p) ::RooVectorDataStore::RealFullVector[nElements] : new ::RooVectorDataStore::RealFullVector[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooVectorDataStorecLcLRealFullVector(void *p) {
      delete ((::RooVectorDataStore::RealFullVector*)p);
   }
   static void deleteArray_RooVectorDataStorecLcLRealFullVector(void *p) {
      delete [] ((::RooVectorDataStore::RealFullVector*)p);
   }
   static void destruct_RooVectorDataStorecLcLRealFullVector(void *p) {
      typedef ::RooVectorDataStore::RealFullVector current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_RooVectorDataStorecLcLRealFullVector(TBuffer &buf, void *obj) {
      ((::RooVectorDataStore::RealFullVector*)obj)->::RooVectorDataStore::RealFullVector::Streamer(buf);
   }
} // end of namespace ROOT for class ::RooVectorDataStore::RealFullVector

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooVectorDataStorecLcLCatVector(void *p) {
      return  p ? new(p) ::RooVectorDataStore::CatVector : new ::RooVectorDataStore::CatVector;
   }
   static void *newArray_RooVectorDataStorecLcLCatVector(Long_t nElements, void *p) {
      return p ? new(p) ::RooVectorDataStore::CatVector[nElements] : new ::RooVectorDataStore::CatVector[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooVectorDataStorecLcLCatVector(void *p) {
      delete ((::RooVectorDataStore::CatVector*)p);
   }
   static void deleteArray_RooVectorDataStorecLcLCatVector(void *p) {
      delete [] ((::RooVectorDataStore::CatVector*)p);
   }
   static void destruct_RooVectorDataStorecLcLCatVector(void *p) {
      typedef ::RooVectorDataStore::CatVector current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_RooVectorDataStorecLcLCatVector(TBuffer &buf, void *obj) {
      ((::RooVectorDataStore::CatVector*)obj)->::RooVectorDataStore::CatVector::Streamer(buf);
   }
} // end of namespace ROOT for class ::RooVectorDataStore::CatVector

//______________________________________________________________________________
void RooUnitTest::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooUnitTest.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooUnitTest::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooUnitTest::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooUnitTest(void *p) {
      delete ((::RooUnitTest*)p);
   }
   static void deleteArray_RooUnitTest(void *p) {
      delete [] ((::RooUnitTest*)p);
   }
   static void destruct_RooUnitTest(void *p) {
      typedef ::RooUnitTest current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooUnitTest

//______________________________________________________________________________
void RooExtendedBinding::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooExtendedBinding.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooExtendedBinding::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooExtendedBinding::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooExtendedBinding(void *p) {
      return  p ? new(p) ::RooExtendedBinding : new ::RooExtendedBinding;
   }
   static void *newArray_RooExtendedBinding(Long_t nElements, void *p) {
      return p ? new(p) ::RooExtendedBinding[nElements] : new ::RooExtendedBinding[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooExtendedBinding(void *p) {
      delete ((::RooExtendedBinding*)p);
   }
   static void deleteArray_RooExtendedBinding(void *p) {
      delete [] ((::RooExtendedBinding*)p);
   }
   static void destruct_RooExtendedBinding(void *p) {
      typedef ::RooExtendedBinding current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooExtendedBinding

//______________________________________________________________________________
void RooFirstMoment::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooFirstMoment.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooFirstMoment::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooFirstMoment::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooFirstMoment(void *p) {
      return  p ? new(p) ::RooFirstMoment : new ::RooFirstMoment;
   }
   static void *newArray_RooFirstMoment(Long_t nElements, void *p) {
      return p ? new(p) ::RooFirstMoment[nElements] : new ::RooFirstMoment[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooFirstMoment(void *p) {
      delete ((::RooFirstMoment*)p);
   }
   static void deleteArray_RooFirstMoment(void *p) {
      delete [] ((::RooFirstMoment*)p);
   }
   static void destruct_RooFirstMoment(void *p) {
      typedef ::RooFirstMoment current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooFirstMoment

//______________________________________________________________________________
void RooSecondMoment::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooSecondMoment.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooSecondMoment::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooSecondMoment::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooSecondMoment(void *p) {
      return  p ? new(p) ::RooSecondMoment : new ::RooSecondMoment;
   }
   static void *newArray_RooSecondMoment(Long_t nElements, void *p) {
      return p ? new(p) ::RooSecondMoment[nElements] : new ::RooSecondMoment[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooSecondMoment(void *p) {
      delete ((::RooSecondMoment*)p);
   }
   static void deleteArray_RooSecondMoment(void *p) {
      delete [] ((::RooSecondMoment*)p);
   }
   static void destruct_RooSecondMoment(void *p) {
      typedef ::RooSecondMoment current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooSecondMoment

namespace ROOT {
   static TClass *vectorlEpairlEstringcOintgRsPgR_Dictionary();
   static void vectorlEpairlEstringcOintgRsPgR_TClassManip(TClass*);
   static void *new_vectorlEpairlEstringcOintgRsPgR(void *p = 0);
   static void *newArray_vectorlEpairlEstringcOintgRsPgR(Long_t size, void *p);
   static void delete_vectorlEpairlEstringcOintgRsPgR(void *p);
   static void deleteArray_vectorlEpairlEstringcOintgRsPgR(void *p);
   static void destruct_vectorlEpairlEstringcOintgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<pair<string,int> >*)
   {
      vector<pair<string,int> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<pair<string,int> >));
      static ::ROOT::TGenericClassInfo 
         instance("vector<pair<string,int> >", -2, "vector", 216,
                  typeid(vector<pair<string,int> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &vectorlEpairlEstringcOintgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(vector<pair<string,int> >) );
      instance.SetNew(&new_vectorlEpairlEstringcOintgRsPgR);
      instance.SetNewArray(&newArray_vectorlEpairlEstringcOintgRsPgR);
      instance.SetDelete(&delete_vectorlEpairlEstringcOintgRsPgR);
      instance.SetDeleteArray(&deleteArray_vectorlEpairlEstringcOintgRsPgR);
      instance.SetDestructor(&destruct_vectorlEpairlEstringcOintgRsPgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<pair<string,int> > >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const vector<pair<string,int> >*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *vectorlEpairlEstringcOintgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const vector<pair<string,int> >*)0x0)->GetClass();
      vectorlEpairlEstringcOintgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void vectorlEpairlEstringcOintgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEpairlEstringcOintgRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<pair<string,int> > : new vector<pair<string,int> >;
   }
   static void *newArray_vectorlEpairlEstringcOintgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<pair<string,int> >[nElements] : new vector<pair<string,int> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEpairlEstringcOintgRsPgR(void *p) {
      delete ((vector<pair<string,int> >*)p);
   }
   static void deleteArray_vectorlEpairlEstringcOintgRsPgR(void *p) {
      delete [] ((vector<pair<string,int> >*)p);
   }
   static void destruct_vectorlEpairlEstringcOintgRsPgR(void *p) {
      typedef vector<pair<string,int> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<pair<string,int> >

namespace ROOT {
   static TClass *vectorlEintgR_Dictionary();
   static void vectorlEintgR_TClassManip(TClass*);
   static void *new_vectorlEintgR(void *p = 0);
   static void *newArray_vectorlEintgR(Long_t size, void *p);
   static void delete_vectorlEintgR(void *p);
   static void deleteArray_vectorlEintgR(void *p);
   static void destruct_vectorlEintgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<int>*)
   {
      vector<int> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<int>));
      static ::ROOT::TGenericClassInfo 
         instance("vector<int>", -2, "vector", 216,
                  typeid(vector<int>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &vectorlEintgR_Dictionary, isa_proxy, 0,
                  sizeof(vector<int>) );
      instance.SetNew(&new_vectorlEintgR);
      instance.SetNewArray(&newArray_vectorlEintgR);
      instance.SetDelete(&delete_vectorlEintgR);
      instance.SetDeleteArray(&deleteArray_vectorlEintgR);
      instance.SetDestructor(&destruct_vectorlEintgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<int> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const vector<int>*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *vectorlEintgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const vector<int>*)0x0)->GetClass();
      vectorlEintgR_TClassManip(theClass);
   return theClass;
   }

   static void vectorlEintgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEintgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<int> : new vector<int>;
   }
   static void *newArray_vectorlEintgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<int>[nElements] : new vector<int>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEintgR(void *p) {
      delete ((vector<int>*)p);
   }
   static void deleteArray_vectorlEintgR(void *p) {
      delete [] ((vector<int>*)p);
   }
   static void destruct_vectorlEintgR(void *p) {
      typedef vector<int> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<int>

namespace ROOT {
   static TClass *vectorlEdoublegR_Dictionary();
   static void vectorlEdoublegR_TClassManip(TClass*);
   static void *new_vectorlEdoublegR(void *p = 0);
   static void *newArray_vectorlEdoublegR(Long_t size, void *p);
   static void delete_vectorlEdoublegR(void *p);
   static void deleteArray_vectorlEdoublegR(void *p);
   static void destruct_vectorlEdoublegR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<double>*)
   {
      vector<double> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<double>));
      static ::ROOT::TGenericClassInfo 
         instance("vector<double>", -2, "vector", 216,
                  typeid(vector<double>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &vectorlEdoublegR_Dictionary, isa_proxy, 0,
                  sizeof(vector<double>) );
      instance.SetNew(&new_vectorlEdoublegR);
      instance.SetNewArray(&newArray_vectorlEdoublegR);
      instance.SetDelete(&delete_vectorlEdoublegR);
      instance.SetDeleteArray(&deleteArray_vectorlEdoublegR);
      instance.SetDestructor(&destruct_vectorlEdoublegR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<double> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const vector<double>*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *vectorlEdoublegR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const vector<double>*)0x0)->GetClass();
      vectorlEdoublegR_TClassManip(theClass);
   return theClass;
   }

   static void vectorlEdoublegR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEdoublegR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<double> : new vector<double>;
   }
   static void *newArray_vectorlEdoublegR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<double>[nElements] : new vector<double>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEdoublegR(void *p) {
      delete ((vector<double>*)p);
   }
   static void deleteArray_vectorlEdoublegR(void *p) {
      delete [] ((vector<double>*)p);
   }
   static void destruct_vectorlEdoublegR(void *p) {
      typedef vector<double> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<double>

namespace ROOT {
   static TClass *vectorlERooVectorDataStorecLcLRealVectormUgR_Dictionary();
   static void vectorlERooVectorDataStorecLcLRealVectormUgR_TClassManip(TClass*);
   static void *new_vectorlERooVectorDataStorecLcLRealVectormUgR(void *p = 0);
   static void *newArray_vectorlERooVectorDataStorecLcLRealVectormUgR(Long_t size, void *p);
   static void delete_vectorlERooVectorDataStorecLcLRealVectormUgR(void *p);
   static void deleteArray_vectorlERooVectorDataStorecLcLRealVectormUgR(void *p);
   static void destruct_vectorlERooVectorDataStorecLcLRealVectormUgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<RooVectorDataStore::RealVector*>*)
   {
      vector<RooVectorDataStore::RealVector*> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<RooVectorDataStore::RealVector*>));
      static ::ROOT::TGenericClassInfo 
         instance("vector<RooVectorDataStore::RealVector*>", -2, "vector", 216,
                  typeid(vector<RooVectorDataStore::RealVector*>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &vectorlERooVectorDataStorecLcLRealVectormUgR_Dictionary, isa_proxy, 0,
                  sizeof(vector<RooVectorDataStore::RealVector*>) );
      instance.SetNew(&new_vectorlERooVectorDataStorecLcLRealVectormUgR);
      instance.SetNewArray(&newArray_vectorlERooVectorDataStorecLcLRealVectormUgR);
      instance.SetDelete(&delete_vectorlERooVectorDataStorecLcLRealVectormUgR);
      instance.SetDeleteArray(&deleteArray_vectorlERooVectorDataStorecLcLRealVectormUgR);
      instance.SetDestructor(&destruct_vectorlERooVectorDataStorecLcLRealVectormUgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<RooVectorDataStore::RealVector*> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const vector<RooVectorDataStore::RealVector*>*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *vectorlERooVectorDataStorecLcLRealVectormUgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const vector<RooVectorDataStore::RealVector*>*)0x0)->GetClass();
      vectorlERooVectorDataStorecLcLRealVectormUgR_TClassManip(theClass);
   return theClass;
   }

   static void vectorlERooVectorDataStorecLcLRealVectormUgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlERooVectorDataStorecLcLRealVectormUgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<RooVectorDataStore::RealVector*> : new vector<RooVectorDataStore::RealVector*>;
   }
   static void *newArray_vectorlERooVectorDataStorecLcLRealVectormUgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<RooVectorDataStore::RealVector*>[nElements] : new vector<RooVectorDataStore::RealVector*>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlERooVectorDataStorecLcLRealVectormUgR(void *p) {
      delete ((vector<RooVectorDataStore::RealVector*>*)p);
   }
   static void deleteArray_vectorlERooVectorDataStorecLcLRealVectormUgR(void *p) {
      delete [] ((vector<RooVectorDataStore::RealVector*>*)p);
   }
   static void destruct_vectorlERooVectorDataStorecLcLRealVectormUgR(void *p) {
      typedef vector<RooVectorDataStore::RealVector*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<RooVectorDataStore::RealVector*>

namespace ROOT {
   static TClass *vectorlERooVectorDataStorecLcLRealFullVectormUgR_Dictionary();
   static void vectorlERooVectorDataStorecLcLRealFullVectormUgR_TClassManip(TClass*);
   static void *new_vectorlERooVectorDataStorecLcLRealFullVectormUgR(void *p = 0);
   static void *newArray_vectorlERooVectorDataStorecLcLRealFullVectormUgR(Long_t size, void *p);
   static void delete_vectorlERooVectorDataStorecLcLRealFullVectormUgR(void *p);
   static void deleteArray_vectorlERooVectorDataStorecLcLRealFullVectormUgR(void *p);
   static void destruct_vectorlERooVectorDataStorecLcLRealFullVectormUgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<RooVectorDataStore::RealFullVector*>*)
   {
      vector<RooVectorDataStore::RealFullVector*> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<RooVectorDataStore::RealFullVector*>));
      static ::ROOT::TGenericClassInfo 
         instance("vector<RooVectorDataStore::RealFullVector*>", -2, "vector", 216,
                  typeid(vector<RooVectorDataStore::RealFullVector*>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &vectorlERooVectorDataStorecLcLRealFullVectormUgR_Dictionary, isa_proxy, 0,
                  sizeof(vector<RooVectorDataStore::RealFullVector*>) );
      instance.SetNew(&new_vectorlERooVectorDataStorecLcLRealFullVectormUgR);
      instance.SetNewArray(&newArray_vectorlERooVectorDataStorecLcLRealFullVectormUgR);
      instance.SetDelete(&delete_vectorlERooVectorDataStorecLcLRealFullVectormUgR);
      instance.SetDeleteArray(&deleteArray_vectorlERooVectorDataStorecLcLRealFullVectormUgR);
      instance.SetDestructor(&destruct_vectorlERooVectorDataStorecLcLRealFullVectormUgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<RooVectorDataStore::RealFullVector*> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const vector<RooVectorDataStore::RealFullVector*>*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *vectorlERooVectorDataStorecLcLRealFullVectormUgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const vector<RooVectorDataStore::RealFullVector*>*)0x0)->GetClass();
      vectorlERooVectorDataStorecLcLRealFullVectormUgR_TClassManip(theClass);
   return theClass;
   }

   static void vectorlERooVectorDataStorecLcLRealFullVectormUgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlERooVectorDataStorecLcLRealFullVectormUgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<RooVectorDataStore::RealFullVector*> : new vector<RooVectorDataStore::RealFullVector*>;
   }
   static void *newArray_vectorlERooVectorDataStorecLcLRealFullVectormUgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<RooVectorDataStore::RealFullVector*>[nElements] : new vector<RooVectorDataStore::RealFullVector*>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlERooVectorDataStorecLcLRealFullVectormUgR(void *p) {
      delete ((vector<RooVectorDataStore::RealFullVector*>*)p);
   }
   static void deleteArray_vectorlERooVectorDataStorecLcLRealFullVectormUgR(void *p) {
      delete [] ((vector<RooVectorDataStore::RealFullVector*>*)p);
   }
   static void destruct_vectorlERooVectorDataStorecLcLRealFullVectormUgR(void *p) {
      typedef vector<RooVectorDataStore::RealFullVector*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<RooVectorDataStore::RealFullVector*>

namespace ROOT {
   static TClass *vectorlERooVectorDataStorecLcLCatVectormUgR_Dictionary();
   static void vectorlERooVectorDataStorecLcLCatVectormUgR_TClassManip(TClass*);
   static void *new_vectorlERooVectorDataStorecLcLCatVectormUgR(void *p = 0);
   static void *newArray_vectorlERooVectorDataStorecLcLCatVectormUgR(Long_t size, void *p);
   static void delete_vectorlERooVectorDataStorecLcLCatVectormUgR(void *p);
   static void deleteArray_vectorlERooVectorDataStorecLcLCatVectormUgR(void *p);
   static void destruct_vectorlERooVectorDataStorecLcLCatVectormUgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<RooVectorDataStore::CatVector*>*)
   {
      vector<RooVectorDataStore::CatVector*> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<RooVectorDataStore::CatVector*>));
      static ::ROOT::TGenericClassInfo 
         instance("vector<RooVectorDataStore::CatVector*>", -2, "vector", 216,
                  typeid(vector<RooVectorDataStore::CatVector*>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &vectorlERooVectorDataStorecLcLCatVectormUgR_Dictionary, isa_proxy, 0,
                  sizeof(vector<RooVectorDataStore::CatVector*>) );
      instance.SetNew(&new_vectorlERooVectorDataStorecLcLCatVectormUgR);
      instance.SetNewArray(&newArray_vectorlERooVectorDataStorecLcLCatVectormUgR);
      instance.SetDelete(&delete_vectorlERooVectorDataStorecLcLCatVectormUgR);
      instance.SetDeleteArray(&deleteArray_vectorlERooVectorDataStorecLcLCatVectormUgR);
      instance.SetDestructor(&destruct_vectorlERooVectorDataStorecLcLCatVectormUgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<RooVectorDataStore::CatVector*> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const vector<RooVectorDataStore::CatVector*>*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *vectorlERooVectorDataStorecLcLCatVectormUgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const vector<RooVectorDataStore::CatVector*>*)0x0)->GetClass();
      vectorlERooVectorDataStorecLcLCatVectormUgR_TClassManip(theClass);
   return theClass;
   }

   static void vectorlERooVectorDataStorecLcLCatVectormUgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlERooVectorDataStorecLcLCatVectormUgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<RooVectorDataStore::CatVector*> : new vector<RooVectorDataStore::CatVector*>;
   }
   static void *newArray_vectorlERooVectorDataStorecLcLCatVectormUgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<RooVectorDataStore::CatVector*>[nElements] : new vector<RooVectorDataStore::CatVector*>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlERooVectorDataStorecLcLCatVectormUgR(void *p) {
      delete ((vector<RooVectorDataStore::CatVector*>*)p);
   }
   static void deleteArray_vectorlERooVectorDataStorecLcLCatVectormUgR(void *p) {
      delete [] ((vector<RooVectorDataStore::CatVector*>*)p);
   }
   static void destruct_vectorlERooVectorDataStorecLcLCatVectormUgR(void *p) {
      typedef vector<RooVectorDataStore::CatVector*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<RooVectorDataStore::CatVector*>

namespace ROOT {
   static TClass *vectorlERooCatTypegR_Dictionary();
   static void vectorlERooCatTypegR_TClassManip(TClass*);
   static void *new_vectorlERooCatTypegR(void *p = 0);
   static void *newArray_vectorlERooCatTypegR(Long_t size, void *p);
   static void delete_vectorlERooCatTypegR(void *p);
   static void deleteArray_vectorlERooCatTypegR(void *p);
   static void destruct_vectorlERooCatTypegR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<RooCatType>*)
   {
      vector<RooCatType> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<RooCatType>));
      static ::ROOT::TGenericClassInfo 
         instance("vector<RooCatType>", -2, "vector", 216,
                  typeid(vector<RooCatType>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &vectorlERooCatTypegR_Dictionary, isa_proxy, 0,
                  sizeof(vector<RooCatType>) );
      instance.SetNew(&new_vectorlERooCatTypegR);
      instance.SetNewArray(&newArray_vectorlERooCatTypegR);
      instance.SetDelete(&delete_vectorlERooCatTypegR);
      instance.SetDeleteArray(&deleteArray_vectorlERooCatTypegR);
      instance.SetDestructor(&destruct_vectorlERooCatTypegR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<RooCatType> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const vector<RooCatType>*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *vectorlERooCatTypegR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const vector<RooCatType>*)0x0)->GetClass();
      vectorlERooCatTypegR_TClassManip(theClass);
   return theClass;
   }

   static void vectorlERooCatTypegR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlERooCatTypegR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<RooCatType> : new vector<RooCatType>;
   }
   static void *newArray_vectorlERooCatTypegR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<RooCatType>[nElements] : new vector<RooCatType>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlERooCatTypegR(void *p) {
      delete ((vector<RooCatType>*)p);
   }
   static void deleteArray_vectorlERooCatTypegR(void *p) {
      delete [] ((vector<RooCatType>*)p);
   }
   static void destruct_vectorlERooCatTypegR(void *p) {
      typedef vector<RooCatType> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<RooCatType>

namespace ROOT {
   static TClass *vectorlERooAbsArgmUgR_Dictionary();
   static void vectorlERooAbsArgmUgR_TClassManip(TClass*);
   static void *new_vectorlERooAbsArgmUgR(void *p = 0);
   static void *newArray_vectorlERooAbsArgmUgR(Long_t size, void *p);
   static void delete_vectorlERooAbsArgmUgR(void *p);
   static void deleteArray_vectorlERooAbsArgmUgR(void *p);
   static void destruct_vectorlERooAbsArgmUgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<RooAbsArg*>*)
   {
      vector<RooAbsArg*> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<RooAbsArg*>));
      static ::ROOT::TGenericClassInfo 
         instance("vector<RooAbsArg*>", -2, "vector", 216,
                  typeid(vector<RooAbsArg*>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &vectorlERooAbsArgmUgR_Dictionary, isa_proxy, 0,
                  sizeof(vector<RooAbsArg*>) );
      instance.SetNew(&new_vectorlERooAbsArgmUgR);
      instance.SetNewArray(&newArray_vectorlERooAbsArgmUgR);
      instance.SetDelete(&delete_vectorlERooAbsArgmUgR);
      instance.SetDeleteArray(&deleteArray_vectorlERooAbsArgmUgR);
      instance.SetDestructor(&destruct_vectorlERooAbsArgmUgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<RooAbsArg*> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const vector<RooAbsArg*>*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *vectorlERooAbsArgmUgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const vector<RooAbsArg*>*)0x0)->GetClass();
      vectorlERooAbsArgmUgR_TClassManip(theClass);
   return theClass;
   }

   static void vectorlERooAbsArgmUgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlERooAbsArgmUgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<RooAbsArg*> : new vector<RooAbsArg*>;
   }
   static void *newArray_vectorlERooAbsArgmUgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<RooAbsArg*>[nElements] : new vector<RooAbsArg*>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlERooAbsArgmUgR(void *p) {
      delete ((vector<RooAbsArg*>*)p);
   }
   static void deleteArray_vectorlERooAbsArgmUgR(void *p) {
      delete [] ((vector<RooAbsArg*>*)p);
   }
   static void destruct_vectorlERooAbsArgmUgR(void *p) {
      typedef vector<RooAbsArg*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<RooAbsArg*>

namespace ROOT {
   static TClass *setlEstringgR_Dictionary();
   static void setlEstringgR_TClassManip(TClass*);
   static void *new_setlEstringgR(void *p = 0);
   static void *newArray_setlEstringgR(Long_t size, void *p);
   static void delete_setlEstringgR(void *p);
   static void deleteArray_setlEstringgR(void *p);
   static void destruct_setlEstringgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const set<string>*)
   {
      set<string> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(set<string>));
      static ::ROOT::TGenericClassInfo 
         instance("set<string>", -2, "set", 93,
                  typeid(set<string>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &setlEstringgR_Dictionary, isa_proxy, 0,
                  sizeof(set<string>) );
      instance.SetNew(&new_setlEstringgR);
      instance.SetNewArray(&newArray_setlEstringgR);
      instance.SetDelete(&delete_setlEstringgR);
      instance.SetDeleteArray(&deleteArray_setlEstringgR);
      instance.SetDestructor(&destruct_setlEstringgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Insert< set<string> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const set<string>*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *setlEstringgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const set<string>*)0x0)->GetClass();
      setlEstringgR_TClassManip(theClass);
   return theClass;
   }

   static void setlEstringgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_setlEstringgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) set<string> : new set<string>;
   }
   static void *newArray_setlEstringgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) set<string>[nElements] : new set<string>[nElements];
   }
   // Wrapper around operator delete
   static void delete_setlEstringgR(void *p) {
      delete ((set<string>*)p);
   }
   static void deleteArray_setlEstringgR(void *p) {
      delete [] ((set<string>*)p);
   }
   static void destruct_setlEstringgR(void *p) {
      typedef set<string> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class set<string>

namespace ROOT {
   static TClass *maplEstringcOstringgR_Dictionary();
   static void maplEstringcOstringgR_TClassManip(TClass*);
   static void *new_maplEstringcOstringgR(void *p = 0);
   static void *newArray_maplEstringcOstringgR(Long_t size, void *p);
   static void delete_maplEstringcOstringgR(void *p);
   static void deleteArray_maplEstringcOstringgR(void *p);
   static void destruct_maplEstringcOstringgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const map<string,string>*)
   {
      map<string,string> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(map<string,string>));
      static ::ROOT::TGenericClassInfo 
         instance("map<string,string>", -2, "map", 99,
                  typeid(map<string,string>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &maplEstringcOstringgR_Dictionary, isa_proxy, 0,
                  sizeof(map<string,string>) );
      instance.SetNew(&new_maplEstringcOstringgR);
      instance.SetNewArray(&newArray_maplEstringcOstringgR);
      instance.SetDelete(&delete_maplEstringcOstringgR);
      instance.SetDeleteArray(&deleteArray_maplEstringcOstringgR);
      instance.SetDestructor(&destruct_maplEstringcOstringgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::MapInsert< map<string,string> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const map<string,string>*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *maplEstringcOstringgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const map<string,string>*)0x0)->GetClass();
      maplEstringcOstringgR_TClassManip(theClass);
   return theClass;
   }

   static void maplEstringcOstringgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_maplEstringcOstringgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) map<string,string> : new map<string,string>;
   }
   static void *newArray_maplEstringcOstringgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) map<string,string>[nElements] : new map<string,string>[nElements];
   }
   // Wrapper around operator delete
   static void delete_maplEstringcOstringgR(void *p) {
      delete ((map<string,string>*)p);
   }
   static void deleteArray_maplEstringcOstringgR(void *p) {
      delete [] ((map<string,string>*)p);
   }
   static void destruct_maplEstringcOstringgR(void *p) {
      typedef map<string,string> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class map<string,string>

namespace ROOT {
   static TClass *maplEstringcOpairlERooAbsIntegratormUcOstringgRsPgR_Dictionary();
   static void maplEstringcOpairlERooAbsIntegratormUcOstringgRsPgR_TClassManip(TClass*);
   static void *new_maplEstringcOpairlERooAbsIntegratormUcOstringgRsPgR(void *p = 0);
   static void *newArray_maplEstringcOpairlERooAbsIntegratormUcOstringgRsPgR(Long_t size, void *p);
   static void delete_maplEstringcOpairlERooAbsIntegratormUcOstringgRsPgR(void *p);
   static void deleteArray_maplEstringcOpairlERooAbsIntegratormUcOstringgRsPgR(void *p);
   static void destruct_maplEstringcOpairlERooAbsIntegratormUcOstringgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const map<string,pair<RooAbsIntegrator*,string> >*)
   {
      map<string,pair<RooAbsIntegrator*,string> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(map<string,pair<RooAbsIntegrator*,string> >));
      static ::ROOT::TGenericClassInfo 
         instance("map<string,pair<RooAbsIntegrator*,string> >", -2, "map", 99,
                  typeid(map<string,pair<RooAbsIntegrator*,string> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &maplEstringcOpairlERooAbsIntegratormUcOstringgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(map<string,pair<RooAbsIntegrator*,string> >) );
      instance.SetNew(&new_maplEstringcOpairlERooAbsIntegratormUcOstringgRsPgR);
      instance.SetNewArray(&newArray_maplEstringcOpairlERooAbsIntegratormUcOstringgRsPgR);
      instance.SetDelete(&delete_maplEstringcOpairlERooAbsIntegratormUcOstringgRsPgR);
      instance.SetDeleteArray(&deleteArray_maplEstringcOpairlERooAbsIntegratormUcOstringgRsPgR);
      instance.SetDestructor(&destruct_maplEstringcOpairlERooAbsIntegratormUcOstringgRsPgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::MapInsert< map<string,pair<RooAbsIntegrator*,string> > >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const map<string,pair<RooAbsIntegrator*,string> >*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *maplEstringcOpairlERooAbsIntegratormUcOstringgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const map<string,pair<RooAbsIntegrator*,string> >*)0x0)->GetClass();
      maplEstringcOpairlERooAbsIntegratormUcOstringgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void maplEstringcOpairlERooAbsIntegratormUcOstringgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_maplEstringcOpairlERooAbsIntegratormUcOstringgRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) map<string,pair<RooAbsIntegrator*,string> > : new map<string,pair<RooAbsIntegrator*,string> >;
   }
   static void *newArray_maplEstringcOpairlERooAbsIntegratormUcOstringgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) map<string,pair<RooAbsIntegrator*,string> >[nElements] : new map<string,pair<RooAbsIntegrator*,string> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_maplEstringcOpairlERooAbsIntegratormUcOstringgRsPgR(void *p) {
      delete ((map<string,pair<RooAbsIntegrator*,string> >*)p);
   }
   static void deleteArray_maplEstringcOpairlERooAbsIntegratormUcOstringgRsPgR(void *p) {
      delete [] ((map<string,pair<RooAbsIntegrator*,string> >*)p);
   }
   static void destruct_maplEstringcOpairlERooAbsIntegratormUcOstringgRsPgR(void *p) {
      typedef map<string,pair<RooAbsIntegrator*,string> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class map<string,pair<RooAbsIntegrator*,string> >

namespace ROOT {
   static TClass *maplEstringcOTH1mUgR_Dictionary();
   static void maplEstringcOTH1mUgR_TClassManip(TClass*);
   static void *new_maplEstringcOTH1mUgR(void *p = 0);
   static void *newArray_maplEstringcOTH1mUgR(Long_t size, void *p);
   static void delete_maplEstringcOTH1mUgR(void *p);
   static void deleteArray_maplEstringcOTH1mUgR(void *p);
   static void destruct_maplEstringcOTH1mUgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const map<string,TH1*>*)
   {
      map<string,TH1*> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(map<string,TH1*>));
      static ::ROOT::TGenericClassInfo 
         instance("map<string,TH1*>", -2, "map", 99,
                  typeid(map<string,TH1*>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &maplEstringcOTH1mUgR_Dictionary, isa_proxy, 4,
                  sizeof(map<string,TH1*>) );
      instance.SetNew(&new_maplEstringcOTH1mUgR);
      instance.SetNewArray(&newArray_maplEstringcOTH1mUgR);
      instance.SetDelete(&delete_maplEstringcOTH1mUgR);
      instance.SetDeleteArray(&deleteArray_maplEstringcOTH1mUgR);
      instance.SetDestructor(&destruct_maplEstringcOTH1mUgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::MapInsert< map<string,TH1*> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const map<string,TH1*>*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *maplEstringcOTH1mUgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const map<string,TH1*>*)0x0)->GetClass();
      maplEstringcOTH1mUgR_TClassManip(theClass);
   return theClass;
   }

   static void maplEstringcOTH1mUgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_maplEstringcOTH1mUgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) map<string,TH1*> : new map<string,TH1*>;
   }
   static void *newArray_maplEstringcOTH1mUgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) map<string,TH1*>[nElements] : new map<string,TH1*>[nElements];
   }
   // Wrapper around operator delete
   static void delete_maplEstringcOTH1mUgR(void *p) {
      delete ((map<string,TH1*>*)p);
   }
   static void deleteArray_maplEstringcOTH1mUgR(void *p) {
      delete [] ((map<string,TH1*>*)p);
   }
   static void destruct_maplEstringcOTH1mUgR(void *p) {
      typedef map<string,TH1*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class map<string,TH1*>

namespace ROOT {
   static TClass *maplEstringcORooMappedCategorycLcLEntrygR_Dictionary();
   static void maplEstringcORooMappedCategorycLcLEntrygR_TClassManip(TClass*);
   static void *new_maplEstringcORooMappedCategorycLcLEntrygR(void *p = 0);
   static void *newArray_maplEstringcORooMappedCategorycLcLEntrygR(Long_t size, void *p);
   static void delete_maplEstringcORooMappedCategorycLcLEntrygR(void *p);
   static void deleteArray_maplEstringcORooMappedCategorycLcLEntrygR(void *p);
   static void destruct_maplEstringcORooMappedCategorycLcLEntrygR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const map<string,RooMappedCategory::Entry>*)
   {
      map<string,RooMappedCategory::Entry> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(map<string,RooMappedCategory::Entry>));
      static ::ROOT::TGenericClassInfo 
         instance("map<string,RooMappedCategory::Entry>", -2, "map", 99,
                  typeid(map<string,RooMappedCategory::Entry>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &maplEstringcORooMappedCategorycLcLEntrygR_Dictionary, isa_proxy, 0,
                  sizeof(map<string,RooMappedCategory::Entry>) );
      instance.SetNew(&new_maplEstringcORooMappedCategorycLcLEntrygR);
      instance.SetNewArray(&newArray_maplEstringcORooMappedCategorycLcLEntrygR);
      instance.SetDelete(&delete_maplEstringcORooMappedCategorycLcLEntrygR);
      instance.SetDeleteArray(&deleteArray_maplEstringcORooMappedCategorycLcLEntrygR);
      instance.SetDestructor(&destruct_maplEstringcORooMappedCategorycLcLEntrygR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::MapInsert< map<string,RooMappedCategory::Entry> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const map<string,RooMappedCategory::Entry>*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *maplEstringcORooMappedCategorycLcLEntrygR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const map<string,RooMappedCategory::Entry>*)0x0)->GetClass();
      maplEstringcORooMappedCategorycLcLEntrygR_TClassManip(theClass);
   return theClass;
   }

   static void maplEstringcORooMappedCategorycLcLEntrygR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_maplEstringcORooMappedCategorycLcLEntrygR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) map<string,RooMappedCategory::Entry> : new map<string,RooMappedCategory::Entry>;
   }
   static void *newArray_maplEstringcORooMappedCategorycLcLEntrygR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) map<string,RooMappedCategory::Entry>[nElements] : new map<string,RooMappedCategory::Entry>[nElements];
   }
   // Wrapper around operator delete
   static void delete_maplEstringcORooMappedCategorycLcLEntrygR(void *p) {
      delete ((map<string,RooMappedCategory::Entry>*)p);
   }
   static void deleteArray_maplEstringcORooMappedCategorycLcLEntrygR(void *p) {
      delete [] ((map<string,RooMappedCategory::Entry>*)p);
   }
   static void destruct_maplEstringcORooMappedCategorycLcLEntrygR(void *p) {
      typedef map<string,RooMappedCategory::Entry> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class map<string,RooMappedCategory::Entry>

namespace ROOT {
   static TClass *maplEstringcORooDataSetmUgR_Dictionary();
   static void maplEstringcORooDataSetmUgR_TClassManip(TClass*);
   static void *new_maplEstringcORooDataSetmUgR(void *p = 0);
   static void *newArray_maplEstringcORooDataSetmUgR(Long_t size, void *p);
   static void delete_maplEstringcORooDataSetmUgR(void *p);
   static void deleteArray_maplEstringcORooDataSetmUgR(void *p);
   static void destruct_maplEstringcORooDataSetmUgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const map<string,RooDataSet*>*)
   {
      map<string,RooDataSet*> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(map<string,RooDataSet*>));
      static ::ROOT::TGenericClassInfo 
         instance("map<string,RooDataSet*>", -2, "map", 99,
                  typeid(map<string,RooDataSet*>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &maplEstringcORooDataSetmUgR_Dictionary, isa_proxy, 4,
                  sizeof(map<string,RooDataSet*>) );
      instance.SetNew(&new_maplEstringcORooDataSetmUgR);
      instance.SetNewArray(&newArray_maplEstringcORooDataSetmUgR);
      instance.SetDelete(&delete_maplEstringcORooDataSetmUgR);
      instance.SetDeleteArray(&deleteArray_maplEstringcORooDataSetmUgR);
      instance.SetDestructor(&destruct_maplEstringcORooDataSetmUgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::MapInsert< map<string,RooDataSet*> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const map<string,RooDataSet*>*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *maplEstringcORooDataSetmUgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const map<string,RooDataSet*>*)0x0)->GetClass();
      maplEstringcORooDataSetmUgR_TClassManip(theClass);
   return theClass;
   }

   static void maplEstringcORooDataSetmUgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_maplEstringcORooDataSetmUgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) map<string,RooDataSet*> : new map<string,RooDataSet*>;
   }
   static void *newArray_maplEstringcORooDataSetmUgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) map<string,RooDataSet*>[nElements] : new map<string,RooDataSet*>[nElements];
   }
   // Wrapper around operator delete
   static void delete_maplEstringcORooDataSetmUgR(void *p) {
      delete ((map<string,RooDataSet*>*)p);
   }
   static void deleteArray_maplEstringcORooDataSetmUgR(void *p) {
      delete [] ((map<string,RooDataSet*>*)p);
   }
   static void destruct_maplEstringcORooDataSetmUgR(void *p) {
      typedef map<string,RooDataSet*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class map<string,RooDataSet*>

namespace ROOT {
   static TClass *maplEstringcORooDataHistmUgR_Dictionary();
   static void maplEstringcORooDataHistmUgR_TClassManip(TClass*);
   static void *new_maplEstringcORooDataHistmUgR(void *p = 0);
   static void *newArray_maplEstringcORooDataHistmUgR(Long_t size, void *p);
   static void delete_maplEstringcORooDataHistmUgR(void *p);
   static void deleteArray_maplEstringcORooDataHistmUgR(void *p);
   static void destruct_maplEstringcORooDataHistmUgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const map<string,RooDataHist*>*)
   {
      map<string,RooDataHist*> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(map<string,RooDataHist*>));
      static ::ROOT::TGenericClassInfo 
         instance("map<string,RooDataHist*>", -2, "map", 99,
                  typeid(map<string,RooDataHist*>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &maplEstringcORooDataHistmUgR_Dictionary, isa_proxy, 4,
                  sizeof(map<string,RooDataHist*>) );
      instance.SetNew(&new_maplEstringcORooDataHistmUgR);
      instance.SetNewArray(&newArray_maplEstringcORooDataHistmUgR);
      instance.SetDelete(&delete_maplEstringcORooDataHistmUgR);
      instance.SetDeleteArray(&deleteArray_maplEstringcORooDataHistmUgR);
      instance.SetDestructor(&destruct_maplEstringcORooDataHistmUgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::MapInsert< map<string,RooDataHist*> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const map<string,RooDataHist*>*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *maplEstringcORooDataHistmUgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const map<string,RooDataHist*>*)0x0)->GetClass();
      maplEstringcORooDataHistmUgR_TClassManip(theClass);
   return theClass;
   }

   static void maplEstringcORooDataHistmUgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_maplEstringcORooDataHistmUgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) map<string,RooDataHist*> : new map<string,RooDataHist*>;
   }
   static void *newArray_maplEstringcORooDataHistmUgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) map<string,RooDataHist*>[nElements] : new map<string,RooDataHist*>[nElements];
   }
   // Wrapper around operator delete
   static void delete_maplEstringcORooDataHistmUgR(void *p) {
      delete ((map<string,RooDataHist*>*)p);
   }
   static void deleteArray_maplEstringcORooDataHistmUgR(void *p) {
      delete [] ((map<string,RooDataHist*>*)p);
   }
   static void destruct_maplEstringcORooDataHistmUgR(void *p) {
      typedef map<string,RooDataHist*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class map<string,RooDataHist*>

namespace ROOT {
   static TClass *maplEstringcORooArgSetgR_Dictionary();
   static void maplEstringcORooArgSetgR_TClassManip(TClass*);
   static void *new_maplEstringcORooArgSetgR(void *p = 0);
   static void *newArray_maplEstringcORooArgSetgR(Long_t size, void *p);
   static void delete_maplEstringcORooArgSetgR(void *p);
   static void deleteArray_maplEstringcORooArgSetgR(void *p);
   static void destruct_maplEstringcORooArgSetgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const map<string,RooArgSet>*)
   {
      map<string,RooArgSet> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(map<string,RooArgSet>));
      static ::ROOT::TGenericClassInfo 
         instance("map<string,RooArgSet>", -2, "map", 99,
                  typeid(map<string,RooArgSet>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &maplEstringcORooArgSetgR_Dictionary, isa_proxy, 0,
                  sizeof(map<string,RooArgSet>) );
      instance.SetNew(&new_maplEstringcORooArgSetgR);
      instance.SetNewArray(&newArray_maplEstringcORooArgSetgR);
      instance.SetDelete(&delete_maplEstringcORooArgSetgR);
      instance.SetDeleteArray(&deleteArray_maplEstringcORooArgSetgR);
      instance.SetDestructor(&destruct_maplEstringcORooArgSetgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::MapInsert< map<string,RooArgSet> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const map<string,RooArgSet>*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *maplEstringcORooArgSetgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const map<string,RooArgSet>*)0x0)->GetClass();
      maplEstringcORooArgSetgR_TClassManip(theClass);
   return theClass;
   }

   static void maplEstringcORooArgSetgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_maplEstringcORooArgSetgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) map<string,RooArgSet> : new map<string,RooArgSet>;
   }
   static void *newArray_maplEstringcORooArgSetgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) map<string,RooArgSet>[nElements] : new map<string,RooArgSet>[nElements];
   }
   // Wrapper around operator delete
   static void delete_maplEstringcORooArgSetgR(void *p) {
      delete ((map<string,RooArgSet>*)p);
   }
   static void deleteArray_maplEstringcORooArgSetgR(void *p) {
      delete [] ((map<string,RooArgSet>*)p);
   }
   static void destruct_maplEstringcORooArgSetgR(void *p) {
      typedef map<string,RooArgSet> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class map<string,RooArgSet>

namespace ROOT {
   static TClass *maplEstringcORooAbsPdfmUgR_Dictionary();
   static void maplEstringcORooAbsPdfmUgR_TClassManip(TClass*);
   static void *new_maplEstringcORooAbsPdfmUgR(void *p = 0);
   static void *newArray_maplEstringcORooAbsPdfmUgR(Long_t size, void *p);
   static void delete_maplEstringcORooAbsPdfmUgR(void *p);
   static void deleteArray_maplEstringcORooAbsPdfmUgR(void *p);
   static void destruct_maplEstringcORooAbsPdfmUgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const map<string,RooAbsPdf*>*)
   {
      map<string,RooAbsPdf*> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(map<string,RooAbsPdf*>));
      static ::ROOT::TGenericClassInfo 
         instance("map<string,RooAbsPdf*>", -2, "map", 99,
                  typeid(map<string,RooAbsPdf*>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &maplEstringcORooAbsPdfmUgR_Dictionary, isa_proxy, 4,
                  sizeof(map<string,RooAbsPdf*>) );
      instance.SetNew(&new_maplEstringcORooAbsPdfmUgR);
      instance.SetNewArray(&newArray_maplEstringcORooAbsPdfmUgR);
      instance.SetDelete(&delete_maplEstringcORooAbsPdfmUgR);
      instance.SetDeleteArray(&deleteArray_maplEstringcORooAbsPdfmUgR);
      instance.SetDestructor(&destruct_maplEstringcORooAbsPdfmUgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::MapInsert< map<string,RooAbsPdf*> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const map<string,RooAbsPdf*>*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *maplEstringcORooAbsPdfmUgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const map<string,RooAbsPdf*>*)0x0)->GetClass();
      maplEstringcORooAbsPdfmUgR_TClassManip(theClass);
   return theClass;
   }

   static void maplEstringcORooAbsPdfmUgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_maplEstringcORooAbsPdfmUgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) map<string,RooAbsPdf*> : new map<string,RooAbsPdf*>;
   }
   static void *newArray_maplEstringcORooAbsPdfmUgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) map<string,RooAbsPdf*>[nElements] : new map<string,RooAbsPdf*>[nElements];
   }
   // Wrapper around operator delete
   static void delete_maplEstringcORooAbsPdfmUgR(void *p) {
      delete ((map<string,RooAbsPdf*>*)p);
   }
   static void deleteArray_maplEstringcORooAbsPdfmUgR(void *p) {
      delete [] ((map<string,RooAbsPdf*>*)p);
   }
   static void destruct_maplEstringcORooAbsPdfmUgR(void *p) {
      typedef map<string,RooAbsPdf*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class map<string,RooAbsPdf*>

namespace ROOT {
   static TClass *maplEstringcORooAbsNumGeneratormUgR_Dictionary();
   static void maplEstringcORooAbsNumGeneratormUgR_TClassManip(TClass*);
   static void *new_maplEstringcORooAbsNumGeneratormUgR(void *p = 0);
   static void *newArray_maplEstringcORooAbsNumGeneratormUgR(Long_t size, void *p);
   static void delete_maplEstringcORooAbsNumGeneratormUgR(void *p);
   static void deleteArray_maplEstringcORooAbsNumGeneratormUgR(void *p);
   static void destruct_maplEstringcORooAbsNumGeneratormUgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const map<string,RooAbsNumGenerator*>*)
   {
      map<string,RooAbsNumGenerator*> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(map<string,RooAbsNumGenerator*>));
      static ::ROOT::TGenericClassInfo 
         instance("map<string,RooAbsNumGenerator*>", -2, "map", 99,
                  typeid(map<string,RooAbsNumGenerator*>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &maplEstringcORooAbsNumGeneratormUgR_Dictionary, isa_proxy, 0,
                  sizeof(map<string,RooAbsNumGenerator*>) );
      instance.SetNew(&new_maplEstringcORooAbsNumGeneratormUgR);
      instance.SetNewArray(&newArray_maplEstringcORooAbsNumGeneratormUgR);
      instance.SetDelete(&delete_maplEstringcORooAbsNumGeneratormUgR);
      instance.SetDeleteArray(&deleteArray_maplEstringcORooAbsNumGeneratormUgR);
      instance.SetDestructor(&destruct_maplEstringcORooAbsNumGeneratormUgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::MapInsert< map<string,RooAbsNumGenerator*> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const map<string,RooAbsNumGenerator*>*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *maplEstringcORooAbsNumGeneratormUgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const map<string,RooAbsNumGenerator*>*)0x0)->GetClass();
      maplEstringcORooAbsNumGeneratormUgR_TClassManip(theClass);
   return theClass;
   }

   static void maplEstringcORooAbsNumGeneratormUgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_maplEstringcORooAbsNumGeneratormUgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) map<string,RooAbsNumGenerator*> : new map<string,RooAbsNumGenerator*>;
   }
   static void *newArray_maplEstringcORooAbsNumGeneratormUgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) map<string,RooAbsNumGenerator*>[nElements] : new map<string,RooAbsNumGenerator*>[nElements];
   }
   // Wrapper around operator delete
   static void delete_maplEstringcORooAbsNumGeneratormUgR(void *p) {
      delete ((map<string,RooAbsNumGenerator*>*)p);
   }
   static void deleteArray_maplEstringcORooAbsNumGeneratormUgR(void *p) {
      delete [] ((map<string,RooAbsNumGenerator*>*)p);
   }
   static void destruct_maplEstringcORooAbsNumGeneratormUgR(void *p) {
      typedef map<string,RooAbsNumGenerator*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class map<string,RooAbsNumGenerator*>

namespace ROOT {
   static TClass *maplEstringcORooAbsDataStoremUgR_Dictionary();
   static void maplEstringcORooAbsDataStoremUgR_TClassManip(TClass*);
   static void *new_maplEstringcORooAbsDataStoremUgR(void *p = 0);
   static void *newArray_maplEstringcORooAbsDataStoremUgR(Long_t size, void *p);
   static void delete_maplEstringcORooAbsDataStoremUgR(void *p);
   static void deleteArray_maplEstringcORooAbsDataStoremUgR(void *p);
   static void destruct_maplEstringcORooAbsDataStoremUgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const map<string,RooAbsDataStore*>*)
   {
      map<string,RooAbsDataStore*> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(map<string,RooAbsDataStore*>));
      static ::ROOT::TGenericClassInfo 
         instance("map<string,RooAbsDataStore*>", -2, "map", 99,
                  typeid(map<string,RooAbsDataStore*>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &maplEstringcORooAbsDataStoremUgR_Dictionary, isa_proxy, 4,
                  sizeof(map<string,RooAbsDataStore*>) );
      instance.SetNew(&new_maplEstringcORooAbsDataStoremUgR);
      instance.SetNewArray(&newArray_maplEstringcORooAbsDataStoremUgR);
      instance.SetDelete(&delete_maplEstringcORooAbsDataStoremUgR);
      instance.SetDeleteArray(&deleteArray_maplEstringcORooAbsDataStoremUgR);
      instance.SetDestructor(&destruct_maplEstringcORooAbsDataStoremUgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::MapInsert< map<string,RooAbsDataStore*> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const map<string,RooAbsDataStore*>*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *maplEstringcORooAbsDataStoremUgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const map<string,RooAbsDataStore*>*)0x0)->GetClass();
      maplEstringcORooAbsDataStoremUgR_TClassManip(theClass);
   return theClass;
   }

   static void maplEstringcORooAbsDataStoremUgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_maplEstringcORooAbsDataStoremUgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) map<string,RooAbsDataStore*> : new map<string,RooAbsDataStore*>;
   }
   static void *newArray_maplEstringcORooAbsDataStoremUgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) map<string,RooAbsDataStore*>[nElements] : new map<string,RooAbsDataStore*>[nElements];
   }
   // Wrapper around operator delete
   static void delete_maplEstringcORooAbsDataStoremUgR(void *p) {
      delete ((map<string,RooAbsDataStore*>*)p);
   }
   static void deleteArray_maplEstringcORooAbsDataStoremUgR(void *p) {
      delete [] ((map<string,RooAbsDataStore*>*)p);
   }
   static void destruct_maplEstringcORooAbsDataStoremUgR(void *p) {
      typedef map<string,RooAbsDataStore*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class map<string,RooAbsDataStore*>

namespace ROOT {
   static TClass *maplEstringcORooAbsDatamUgR_Dictionary();
   static void maplEstringcORooAbsDatamUgR_TClassManip(TClass*);
   static void *new_maplEstringcORooAbsDatamUgR(void *p = 0);
   static void *newArray_maplEstringcORooAbsDatamUgR(Long_t size, void *p);
   static void delete_maplEstringcORooAbsDatamUgR(void *p);
   static void deleteArray_maplEstringcORooAbsDatamUgR(void *p);
   static void destruct_maplEstringcORooAbsDatamUgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const map<string,RooAbsData*>*)
   {
      map<string,RooAbsData*> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(map<string,RooAbsData*>));
      static ::ROOT::TGenericClassInfo 
         instance("map<string,RooAbsData*>", -2, "map", 99,
                  typeid(map<string,RooAbsData*>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &maplEstringcORooAbsDatamUgR_Dictionary, isa_proxy, 4,
                  sizeof(map<string,RooAbsData*>) );
      instance.SetNew(&new_maplEstringcORooAbsDatamUgR);
      instance.SetNewArray(&newArray_maplEstringcORooAbsDatamUgR);
      instance.SetDelete(&delete_maplEstringcORooAbsDatamUgR);
      instance.SetDeleteArray(&deleteArray_maplEstringcORooAbsDatamUgR);
      instance.SetDestructor(&destruct_maplEstringcORooAbsDatamUgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::MapInsert< map<string,RooAbsData*> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const map<string,RooAbsData*>*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *maplEstringcORooAbsDatamUgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const map<string,RooAbsData*>*)0x0)->GetClass();
      maplEstringcORooAbsDatamUgR_TClassManip(theClass);
   return theClass;
   }

   static void maplEstringcORooAbsDatamUgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_maplEstringcORooAbsDatamUgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) map<string,RooAbsData*> : new map<string,RooAbsData*>;
   }
   static void *newArray_maplEstringcORooAbsDatamUgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) map<string,RooAbsData*>[nElements] : new map<string,RooAbsData*>[nElements];
   }
   // Wrapper around operator delete
   static void delete_maplEstringcORooAbsDatamUgR(void *p) {
      delete ((map<string,RooAbsData*>*)p);
   }
   static void deleteArray_maplEstringcORooAbsDatamUgR(void *p) {
      delete [] ((map<string,RooAbsData*>*)p);
   }
   static void destruct_maplEstringcORooAbsDatamUgR(void *p) {
      typedef map<string,RooAbsData*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class map<string,RooAbsData*>

namespace ROOT {
   static TClass *maplEintcORooAbsDataStoremUgR_Dictionary();
   static void maplEintcORooAbsDataStoremUgR_TClassManip(TClass*);
   static void *new_maplEintcORooAbsDataStoremUgR(void *p = 0);
   static void *newArray_maplEintcORooAbsDataStoremUgR(Long_t size, void *p);
   static void delete_maplEintcORooAbsDataStoremUgR(void *p);
   static void deleteArray_maplEintcORooAbsDataStoremUgR(void *p);
   static void destruct_maplEintcORooAbsDataStoremUgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const map<int,RooAbsDataStore*>*)
   {
      map<int,RooAbsDataStore*> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(map<int,RooAbsDataStore*>));
      static ::ROOT::TGenericClassInfo 
         instance("map<int,RooAbsDataStore*>", -2, "map", 99,
                  typeid(map<int,RooAbsDataStore*>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &maplEintcORooAbsDataStoremUgR_Dictionary, isa_proxy, 0,
                  sizeof(map<int,RooAbsDataStore*>) );
      instance.SetNew(&new_maplEintcORooAbsDataStoremUgR);
      instance.SetNewArray(&newArray_maplEintcORooAbsDataStoremUgR);
      instance.SetDelete(&delete_maplEintcORooAbsDataStoremUgR);
      instance.SetDeleteArray(&deleteArray_maplEintcORooAbsDataStoremUgR);
      instance.SetDestructor(&destruct_maplEintcORooAbsDataStoremUgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::MapInsert< map<int,RooAbsDataStore*> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const map<int,RooAbsDataStore*>*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *maplEintcORooAbsDataStoremUgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const map<int,RooAbsDataStore*>*)0x0)->GetClass();
      maplEintcORooAbsDataStoremUgR_TClassManip(theClass);
   return theClass;
   }

   static void maplEintcORooAbsDataStoremUgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_maplEintcORooAbsDataStoremUgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) map<int,RooAbsDataStore*> : new map<int,RooAbsDataStore*>;
   }
   static void *newArray_maplEintcORooAbsDataStoremUgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) map<int,RooAbsDataStore*>[nElements] : new map<int,RooAbsDataStore*>[nElements];
   }
   // Wrapper around operator delete
   static void delete_maplEintcORooAbsDataStoremUgR(void *p) {
      delete ((map<int,RooAbsDataStore*>*)p);
   }
   static void deleteArray_maplEintcORooAbsDataStoremUgR(void *p) {
      delete [] ((map<int,RooAbsDataStore*>*)p);
   }
   static void destruct_maplEintcORooAbsDataStoremUgR(void *p) {
      typedef map<int,RooAbsDataStore*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class map<int,RooAbsDataStore*>

namespace ROOT {
   static TClass *maplETStringcOintgR_Dictionary();
   static void maplETStringcOintgR_TClassManip(TClass*);
   static void *new_maplETStringcOintgR(void *p = 0);
   static void *newArray_maplETStringcOintgR(Long_t size, void *p);
   static void delete_maplETStringcOintgR(void *p);
   static void deleteArray_maplETStringcOintgR(void *p);
   static void destruct_maplETStringcOintgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const map<TString,int>*)
   {
      map<TString,int> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(map<TString,int>));
      static ::ROOT::TGenericClassInfo 
         instance("map<TString,int>", -2, "map", 99,
                  typeid(map<TString,int>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &maplETStringcOintgR_Dictionary, isa_proxy, 0,
                  sizeof(map<TString,int>) );
      instance.SetNew(&new_maplETStringcOintgR);
      instance.SetNewArray(&newArray_maplETStringcOintgR);
      instance.SetDelete(&delete_maplETStringcOintgR);
      instance.SetDeleteArray(&deleteArray_maplETStringcOintgR);
      instance.SetDestructor(&destruct_maplETStringcOintgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::MapInsert< map<TString,int> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const map<TString,int>*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *maplETStringcOintgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const map<TString,int>*)0x0)->GetClass();
      maplETStringcOintgR_TClassManip(theClass);
   return theClass;
   }

   static void maplETStringcOintgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_maplETStringcOintgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) map<TString,int> : new map<TString,int>;
   }
   static void *newArray_maplETStringcOintgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) map<TString,int>[nElements] : new map<TString,int>[nElements];
   }
   // Wrapper around operator delete
   static void delete_maplETStringcOintgR(void *p) {
      delete ((map<TString,int>*)p);
   }
   static void deleteArray_maplETStringcOintgR(void *p) {
      delete [] ((map<TString,int>*)p);
   }
   static void destruct_maplETStringcOintgR(void *p) {
      typedef map<TString,int> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class map<TString,int>

namespace ROOT {
   static TClass *maplETStringcOdoublegR_Dictionary();
   static void maplETStringcOdoublegR_TClassManip(TClass*);
   static void *new_maplETStringcOdoublegR(void *p = 0);
   static void *newArray_maplETStringcOdoublegR(Long_t size, void *p);
   static void delete_maplETStringcOdoublegR(void *p);
   static void deleteArray_maplETStringcOdoublegR(void *p);
   static void destruct_maplETStringcOdoublegR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const map<TString,double>*)
   {
      map<TString,double> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(map<TString,double>));
      static ::ROOT::TGenericClassInfo 
         instance("map<TString,double>", -2, "map", 99,
                  typeid(map<TString,double>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &maplETStringcOdoublegR_Dictionary, isa_proxy, 0,
                  sizeof(map<TString,double>) );
      instance.SetNew(&new_maplETStringcOdoublegR);
      instance.SetNewArray(&newArray_maplETStringcOdoublegR);
      instance.SetDelete(&delete_maplETStringcOdoublegR);
      instance.SetDeleteArray(&deleteArray_maplETStringcOdoublegR);
      instance.SetDestructor(&destruct_maplETStringcOdoublegR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::MapInsert< map<TString,double> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const map<TString,double>*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *maplETStringcOdoublegR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const map<TString,double>*)0x0)->GetClass();
      maplETStringcOdoublegR_TClassManip(theClass);
   return theClass;
   }

   static void maplETStringcOdoublegR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_maplETStringcOdoublegR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) map<TString,double> : new map<TString,double>;
   }
   static void *newArray_maplETStringcOdoublegR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) map<TString,double>[nElements] : new map<TString,double>[nElements];
   }
   // Wrapper around operator delete
   static void delete_maplETStringcOdoublegR(void *p) {
      delete ((map<TString,double>*)p);
   }
   static void deleteArray_maplETStringcOdoublegR(void *p) {
      delete [] ((map<TString,double>*)p);
   }
   static void destruct_maplETStringcOdoublegR(void *p) {
      typedef map<TString,double> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class map<TString,double>

namespace ROOT {
   static TClass *maplETStringcORooWorkspacecLcLCodeRepocLcLExtraHeadergR_Dictionary();
   static void maplETStringcORooWorkspacecLcLCodeRepocLcLExtraHeadergR_TClassManip(TClass*);
   static void *new_maplETStringcORooWorkspacecLcLCodeRepocLcLExtraHeadergR(void *p = 0);
   static void *newArray_maplETStringcORooWorkspacecLcLCodeRepocLcLExtraHeadergR(Long_t size, void *p);
   static void delete_maplETStringcORooWorkspacecLcLCodeRepocLcLExtraHeadergR(void *p);
   static void deleteArray_maplETStringcORooWorkspacecLcLCodeRepocLcLExtraHeadergR(void *p);
   static void destruct_maplETStringcORooWorkspacecLcLCodeRepocLcLExtraHeadergR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const map<TString,RooWorkspace::CodeRepo::ExtraHeader>*)
   {
      map<TString,RooWorkspace::CodeRepo::ExtraHeader> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(map<TString,RooWorkspace::CodeRepo::ExtraHeader>));
      static ::ROOT::TGenericClassInfo 
         instance("map<TString,RooWorkspace::CodeRepo::ExtraHeader>", -2, "map", 99,
                  typeid(map<TString,RooWorkspace::CodeRepo::ExtraHeader>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &maplETStringcORooWorkspacecLcLCodeRepocLcLExtraHeadergR_Dictionary, isa_proxy, 0,
                  sizeof(map<TString,RooWorkspace::CodeRepo::ExtraHeader>) );
      instance.SetNew(&new_maplETStringcORooWorkspacecLcLCodeRepocLcLExtraHeadergR);
      instance.SetNewArray(&newArray_maplETStringcORooWorkspacecLcLCodeRepocLcLExtraHeadergR);
      instance.SetDelete(&delete_maplETStringcORooWorkspacecLcLCodeRepocLcLExtraHeadergR);
      instance.SetDeleteArray(&deleteArray_maplETStringcORooWorkspacecLcLCodeRepocLcLExtraHeadergR);
      instance.SetDestructor(&destruct_maplETStringcORooWorkspacecLcLCodeRepocLcLExtraHeadergR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::MapInsert< map<TString,RooWorkspace::CodeRepo::ExtraHeader> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const map<TString,RooWorkspace::CodeRepo::ExtraHeader>*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *maplETStringcORooWorkspacecLcLCodeRepocLcLExtraHeadergR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const map<TString,RooWorkspace::CodeRepo::ExtraHeader>*)0x0)->GetClass();
      maplETStringcORooWorkspacecLcLCodeRepocLcLExtraHeadergR_TClassManip(theClass);
   return theClass;
   }

   static void maplETStringcORooWorkspacecLcLCodeRepocLcLExtraHeadergR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_maplETStringcORooWorkspacecLcLCodeRepocLcLExtraHeadergR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) map<TString,RooWorkspace::CodeRepo::ExtraHeader> : new map<TString,RooWorkspace::CodeRepo::ExtraHeader>;
   }
   static void *newArray_maplETStringcORooWorkspacecLcLCodeRepocLcLExtraHeadergR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) map<TString,RooWorkspace::CodeRepo::ExtraHeader>[nElements] : new map<TString,RooWorkspace::CodeRepo::ExtraHeader>[nElements];
   }
   // Wrapper around operator delete
   static void delete_maplETStringcORooWorkspacecLcLCodeRepocLcLExtraHeadergR(void *p) {
      delete ((map<TString,RooWorkspace::CodeRepo::ExtraHeader>*)p);
   }
   static void deleteArray_maplETStringcORooWorkspacecLcLCodeRepocLcLExtraHeadergR(void *p) {
      delete [] ((map<TString,RooWorkspace::CodeRepo::ExtraHeader>*)p);
   }
   static void destruct_maplETStringcORooWorkspacecLcLCodeRepocLcLExtraHeadergR(void *p) {
      typedef map<TString,RooWorkspace::CodeRepo::ExtraHeader> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class map<TString,RooWorkspace::CodeRepo::ExtraHeader>

namespace ROOT {
   static TClass *maplETStringcORooWorkspacecLcLCodeRepocLcLClassRelInfogR_Dictionary();
   static void maplETStringcORooWorkspacecLcLCodeRepocLcLClassRelInfogR_TClassManip(TClass*);
   static void *new_maplETStringcORooWorkspacecLcLCodeRepocLcLClassRelInfogR(void *p = 0);
   static void *newArray_maplETStringcORooWorkspacecLcLCodeRepocLcLClassRelInfogR(Long_t size, void *p);
   static void delete_maplETStringcORooWorkspacecLcLCodeRepocLcLClassRelInfogR(void *p);
   static void deleteArray_maplETStringcORooWorkspacecLcLCodeRepocLcLClassRelInfogR(void *p);
   static void destruct_maplETStringcORooWorkspacecLcLCodeRepocLcLClassRelInfogR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const map<TString,RooWorkspace::CodeRepo::ClassRelInfo>*)
   {
      map<TString,RooWorkspace::CodeRepo::ClassRelInfo> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(map<TString,RooWorkspace::CodeRepo::ClassRelInfo>));
      static ::ROOT::TGenericClassInfo 
         instance("map<TString,RooWorkspace::CodeRepo::ClassRelInfo>", -2, "map", 99,
                  typeid(map<TString,RooWorkspace::CodeRepo::ClassRelInfo>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &maplETStringcORooWorkspacecLcLCodeRepocLcLClassRelInfogR_Dictionary, isa_proxy, 0,
                  sizeof(map<TString,RooWorkspace::CodeRepo::ClassRelInfo>) );
      instance.SetNew(&new_maplETStringcORooWorkspacecLcLCodeRepocLcLClassRelInfogR);
      instance.SetNewArray(&newArray_maplETStringcORooWorkspacecLcLCodeRepocLcLClassRelInfogR);
      instance.SetDelete(&delete_maplETStringcORooWorkspacecLcLCodeRepocLcLClassRelInfogR);
      instance.SetDeleteArray(&deleteArray_maplETStringcORooWorkspacecLcLCodeRepocLcLClassRelInfogR);
      instance.SetDestructor(&destruct_maplETStringcORooWorkspacecLcLCodeRepocLcLClassRelInfogR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::MapInsert< map<TString,RooWorkspace::CodeRepo::ClassRelInfo> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const map<TString,RooWorkspace::CodeRepo::ClassRelInfo>*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *maplETStringcORooWorkspacecLcLCodeRepocLcLClassRelInfogR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const map<TString,RooWorkspace::CodeRepo::ClassRelInfo>*)0x0)->GetClass();
      maplETStringcORooWorkspacecLcLCodeRepocLcLClassRelInfogR_TClassManip(theClass);
   return theClass;
   }

   static void maplETStringcORooWorkspacecLcLCodeRepocLcLClassRelInfogR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_maplETStringcORooWorkspacecLcLCodeRepocLcLClassRelInfogR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) map<TString,RooWorkspace::CodeRepo::ClassRelInfo> : new map<TString,RooWorkspace::CodeRepo::ClassRelInfo>;
   }
   static void *newArray_maplETStringcORooWorkspacecLcLCodeRepocLcLClassRelInfogR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) map<TString,RooWorkspace::CodeRepo::ClassRelInfo>[nElements] : new map<TString,RooWorkspace::CodeRepo::ClassRelInfo>[nElements];
   }
   // Wrapper around operator delete
   static void delete_maplETStringcORooWorkspacecLcLCodeRepocLcLClassRelInfogR(void *p) {
      delete ((map<TString,RooWorkspace::CodeRepo::ClassRelInfo>*)p);
   }
   static void deleteArray_maplETStringcORooWorkspacecLcLCodeRepocLcLClassRelInfogR(void *p) {
      delete [] ((map<TString,RooWorkspace::CodeRepo::ClassRelInfo>*)p);
   }
   static void destruct_maplETStringcORooWorkspacecLcLCodeRepocLcLClassRelInfogR(void *p) {
      typedef map<TString,RooWorkspace::CodeRepo::ClassRelInfo> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class map<TString,RooWorkspace::CodeRepo::ClassRelInfo>

namespace ROOT {
   static TClass *maplETStringcORooWorkspacecLcLCodeRepocLcLClassFilesgR_Dictionary();
   static void maplETStringcORooWorkspacecLcLCodeRepocLcLClassFilesgR_TClassManip(TClass*);
   static void *new_maplETStringcORooWorkspacecLcLCodeRepocLcLClassFilesgR(void *p = 0);
   static void *newArray_maplETStringcORooWorkspacecLcLCodeRepocLcLClassFilesgR(Long_t size, void *p);
   static void delete_maplETStringcORooWorkspacecLcLCodeRepocLcLClassFilesgR(void *p);
   static void deleteArray_maplETStringcORooWorkspacecLcLCodeRepocLcLClassFilesgR(void *p);
   static void destruct_maplETStringcORooWorkspacecLcLCodeRepocLcLClassFilesgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const map<TString,RooWorkspace::CodeRepo::ClassFiles>*)
   {
      map<TString,RooWorkspace::CodeRepo::ClassFiles> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(map<TString,RooWorkspace::CodeRepo::ClassFiles>));
      static ::ROOT::TGenericClassInfo 
         instance("map<TString,RooWorkspace::CodeRepo::ClassFiles>", -2, "map", 99,
                  typeid(map<TString,RooWorkspace::CodeRepo::ClassFiles>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &maplETStringcORooWorkspacecLcLCodeRepocLcLClassFilesgR_Dictionary, isa_proxy, 0,
                  sizeof(map<TString,RooWorkspace::CodeRepo::ClassFiles>) );
      instance.SetNew(&new_maplETStringcORooWorkspacecLcLCodeRepocLcLClassFilesgR);
      instance.SetNewArray(&newArray_maplETStringcORooWorkspacecLcLCodeRepocLcLClassFilesgR);
      instance.SetDelete(&delete_maplETStringcORooWorkspacecLcLCodeRepocLcLClassFilesgR);
      instance.SetDeleteArray(&deleteArray_maplETStringcORooWorkspacecLcLCodeRepocLcLClassFilesgR);
      instance.SetDestructor(&destruct_maplETStringcORooWorkspacecLcLCodeRepocLcLClassFilesgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::MapInsert< map<TString,RooWorkspace::CodeRepo::ClassFiles> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const map<TString,RooWorkspace::CodeRepo::ClassFiles>*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *maplETStringcORooWorkspacecLcLCodeRepocLcLClassFilesgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const map<TString,RooWorkspace::CodeRepo::ClassFiles>*)0x0)->GetClass();
      maplETStringcORooWorkspacecLcLCodeRepocLcLClassFilesgR_TClassManip(theClass);
   return theClass;
   }

   static void maplETStringcORooWorkspacecLcLCodeRepocLcLClassFilesgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_maplETStringcORooWorkspacecLcLCodeRepocLcLClassFilesgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) map<TString,RooWorkspace::CodeRepo::ClassFiles> : new map<TString,RooWorkspace::CodeRepo::ClassFiles>;
   }
   static void *newArray_maplETStringcORooWorkspacecLcLCodeRepocLcLClassFilesgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) map<TString,RooWorkspace::CodeRepo::ClassFiles>[nElements] : new map<TString,RooWorkspace::CodeRepo::ClassFiles>[nElements];
   }
   // Wrapper around operator delete
   static void delete_maplETStringcORooWorkspacecLcLCodeRepocLcLClassFilesgR(void *p) {
      delete ((map<TString,RooWorkspace::CodeRepo::ClassFiles>*)p);
   }
   static void deleteArray_maplETStringcORooWorkspacecLcLCodeRepocLcLClassFilesgR(void *p) {
      delete [] ((map<TString,RooWorkspace::CodeRepo::ClassFiles>*)p);
   }
   static void destruct_maplETStringcORooWorkspacecLcLCodeRepocLcLClassFilesgR(void *p) {
      typedef map<TString,RooWorkspace::CodeRepo::ClassFiles> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class map<TString,RooWorkspace::CodeRepo::ClassFiles>

namespace ROOT {
   static TClass *maplETStringcORooExpensiveObjectCachecLcLExpensiveObjectmUgR_Dictionary();
   static void maplETStringcORooExpensiveObjectCachecLcLExpensiveObjectmUgR_TClassManip(TClass*);
   static void *new_maplETStringcORooExpensiveObjectCachecLcLExpensiveObjectmUgR(void *p = 0);
   static void *newArray_maplETStringcORooExpensiveObjectCachecLcLExpensiveObjectmUgR(Long_t size, void *p);
   static void delete_maplETStringcORooExpensiveObjectCachecLcLExpensiveObjectmUgR(void *p);
   static void deleteArray_maplETStringcORooExpensiveObjectCachecLcLExpensiveObjectmUgR(void *p);
   static void destruct_maplETStringcORooExpensiveObjectCachecLcLExpensiveObjectmUgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const map<TString,RooExpensiveObjectCache::ExpensiveObject*>*)
   {
      map<TString,RooExpensiveObjectCache::ExpensiveObject*> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(map<TString,RooExpensiveObjectCache::ExpensiveObject*>));
      static ::ROOT::TGenericClassInfo 
         instance("map<TString,RooExpensiveObjectCache::ExpensiveObject*>", -2, "map", 99,
                  typeid(map<TString,RooExpensiveObjectCache::ExpensiveObject*>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &maplETStringcORooExpensiveObjectCachecLcLExpensiveObjectmUgR_Dictionary, isa_proxy, 0,
                  sizeof(map<TString,RooExpensiveObjectCache::ExpensiveObject*>) );
      instance.SetNew(&new_maplETStringcORooExpensiveObjectCachecLcLExpensiveObjectmUgR);
      instance.SetNewArray(&newArray_maplETStringcORooExpensiveObjectCachecLcLExpensiveObjectmUgR);
      instance.SetDelete(&delete_maplETStringcORooExpensiveObjectCachecLcLExpensiveObjectmUgR);
      instance.SetDeleteArray(&deleteArray_maplETStringcORooExpensiveObjectCachecLcLExpensiveObjectmUgR);
      instance.SetDestructor(&destruct_maplETStringcORooExpensiveObjectCachecLcLExpensiveObjectmUgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::MapInsert< map<TString,RooExpensiveObjectCache::ExpensiveObject*> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const map<TString,RooExpensiveObjectCache::ExpensiveObject*>*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *maplETStringcORooExpensiveObjectCachecLcLExpensiveObjectmUgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const map<TString,RooExpensiveObjectCache::ExpensiveObject*>*)0x0)->GetClass();
      maplETStringcORooExpensiveObjectCachecLcLExpensiveObjectmUgR_TClassManip(theClass);
   return theClass;
   }

   static void maplETStringcORooExpensiveObjectCachecLcLExpensiveObjectmUgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_maplETStringcORooExpensiveObjectCachecLcLExpensiveObjectmUgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) map<TString,RooExpensiveObjectCache::ExpensiveObject*> : new map<TString,RooExpensiveObjectCache::ExpensiveObject*>;
   }
   static void *newArray_maplETStringcORooExpensiveObjectCachecLcLExpensiveObjectmUgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) map<TString,RooExpensiveObjectCache::ExpensiveObject*>[nElements] : new map<TString,RooExpensiveObjectCache::ExpensiveObject*>[nElements];
   }
   // Wrapper around operator delete
   static void delete_maplETStringcORooExpensiveObjectCachecLcLExpensiveObjectmUgR(void *p) {
      delete ((map<TString,RooExpensiveObjectCache::ExpensiveObject*>*)p);
   }
   static void deleteArray_maplETStringcORooExpensiveObjectCachecLcLExpensiveObjectmUgR(void *p) {
      delete [] ((map<TString,RooExpensiveObjectCache::ExpensiveObject*>*)p);
   }
   static void destruct_maplETStringcORooExpensiveObjectCachecLcLExpensiveObjectmUgR(void *p) {
      typedef map<TString,RooExpensiveObjectCache::ExpensiveObject*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class map<TString,RooExpensiveObjectCache::ExpensiveObject*>

namespace ROOT {
   static TClass *listlETObjectmUgR_Dictionary();
   static void listlETObjectmUgR_TClassManip(TClass*);
   static void *new_listlETObjectmUgR(void *p = 0);
   static void *newArray_listlETObjectmUgR(Long_t size, void *p);
   static void delete_listlETObjectmUgR(void *p);
   static void deleteArray_listlETObjectmUgR(void *p);
   static void destruct_listlETObjectmUgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const list<TObject*>*)
   {
      list<TObject*> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(list<TObject*>));
      static ::ROOT::TGenericClassInfo 
         instance("list<TObject*>", -2, "list", 503,
                  typeid(list<TObject*>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &listlETObjectmUgR_Dictionary, isa_proxy, 4,
                  sizeof(list<TObject*>) );
      instance.SetNew(&new_listlETObjectmUgR);
      instance.SetNewArray(&newArray_listlETObjectmUgR);
      instance.SetDelete(&delete_listlETObjectmUgR);
      instance.SetDeleteArray(&deleteArray_listlETObjectmUgR);
      instance.SetDestructor(&destruct_listlETObjectmUgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< list<TObject*> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const list<TObject*>*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *listlETObjectmUgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const list<TObject*>*)0x0)->GetClass();
      listlETObjectmUgR_TClassManip(theClass);
   return theClass;
   }

   static void listlETObjectmUgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_listlETObjectmUgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) list<TObject*> : new list<TObject*>;
   }
   static void *newArray_listlETObjectmUgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) list<TObject*>[nElements] : new list<TObject*>[nElements];
   }
   // Wrapper around operator delete
   static void delete_listlETObjectmUgR(void *p) {
      delete ((list<TObject*>*)p);
   }
   static void deleteArray_listlETObjectmUgR(void *p) {
      delete [] ((list<TObject*>*)p);
   }
   static void destruct_listlETObjectmUgR(void *p) {
      typedef list<TObject*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class list<TObject*>

namespace ROOT {
   static TClass *listlERooAbsStudymUgR_Dictionary();
   static void listlERooAbsStudymUgR_TClassManip(TClass*);
   static void *new_listlERooAbsStudymUgR(void *p = 0);
   static void *newArray_listlERooAbsStudymUgR(Long_t size, void *p);
   static void delete_listlERooAbsStudymUgR(void *p);
   static void deleteArray_listlERooAbsStudymUgR(void *p);
   static void destruct_listlERooAbsStudymUgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const list<RooAbsStudy*>*)
   {
      list<RooAbsStudy*> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(list<RooAbsStudy*>));
      static ::ROOT::TGenericClassInfo 
         instance("list<RooAbsStudy*>", -2, "list", 503,
                  typeid(list<RooAbsStudy*>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &listlERooAbsStudymUgR_Dictionary, isa_proxy, 4,
                  sizeof(list<RooAbsStudy*>) );
      instance.SetNew(&new_listlERooAbsStudymUgR);
      instance.SetNewArray(&newArray_listlERooAbsStudymUgR);
      instance.SetDelete(&delete_listlERooAbsStudymUgR);
      instance.SetDeleteArray(&deleteArray_listlERooAbsStudymUgR);
      instance.SetDestructor(&destruct_listlERooAbsStudymUgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< list<RooAbsStudy*> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const list<RooAbsStudy*>*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *listlERooAbsStudymUgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const list<RooAbsStudy*>*)0x0)->GetClass();
      listlERooAbsStudymUgR_TClassManip(theClass);
   return theClass;
   }

   static void listlERooAbsStudymUgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_listlERooAbsStudymUgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) list<RooAbsStudy*> : new list<RooAbsStudy*>;
   }
   static void *newArray_listlERooAbsStudymUgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) list<RooAbsStudy*>[nElements] : new list<RooAbsStudy*>[nElements];
   }
   // Wrapper around operator delete
   static void delete_listlERooAbsStudymUgR(void *p) {
      delete ((list<RooAbsStudy*>*)p);
   }
   static void deleteArray_listlERooAbsStudymUgR(void *p) {
      delete [] ((list<RooAbsStudy*>*)p);
   }
   static void destruct_listlERooAbsStudymUgR(void *p) {
      typedef list<RooAbsStudy*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class list<RooAbsStudy*>

namespace ROOT {
   static TClass *listlERooAbsDatamUgR_Dictionary();
   static void listlERooAbsDatamUgR_TClassManip(TClass*);
   static void *new_listlERooAbsDatamUgR(void *p = 0);
   static void *newArray_listlERooAbsDatamUgR(Long_t size, void *p);
   static void delete_listlERooAbsDatamUgR(void *p);
   static void deleteArray_listlERooAbsDatamUgR(void *p);
   static void destruct_listlERooAbsDatamUgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const list<RooAbsData*>*)
   {
      list<RooAbsData*> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(list<RooAbsData*>));
      static ::ROOT::TGenericClassInfo 
         instance("list<RooAbsData*>", -2, "list", 503,
                  typeid(list<RooAbsData*>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &listlERooAbsDatamUgR_Dictionary, isa_proxy, 4,
                  sizeof(list<RooAbsData*>) );
      instance.SetNew(&new_listlERooAbsDatamUgR);
      instance.SetNewArray(&newArray_listlERooAbsDatamUgR);
      instance.SetDelete(&delete_listlERooAbsDatamUgR);
      instance.SetDeleteArray(&deleteArray_listlERooAbsDatamUgR);
      instance.SetDestructor(&destruct_listlERooAbsDatamUgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< list<RooAbsData*> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const list<RooAbsData*>*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *listlERooAbsDatamUgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const list<RooAbsData*>*)0x0)->GetClass();
      listlERooAbsDatamUgR_TClassManip(theClass);
   return theClass;
   }

   static void listlERooAbsDatamUgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_listlERooAbsDatamUgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) list<RooAbsData*> : new list<RooAbsData*>;
   }
   static void *newArray_listlERooAbsDatamUgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) list<RooAbsData*>[nElements] : new list<RooAbsData*>[nElements];
   }
   // Wrapper around operator delete
   static void delete_listlERooAbsDatamUgR(void *p) {
      delete ((list<RooAbsData*>*)p);
   }
   static void deleteArray_listlERooAbsDatamUgR(void *p) {
      delete [] ((list<RooAbsData*>*)p);
   }
   static void destruct_listlERooAbsDatamUgR(void *p) {
      typedef list<RooAbsData*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class list<RooAbsData*>

namespace ROOT {
   static TClass *dequelERooAbsCachemUgR_Dictionary();
   static void dequelERooAbsCachemUgR_TClassManip(TClass*);
   static void *new_dequelERooAbsCachemUgR(void *p = 0);
   static void *newArray_dequelERooAbsCachemUgR(Long_t size, void *p);
   static void delete_dequelERooAbsCachemUgR(void *p);
   static void deleteArray_dequelERooAbsCachemUgR(void *p);
   static void destruct_dequelERooAbsCachemUgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const deque<RooAbsCache*>*)
   {
      deque<RooAbsCache*> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(deque<RooAbsCache*>));
      static ::ROOT::TGenericClassInfo 
         instance("deque<RooAbsCache*>", -2, "deque", 831,
                  typeid(deque<RooAbsCache*>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &dequelERooAbsCachemUgR_Dictionary, isa_proxy, 0,
                  sizeof(deque<RooAbsCache*>) );
      instance.SetNew(&new_dequelERooAbsCachemUgR);
      instance.SetNewArray(&newArray_dequelERooAbsCachemUgR);
      instance.SetDelete(&delete_dequelERooAbsCachemUgR);
      instance.SetDeleteArray(&deleteArray_dequelERooAbsCachemUgR);
      instance.SetDestructor(&destruct_dequelERooAbsCachemUgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< deque<RooAbsCache*> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const deque<RooAbsCache*>*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *dequelERooAbsCachemUgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const deque<RooAbsCache*>*)0x0)->GetClass();
      dequelERooAbsCachemUgR_TClassManip(theClass);
   return theClass;
   }

   static void dequelERooAbsCachemUgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_dequelERooAbsCachemUgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) deque<RooAbsCache*> : new deque<RooAbsCache*>;
   }
   static void *newArray_dequelERooAbsCachemUgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) deque<RooAbsCache*>[nElements] : new deque<RooAbsCache*>[nElements];
   }
   // Wrapper around operator delete
   static void delete_dequelERooAbsCachemUgR(void *p) {
      delete ((deque<RooAbsCache*>*)p);
   }
   static void deleteArray_dequelERooAbsCachemUgR(void *p) {
      delete [] ((deque<RooAbsCache*>*)p);
   }
   static void destruct_dequelERooAbsCachemUgR(void *p) {
      typedef deque<RooAbsCache*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class deque<RooAbsCache*>

namespace {
  void TriggerDictionaryInitialization_libRooFitCore_Impl() {
    static const char* headers[] = {
"Roo1DTable.h",
"RooAbsArg.h",
"RooAbsBinning.h",
"RooAbsCategory.h",
"RooAbsCategoryLValue.h",
"RooAbsCollection.h",
"RooAbsData.h",
"RooAbsFunc.h",
"RooAbsGenContext.h",
"RooAbsTestStatistic.h",
"RooAbsHiddenReal.h",
"RooAbsIntegrator.h",
"RooAbsLValue.h",
"RooAbsMCStudyModule.h",
"RooAbsOptTestStatistic.h",
"RooAbsPdf.h",
"RooAbsProxy.h",
"RooAbsReal.h",
"RooAbsRealLValue.h",
"RooAbsRootFinder.h",
"RooAbsString.h",
"RooAcceptReject.h",
"RooAdaptiveGaussKronrodIntegrator1D.h",
"RooAddGenContext.h",
"RooAddition.h",
"RooAddModel.h",
"RooAICRegistry.h",
"RooArgList.h",
"RooArgProxy.h",
"RooArgSet.h",
"RooBanner.h",
"RooBinning.h",
"RooBinnedGenContext.h",
"RooBrentRootFinder.h",
"RooCategory.h",
"RooCategoryProxy.h",
"RooCategorySharedProperties.h",
"RooCatType.h",
"RooChi2Var.h",
"RooClassFactory.h",
"RooCmdArg.h",
"RooCmdConfig.h",
"RooConstVar.h",
"RooConvCoefVar.h",
"RooConvGenContext.h",
"RooConvIntegrandBinding.h",
"RooCurve.h",
"RooCustomizer.h",
"RooDataHist.h",
"RooDataProjBinding.h",
"RooDataSet.h",
"RooDirItem.h",
"RooDLLSignificanceMCSModule.h",
"RooAbsAnaConvPdf.h",
"RooAddPdf.h",
"RooEfficiency.h",
"RooEffProd.h",
"RooExtendPdf.h",
"RooDouble.h",
"RooEffGenContext.h",
"RooEllipse.h",
"RooErrorHandler.h",
"RooErrorVar.h",
"RooFit.h",
"RooFitResult.h",
"RooFormula.h",
"RooFormulaVar.h",
"RooGaussKronrodIntegrator1D.h",
"RooGenContext.h",
"RooGenericPdf.h",
"RooGenProdProj.h",
"RooGlobalFunc.h",
"RooGrid.h",
"RooHashTable.h",
"RooHistError.h",
"RooHist.h",
"RooImproperIntegrator1D.h",
"RooBinIntegrator.h",
"RooIntegrator1D.h",
"RooIntegrator2D.h",
"RooIntegratorBinding.h",
"RooInt.h",
"RooInvTransform.h",
"RooLinearVar.h",
"RooLinkedListElem.h",
"RooLinkedList.h",
"RooLinkedListIter.h",
"RooLinTransBinning.h",
"RooList.h",
"RooListProxy.h",
"RooMapCatEntry.h",
"RooMappedCategory.h",
"RooMath.h",
"RooMCIntegrator.h",
"RooMinuit.h",
"RooMPSentinel.h",
"RooMultiCategory.h",
"RooMultiCatIter.h",
"RooNameReg.h",
"RooNameSet.h",
"RooNLLVar.h",
"RooNormSetCache.h",
"RooNumber.h",
"RooNumConvolution.h",
"RooNumConvPdf.h",
"RooNumIntConfig.h",
"RooNumIntFactory.h",
"RooPlotable.h",
"RooPlot.h",
"RooPolyVar.h",
"RooPrintable.h",
"RooProdGenContext.h",
"RooProduct.h",
"RooPullVar.h",
"RooQuasiRandomGenerator.h",
"RooRandom.h",
"RooRandomizeParamMCSModule.h",
"RooRangeBinning.h",
"RooRealAnalytic.h",
"RooRealBinding.h",
"RooRealConstant.h",
"RooRealIntegral.h",
"RooRealMPFE.h",
"RooRealProxy.h",
"RooRealVar.h",
"RooRealVarSharedProperties.h",
"RooRefCountList.h",
"RooScaledFunc.h",
"RooSegmentedIntegrator1D.h",
"RooSegmentedIntegrator2D.h",
"RooSetPair.h",
"RooSetProxy.h",
"RooSharedProperties.h",
"RooSharedPropertiesList.h",
"RooSimGenContext.h",
"RooSimSplitGenContext.h",
"RooStreamParser.h",
"RooStringVar.h",
"RooSuperCategory.h",
"RooTable.h",
"RooThreshEntry.h",
"RooThresholdCategory.h",
"RooTObjWrap.h",
"RooTrace.h",
"RooUniformBinning.h",
"RooSimultaneous.h",
"RooRealSumPdf.h",
"RooResolutionModel.h",
"RooProdPdf.h",
"RooMCStudy.h",
"RooSimPdfBuilder.h",
"RooTruthModel.h",
"RooMsgService.h",
"RooProjectedPdf.h",
"RooWorkspace.h",
"RooProfileLL.h",
"RooAbsCachedPdf.h",
"RooAbsSelfCachedPdf.h",
"RooHistPdf.h",
"RooCachedPdf.h",
"RooFFTConvPdf.h",
"RooDataHistSliceIter.h",
"RooCacheManager.h",
"RooAbsCache.h",
"RooAbsCacheElement.h",
"RooObjCacheManager.h",
"RooExtendedTerm.h",
"RooSentinel.h",
"RooParamBinning.h",
"RooConstraintSum.h",
"RooRecursiveFraction.h",
"RooDataWeightedAverage.h",
"RooSimWSTool.h",
"RooFracRemainder.h",
"RooAbsCachedReal.h",
"RooAbsSelfCachedReal.h",
"RooCachedReal.h",
"RooNumCdf.h",
"RooChangeTracker.h",
"RooNumRunningInt.h",
"RooHistFunc.h",
"RooExpensiveObjectCache.h",
"RooBinningCategory.h",
"RooCintUtils.h",
"RooFactoryWSTool.h",
"RooTFoamBinding.h",
"RooFunctor.h",
"RooDerivative.h",
"RooGenFunction.h",
"RooMultiGenFunction.h",
"RooAdaptiveIntegratorND.h",
"RooAbsNumGenerator.h",
"RooFoamGenerator.h",
"RooNumGenConfig.h",
"RooNumGenFactory.h",
"RooMultiVarGaussian.h",
"RooXYChi2Var.h",
"RooAbsDataStore.h",
"RooTreeDataStore.h",
"RooTreeData.h",
"RooMinimizer.h",
"RooMinimizerFcn.h",
"RooMoment.h",
"RooStudyManager.h",
"RooAbsStudy.h",
"RooGenFitStudy.h",
"RooProofDriverSelector.h",
"RooStudyPackage.h",
"RooCompositeDataStore.h",
"RooRangeBoolean.h",
"RooVectorDataStore.h",
"RooUnitTest.h",
"RooExtendedBinding.h",
"RooAbsMoment.h",
"RooFirstMoment.h",
"RooSecondMoment.h",
0
    };
    static const char* includePaths[] = {
0
    };
    static const char* fwdDeclCode = nullptr;
    static const char* payloadCode = R"DICTPAYLOAD(
#line 1 "libRooFitCore dictionary payload"

#ifndef G__VECTOR_HAS_CLASS_ITERATOR
  #define G__VECTOR_HAS_CLASS_ITERATOR 1
#endif

#define _BACKWARD_BACKWARD_WARNING_H
#include "Roo1DTable.h"
#include "RooAbsArg.h"
#include "RooAbsBinning.h"
#include "RooAbsCategory.h"
#include "RooAbsCategoryLValue.h"
#include "RooAbsCollection.h"
#include "RooAbsData.h"
#include "RooAbsFunc.h"
#include "RooAbsGenContext.h"
#include "RooAbsTestStatistic.h"
#include "RooAbsHiddenReal.h"
#include "RooAbsIntegrator.h"
#include "RooAbsLValue.h"
#include "RooAbsMCStudyModule.h"
#include "RooAbsOptTestStatistic.h"
#include "RooAbsPdf.h"
#include "RooAbsProxy.h"
#include "RooAbsReal.h"
#include "RooAbsRealLValue.h"
#include "RooAbsRootFinder.h"
#include "RooAbsString.h"
#include "RooAcceptReject.h"
#include "RooAdaptiveGaussKronrodIntegrator1D.h"
#include "RooAddGenContext.h"
#include "RooAddition.h"
#include "RooAddModel.h"
#include "RooAICRegistry.h"
#include "RooArgList.h"
#include "RooArgProxy.h"
#include "RooArgSet.h"
#include "RooBanner.h"
#include "RooBinning.h"
#include "RooBinnedGenContext.h"
#include "RooBrentRootFinder.h"
#include "RooCategory.h"
#include "RooCategoryProxy.h"
#include "RooCategorySharedProperties.h"
#include "RooCatType.h"
#include "RooChi2Var.h"
#include "RooClassFactory.h"
#include "RooCmdArg.h"
#include "RooCmdConfig.h"
#include "RooConstVar.h"
#include "RooConvCoefVar.h"
#include "RooConvGenContext.h"
#include "RooConvIntegrandBinding.h"
#include "RooCurve.h"
#include "RooCustomizer.h"
#include "RooDataHist.h"
#include "RooDataProjBinding.h"
#include "RooDataSet.h"
#include "RooDirItem.h"
#include "RooDLLSignificanceMCSModule.h"
#include "RooAbsAnaConvPdf.h"
#include "RooAddPdf.h"
#include "RooEfficiency.h"
#include "RooEffProd.h"
#include "RooExtendPdf.h"
#include "RooDouble.h"
#include "RooEffGenContext.h"
#include "RooEllipse.h"
#include "RooErrorHandler.h"
#include "RooErrorVar.h"
#include "RooFit.h"
#include "RooFitResult.h"
#include "RooFormula.h"
#include "RooFormulaVar.h"
#include "RooGaussKronrodIntegrator1D.h"
#include "RooGenContext.h"
#include "RooGenericPdf.h"
#include "RooGenProdProj.h"
#include "RooGlobalFunc.h"
#include "RooGrid.h"
#include "RooHashTable.h"
#include "RooHistError.h"
#include "RooHist.h"
#include "RooImproperIntegrator1D.h"
#include "RooBinIntegrator.h"
#include "RooIntegrator1D.h"
#include "RooIntegrator2D.h"
#include "RooIntegratorBinding.h"
#include "RooInt.h"
#include "RooInvTransform.h"
#include "RooLinearVar.h"
#include "RooLinkedListElem.h"
#include "RooLinkedList.h"
#include "RooLinkedListIter.h"
#include "RooLinTransBinning.h"
#include "RooList.h"
#include "RooListProxy.h"
#include "RooMapCatEntry.h"
#include "RooMappedCategory.h"
#include "RooMath.h"
#include "RooMCIntegrator.h"
#include "RooMinuit.h"
#include "RooMPSentinel.h"
#include "RooMultiCategory.h"
#include "RooMultiCatIter.h"
#include "RooNameReg.h"
#include "RooNameSet.h"
#include "RooNLLVar.h"
#include "RooNormSetCache.h"
#include "RooNumber.h"
#include "RooNumConvolution.h"
#include "RooNumConvPdf.h"
#include "RooNumIntConfig.h"
#include "RooNumIntFactory.h"
#include "RooPlotable.h"
#include "RooPlot.h"
#include "RooPolyVar.h"
#include "RooPrintable.h"
#include "RooProdGenContext.h"
#include "RooProduct.h"
#include "RooPullVar.h"
#include "RooQuasiRandomGenerator.h"
#include "RooRandom.h"
#include "RooRandomizeParamMCSModule.h"
#include "RooRangeBinning.h"
#include "RooRealAnalytic.h"
#include "RooRealBinding.h"
#include "RooRealConstant.h"
#include "RooRealIntegral.h"
#include "RooRealMPFE.h"
#include "RooRealProxy.h"
#include "RooRealVar.h"
#include "RooRealVarSharedProperties.h"
#include "RooRefCountList.h"
#include "RooScaledFunc.h"
#include "RooSegmentedIntegrator1D.h"
#include "RooSegmentedIntegrator2D.h"
#include "RooSetPair.h"
#include "RooSetProxy.h"
#include "RooSharedProperties.h"
#include "RooSharedPropertiesList.h"
#include "RooSimGenContext.h"
#include "RooSimSplitGenContext.h"
#include "RooStreamParser.h"
#include "RooStringVar.h"
#include "RooSuperCategory.h"
#include "RooTable.h"
#include "RooThreshEntry.h"
#include "RooThresholdCategory.h"
#include "RooTObjWrap.h"
#include "RooTrace.h"
#include "RooUniformBinning.h"
#include "RooSimultaneous.h"
#include "RooRealSumPdf.h"
#include "RooResolutionModel.h"
#include "RooProdPdf.h"
#include "RooMCStudy.h"
#include "RooSimPdfBuilder.h"
#include "RooTruthModel.h"
#include "RooMsgService.h"
#include "RooProjectedPdf.h"
#include "RooWorkspace.h"
#include "RooProfileLL.h"
#include "RooAbsCachedPdf.h"
#include "RooAbsSelfCachedPdf.h"
#include "RooHistPdf.h"
#include "RooCachedPdf.h"
#include "RooFFTConvPdf.h"
#include "RooDataHistSliceIter.h"
#include "RooCacheManager.h"
#include "RooAbsCache.h"
#include "RooAbsCacheElement.h"
#include "RooObjCacheManager.h"
#include "RooExtendedTerm.h"
#include "RooSentinel.h"
#include "RooParamBinning.h"
#include "RooConstraintSum.h"
#include "RooRecursiveFraction.h"
#include "RooDataWeightedAverage.h"
#include "RooSimWSTool.h"
#include "RooFracRemainder.h"
#include "RooAbsCachedReal.h"
#include "RooAbsSelfCachedReal.h"
#include "RooCachedReal.h"
#include "RooNumCdf.h"
#include "RooChangeTracker.h"
#include "RooNumRunningInt.h"
#include "RooHistFunc.h"
#include "RooExpensiveObjectCache.h"
#include "RooBinningCategory.h"
#include "RooCintUtils.h"
#include "RooFactoryWSTool.h"
#include "RooTFoamBinding.h"
#include "RooFunctor.h"
#include "RooDerivative.h"
#include "RooGenFunction.h"
#include "RooMultiGenFunction.h"
#include "RooAdaptiveIntegratorND.h"
#include "RooAbsNumGenerator.h"
#include "RooFoamGenerator.h"
#include "RooNumGenConfig.h"
#include "RooNumGenFactory.h"
#include "RooMultiVarGaussian.h"
#include "RooXYChi2Var.h"
#include "RooAbsDataStore.h"
#include "RooTreeDataStore.h"
#include "RooTreeData.h"
#include "RooMinimizer.h"
#include "RooMinimizerFcn.h"
#include "RooMoment.h"
#include "RooStudyManager.h"
#include "RooAbsStudy.h"
#include "RooGenFitStudy.h"
#include "RooProofDriverSelector.h"
#include "RooStudyPackage.h"
#include "RooCompositeDataStore.h"
#include "RooRangeBoolean.h"
#include "RooVectorDataStore.h"
#include "RooUnitTest.h"
#include "RooExtendedBinding.h"
#include "RooAbsMoment.h"
#include "RooFirstMoment.h"
#include "RooSecondMoment.h"

#undef  _BACKWARD_BACKWARD_WARNING_H
)DICTPAYLOAD";
    static const char* classesHeaders[]={
nullptr};

    static bool isInitialized = false;
    if (!isInitialized) {
      TROOT::RegisterModule("libRooFitCore",
        headers, includePaths, payloadCode, fwdDeclCode,
        TriggerDictionaryInitialization_libRooFitCore_Impl, {}, classesHeaders);
      isInitialized = true;
    }
  }
  static struct DictInit {
    DictInit() {
      TriggerDictionaryInitialization_libRooFitCore_Impl();
    }
  } __TheDictionaryInitializer;
}
void TriggerDictionaryInitialization_libRooFitCore() {
  TriggerDictionaryInitialization_libRooFitCore_Impl();
}
